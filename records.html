<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0050)records.html#./records:h0 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf8">
<title>Записи</title>
<link href="./records_files/tspl.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g138"></a>
<a name="./records:h0"></a>

<div>
<img  src="./records_files/ch9.png">
</div>
<h1>Chapter 9. Записи<a name="CHPTRECORDS"></a></h1>

<p>
<a name="./records:s0"></a><a name="./records:s1"></a><a name="./records:s2"></a>
В этой главе описываются способы, с помощью которых программист может определять
новый типы данных, или типы записей(<i>records types</i>), каждый из которых 
отличается от всех других типов.
Тип записи определяет количество и имена полей, которые имеет каждый экземпляр
типа. Записи определяются с помощью формы <tt>define-record-type</tt> или
процедуры <tt>make-record-type-descriptor</tt>.

</p><p>

</p><h3><a name="g139"></a><a name="./records:h1"></a>Section 9.1. Объявление(определение) Записей<a name="SECTRECORDDEFINITION"></a></h3>

<p>
Форма <tt>define-record-type</tt> определяет новый тип записи и вместе с ним
процедуру конструктора для этого типа записи, предикат типа, который возвращает
истину только для данного типа записи, процедуры доступа для каждого поля и
процедуру присваивания для каждого изменяемого поля. Например,
определение

</p><p>

</p><p><tt>(define-record-type&nbsp;point&nbsp;(fields&nbsp;x&nbsp;y))</tt>
</p><p>создает запись типа <tt>point</tt> с двумя полями, <tt>x</tt>
и <tt>y</tt>, и определяет следующие процедуры:

</p><p>
</p><table><tbody><tr><td nowrap="" align="left">
<tt>(make-point&nbsp;<i>x</i>&nbsp;<i>y</i>)</tt> </td><td nowrap="" align="left"> constructor</td></tr><tr><td nowrap="" align="left">
<tt>(point?&nbsp;<i>obj</i>)</tt> </td><td nowrap="" align="left"> predicate</td></tr><tr><td nowrap="" align="left">
<tt>(point-x&nbsp;<i>p</i>)</tt> </td><td nowrap="" align="left"> accessor for field <tt>x</tt></td></tr><tr><td nowrap="" align="left">
<tt>(point-y&nbsp;<i>p</i>)</tt> </td><td nowrap="" align="left"> accessor for field <tt>y</tt>
</td></tr></tbody></table>

<p>
Используя это определение, мы можем использовать эти процедуры для создания и
управления записями типа <tt>point</tt>, как показано ниже.

</p><p>

</p><p><tt>(define&nbsp;p&nbsp;(make-point&nbsp;36&nbsp;-17))<br>

(point?&nbsp;p)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#t<br>

(point?&nbsp;'(cons&nbsp;36&nbsp;-17))&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#f<br>

(point-x&nbsp;p)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;36<br>

(point-y&nbsp;p)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;-17</tt>
</p><p>Поля не изменяемы, по умолчанию, но могут быть объявлены изменяемыми.
В альтернативном определениии <tt>point</tt>, данном ниже, поле <tt>x</tt>
изменяемо, а  <tt>y</tt> остается неизменяемым.

</p><p>

</p><p><tt>(define-record-type&nbsp;point&nbsp;(fields&nbsp;(mutable&nbsp;x)&nbsp;y))</tt>
</p><p>В этом случае, <tt>define-record-type</tt> определяет процедуру изменения(изменятель)
для поля <tt>x</tt> в дополнение к другим процедурам показанным выше.

</p><p>
</p><table><tbody><tr><td nowrap="" align="left">
<tt>(point-x-set!&nbsp;<i>p</i>&nbsp;<i>x</i>)</tt> </td><td nowrap="" align="left"> процедура изменения поля <tt>x</tt>
</td></tr></tbody></table>

<p>
Процедура изменения может использоваться для изменения содержимого поля <tt>x</tt>.

</p><p>

</p><p><tt>(define&nbsp;p&nbsp;(make-point&nbsp;36&nbsp;-17))<br>

(point-x-set!&nbsp;p&nbsp;(-&nbsp;(point-x&nbsp;p)&nbsp;12))<br>

(point-x&nbsp;p)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;24</tt>
</p><p>Поле может быть объявлено неизменяемым для ясности; определение <tt>point</tt> 
ниже эквивалентно приведенному выше второму определению.

</p><p>

</p><p><tt>(define-record-type&nbsp;point&nbsp;(fields&nbsp;(mutable&nbsp;x)&nbsp;(immutable&nbsp;y)))</tt>
</p><p>Имена процедур, определяемых <tt>define-record-type</tt> следуют
стандартным правилам именования, проилюстрированными вышеприведенными примерами,
но программист может , если это необходимо, переопределить значения по умолчанию.
При следующем определении <tt>point</tt>, конструктор называется <tt>mkpoint</tt>, 
предикат типа <tt>ispoint?</tt>, и процедуры доступа
для <tt>x</tt> и <tt>y</tt> как <tt>x-val</tt> и <tt>y-val</tt>.
Процедура изменения для <tt>x</tt> называется <tt>set-x-val!</tt>.

</p><p>

</p><p><tt>(define-record-type&nbsp;(point&nbsp;mkpoint&nbsp;ispoint?)<br>

&nbsp;&nbsp;(fields&nbsp;(mutable&nbsp;x&nbsp;x-val&nbsp;set-x-val!)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(immutable&nbsp;y&nbsp;y-val)))</tt>
</p><p>По умолчанию определение записи создает новый тип каждый раз, когда оно вычисляется, как показано
в примере ниже.

</p><p>

</p><p><tt>(define&nbsp;(f&nbsp;p)<br>

&nbsp;&nbsp;(define-record-type&nbsp;point&nbsp;(fields&nbsp;x&nbsp;y))<br>

&nbsp;&nbsp;(if&nbsp;(eq?&nbsp;p&nbsp;'make)&nbsp;(make-point&nbsp;3&nbsp;4)&nbsp;(point?&nbsp;p)))<br>

(f&nbsp;(f&nbsp;'make))&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#f</tt>
</p><p>Первый (внутренний) вызов <tt>f</tt> возвращает записть созданного внутри типа point <tt><i>p</i></tt>, 
которая передается в <tt>f</tt> во второй (внешний) вызов, который применяет
предикат <tt>point?</tt> к <tt><i>p</i></tt>.
Это предикат <tt>point?</tt> ищущий тип point созданный во время второго
вызова, в то время как <tt><i>p</i></tt> это имеет тип point созданный
во время первого вызова.
Так что <tt>point?</tt> возвращает <tt>#f</tt>.

</p><p>
<a name="./records:s3"></a><a name="./records:s4"></a><a name="./records:s5"></a>Данное поведение по умолчанию генерирующее(<i>generative</i>) может быть переопределено включением предложения
<tt>nongenerative</tt> в определение записи.

</p><p>

</p><p><tt>(define&nbsp;(f&nbsp;p)<br>

&nbsp;&nbsp;(define-record-type&nbsp;point&nbsp;(fields&nbsp;x&nbsp;y)&nbsp;(nongenerative))<br>

&nbsp;&nbsp;(if&nbsp;(eq?&nbsp;p&nbsp;'make)&nbsp;(make-point&nbsp;3&nbsp;4)&nbsp;(point?&nbsp;p)))<br>

(define&nbsp;p&nbsp;(f&nbsp;'make))<br>

(f&nbsp;p)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#t</tt>
</p><p>Типы записей, созданные таким образом, по прежнему отличаются от типов записей,
созданных определениями в другой части программы, даже если определения
синтаксически  идентичны:

</p><p>

</p><p><tt>(define&nbsp;(f)<br>

&nbsp;&nbsp;(define-record-type&nbsp;point&nbsp;(fields&nbsp;x&nbsp;y)&nbsp;(nongenerative))<br>

&nbsp;&nbsp;(make-point&nbsp;3&nbsp;4))<br>

(define&nbsp;(g&nbsp;p)<br>

&nbsp;&nbsp;(define-record-type&nbsp;point&nbsp;(fields&nbsp;x&nbsp;y)&nbsp;(nongenerative))<br>

&nbsp;&nbsp;(point?&nbsp;p))<br>

(g&nbsp;(f))&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#f</tt>
</p><p><a name="./records:s6"></a><a name="page:record-uid"></a>Но и это можно переопределить, включив
uid (уникальный идентификатор - unique id) в
предложение <tt>nongenerative</tt>:

</p><p>

</p><p><tt>(define&nbsp;(f)<br>

&nbsp;&nbsp;(define-record-type&nbsp;point&nbsp;(fields&nbsp;x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(nongenerative&nbsp;really-the-same-point))<br>

&nbsp;&nbsp;(make-point&nbsp;3&nbsp;4))<br>

(define&nbsp;(g&nbsp;p)<br>

&nbsp;&nbsp;(define-record-type&nbsp;point&nbsp;(fields&nbsp;x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(nongenerative&nbsp;really-the-same-point))<br>

&nbsp;&nbsp;(point?&nbsp;p))<br>

(g&nbsp;(f))&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#t</tt>
</p><p>uid может быть любым идентификатором, но программистам предлагается выбирать
uid из пространства имен RFC&nbsp;4122 UUID namespace&nbsp;[<a class="citation" href="bibliography.html#g238">20</a>],
возмножно с именем типа записи в качестве префикса.

</p><p>
<a name="./records:s7"></a><a name="./records:s8"></a><a name="./records:s9"></a><a name="./records:s10"></a><a name="page:parent-type"></a>Тип записи может быть определен как подтип
существующего "родительского(parent)" типа с предложением <tt>parent</tt>,
которое объявляет имя существующего типа записи.
Если указан родительский тип, новый "дочерний(child)" тип записи наследует
поля родительского типа записи и каждый экзепляр дочернего типа считается
экземпляром  родительского типа, так что процедуры доступа и изменения
для родительского типа могут использоваться для экземпляров дочернего
типа.

</p><p>

</p><p><tt>(define-record-type&nbsp;point&nbsp;(fields&nbsp;x&nbsp;y))<br>

(define-record-type&nbsp;cpoint&nbsp;(parent&nbsp;point)&nbsp;(fields&nbsp;color))</tt>
</p><p>Дочерний тип имеет все поля родительского типа, а также дополнительные поля,
объявленные в определении дочернего типа.
Это отражается в конструкторе для <tt>cpoint</tt>, который теперь
принимает три аргумента, за которыми следует дочерний аргумент.

</p><p>

</p><p><tt>(define&nbsp;cp&nbsp;(make-cpoint&nbsp;3&nbsp;4&nbsp;'red))</tt>
</p><p>Запись дочернего типа считается записью родительского типа, но
запись родительского типа не является записью нового(дочернего) типа.

</p><p>

</p><p><tt>(point?&nbsp;(make-cpoint&nbsp;3&nbsp;4&nbsp;'red))&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#t<br>

(cpoint?&nbsp;(make-point&nbsp;3&nbsp;4))&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#f</tt>
</p><p>Создается только одна новая процедура достпуа для <tt>cpoint</tt>, для нового
поля <tt>color</tt>.
Существующие процедуры доступа и изменения для родительского типа могут использоваться для доступа
и изменения родительских полей дочернего типа.

</p><p>

</p><p><tt>(define&nbsp;cp&nbsp;(make-cpoint&nbsp;3&nbsp;4&nbsp;'red))<br>

(point-x&nbsp;cp)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;3<br>

(point-y&nbsp;cp)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;4<br>

(cpoint-color&nbsp;cp)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;red</tt>
</p><p><a name="./records:s11"></a><a name="page:protocols"></a>Как показывают примеры,
приведенные до сих пор, конструктор по умолчанию, определяемый  <tt>define-record-type</tt>
принимает столько аргументов, сколько полей есть в записи, включая поля родителя, и т.д.
Программист может переопределить умолчания и указать аргументы конструктору для
нового типа и как он определяет начальные значения создаваемых полей записи, через
предложение <tt>protocol</tt>.
Следующее определение создает запись <tt>point</tt> с тремя полями:
<tt>x</tt>, <tt>y</tt>, и <tt>d</tt>, где <tt>d</tt>
представляет смещение от начала координат.
Конструктор по прежнему принимает только два аргумента, значения <tt>x</tt> и
<tt>y</tt> и инициализирует <tt>d</tt> квадратным корнем из суммы
квадратов <tt>x</tt> и <tt>y</tt>.

</p><p>

</p><p><tt>(define-record-type&nbsp;point<br>

&nbsp;&nbsp;(fields&nbsp;x&nbsp;y&nbsp;d)<br>

&nbsp;&nbsp;(protocol<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(new)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(new&nbsp;x&nbsp;y&nbsp;(sqrt&nbsp;(+&nbsp;(*&nbsp;x&nbsp;x)&nbsp;(*&nbsp;y&nbsp;y))))))))
<br>
<br>
(define&nbsp;p&nbsp;(make-point&nbsp;3&nbsp;4))<br>

(point-x&nbsp;p)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;3<br>

(point-y&nbsp;p)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;4<br>

(point-d&nbsp;p)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;5</tt>
</p><p>Процедурное значение выражения в предложении <tt>protocol</tt>
получает в качестве аргумента примитивный конструктор <tt><i>new</i></tt> и
возвращает законченный конструктор <tt><i>c</i></tt>.
По сути нет ограничений на то, что разрешено делать <tt><i>c</i></tt>, но если
он возвращается, он должен вернуть результат вызова <tt><i>new</i></tt>.
Прежде чем он это сделает, он может изменить новый экземпляр записи(если тип
записи имеет изменяемые поля), зарегистрировать его с помощью некоторого внешнего
обработчика, распечатать сообщения и т.д.
В этом случае, <tt><i>c</i></tt> принимает два аргумента, <tt><i>x</i></tt> и <tt><i>y</i></tt>, и
применяет <tt><i>new</i></tt> к <tt><i>x</i></tt>, <tt><i>y</i></tt>, и результату вычисления
смещения от начала координат на основе <tt><i>x</i></tt> и <tt><i>y</i></tt>.

</p><p>
Если указана родительская запись, протокол конструктора становиться более активным.
Следующее определение <tt>cpoint</tt> предполагает, что <tt>point</tt>
определена как показано выше.

</p><p>

</p><p><tt>(define-record-type&nbsp;cpoint<br>

&nbsp;&nbsp;(parent&nbsp;point)<br>

&nbsp;&nbsp;(fields&nbsp;color)<br>

&nbsp;&nbsp;(protocol<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(pargs-&gt;new)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(c&nbsp;x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((pargs-&gt;new&nbsp;x&nbsp;y)&nbsp;c)))))
<br>
<br>
(define&nbsp;cp&nbsp;(make-cpoint&nbsp;'red&nbsp;3&nbsp;4))<br>

(point-x&nbsp;cp)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;3<br>

(point-y&nbsp;cp)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;4<br>

(point-d&nbsp;cp)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;5<br>

(cpoint-color&nbsp;cp)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;red</tt>
</p><p>Поскольку присутствует предложение - родитель(parent), значение выражения процедуры в
предложении <tt>protocol</tt> получает процедуру <tt><i>pargs</i>-&gt;<i>new</i></tt>
которая при применении к родительским аргументам возвращает процедуру <tt><i>new</i></tt>.
Процедура <tt><i>new</i></tt>, когда передаются значения дочерних полей,
возвращает результат применения родительского протокола к соответствующей
процедуре <tt><i>new</i></tt>.
В этом случае, <tt><i>pargs</i>-&gt;<i>new</i></tt> передаются значения второго и третьего
аргументов дочернего конструктора (значения <tt><i>x</i></tt> и <tt><i>y</i></tt>),
а полученной процедуре <tt><i>new</i></tt> передаются значения первого аргумента
дочернего конструктора (цвет).
Таким образом, протокол представленный в этом примере, эффективно отменяет нормальный
порядок аргументов, в котором родительские аргументы приходят перед дочерними аргументами,
при организации передачи вперед аргументов необходимых родительскому протоколу.

</p><p>
<a name="./records:s12"></a>По умолчанию протокол эквивалентен следующему выражению

</p><p>

</p><p><tt>(lambda&nbsp;(new)&nbsp;new)</tt>
</p><p>для типов записей не имеющих родителей, в то время как для типов записей имеющих родителей
протокол по умолчанию эквивалентен следующему

</p><p>

</p><p><tt>(lambda&nbsp;(pargs-&gt;new)<br>

&nbsp;&nbsp;(lambda&nbsp;(<i>x<sub>1</sub></i>&nbsp;...&nbsp;<i>x<sub>n</sub></i>&nbsp;<i>y<sub>1</sub></i>&nbsp;...&nbsp;<i>y<sub>m</sub></i>)<br>

&nbsp;&nbsp;&nbsp;&nbsp;((pargs-&gt;new&nbsp;<i>x<sub>1</sub></i>&nbsp;...&nbsp;<i>x<sub>n</sub></i>)&nbsp;<i>y<sub>1</sub></i>&nbsp;...&nbsp;<i>y<sub>m</sub></i>)))</tt>
</p><p>где <tt><i>n</i></tt> это число родительских (включая родителей родителя, и т.д.) полей
и <tt><i>m</i></tt> это число дочерних полей.

</p><p>
Использование предложения <tt>protocol</tt> изолирует определение дочерней записи
от некоторых измений в типе родительской записи.
Определение родителя может быть изменено добавлением или удалением полей или даже
добавлением, удалением или изменением родительского элемента(изменение родителя родителя),
но дочерний протокол и конструктор не должны изменяться если родительский протокол
не изменяется.

</p><p>
Дополнительные подробные сведения и опции для <tt>define-record-type</tt> приведены
в его формальном описании ниже.

</p><p>
<a name="./records:s13"></a><span class="formdef"><b>syntax</b>: <tt>(define-record-type&nbsp;<i>record-name</i>&nbsp;<i>clause</i>&nbsp;...)</tt></span>
<br>
<span class="formdef"><b>syntax</b>: <tt>(define-record-type&nbsp;(<i>record-name</i>&nbsp;<i>constructor</i>&nbsp;<i>pred</i>)&nbsp;<i>clause</i>&nbsp;...)</tt></span>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;syntactic)</tt>, <tt>(rnrs)</tt>

</p><p>Форма <tt>define-record-type</tt> или <i>определение записи(record definition)</i>, 
является определением и может появляться везде, где могут появляться другие определения.
Она определяет тип записи, идентифцированный <tt><i>record-name</i></tt>, плюс предикат,
конструктор, процедуры доступа и процедуры изменения для данного типа записи.
Если определение записи принимает первую форму(выше), имена конструктора и предиката
выводятся из <tt><i>record-name</i></tt>: <tt>make-<i>record-name</i></tt>
для конструктора и <tt><i>record-name</i>?</tt> для предиката.
Если определение записи принимает вторую форму(выше), именем конструктора является
<tt><i>constructor</i></tt> и именем предиката является <tt><i>pred</i></tt>.
Все имена определенные определением записи, имеют область видимости где появляется
определение записи.

</p><p>
Предложения <tt><i>clause</i>&nbsp;...</tt> определения записи определяют
поля записи и имена процедур доступа к ним и процедур их изменения;
ее родительский тип, если таковой имеется; протокол констурирования;
является ли запись nongenerative, и если так, то указан ли ее uid;
является ли запись sealed; является ли запись непрозрачной(opaque).
Синтаксис и влияние каждого предложения описаны ниже.

</p><p>
Ни одно из предложений не является обязательным; таким образом, самым простым определением
записи является

</p><p>

</p><p><tt>(define-record-type&nbsp;<i>record-name</i>)</tt>
</p><p>которое определяет новый, генеративный(generative), незапечатанный(non-sealed), прозрачный(non-opaque)
тип записи не имеющей родителя и не имеющую полей, плюс конструктор без аргументов и предикат.

</p><p>
Не более одного предложения каждого типа могут присутствовать в наборе предложений, и
если присутствует предожение <tt>parent</tt> предложение <tt>parent-rtd</tt> должно отсутствовать.
Представленные предложения могут появляться в любом порядке.

</p><p>
</p><p><b>Предложение описания полей(Fields clause).</b>&nbsp;&nbsp;A <tt>(fields&nbsp;<i>field-spec</i>&nbsp;...)</tt>
предложение объявляет поля типа записи.
Каждое <tt><i>field-spec</i></tt> должно принимать одну из следующих форм:

</p><p>

</p><p><tt><i>field-name</i><br>

(immmutable&nbsp;<i>field-name</i>)<br>

(mutable&nbsp;<i>field-name</i>)<br>

(immmutable&nbsp;<i>field-name</i>&nbsp;<i>accessor-name</i>)<br>

(mutable&nbsp;<i>field-name</i>&nbsp;<i>accessor-name</i>&nbsp;<i>mutator-name</i>)</tt>
</p><p>где <tt><i>field-name</i></tt>, <tt><i>accessor-name</i></tt>, и <tt><i>mutator-name</i></tt> являются
идентификаторами.
Первая форма, <tt><i>field-name</i></tt>, эквивалентна <tt>(immutable&nbsp;<i>field-name</i>)</tt>.
Значение поля, объявленного неизменяемым(immutable) не может быть изменено, и для него не создается
процедура изменения(mutator).
В первых трех формах, именем процедуры доступа является <tt><i>rname</i>-<i>fname</i></tt>, 
где <tt><i>rname</i></tt> это имя записи и <tt><i>fname</i></tt> это имя поля.
В третьей форме, имя процедуры доступа является <tt><i>rname</i>-<i>fname</i>-set!</tt>.
Четвертая и пятая формы явно объявляют имена процедур доступа(accessor) и процедур
записи(mutator).

</p><p>
Если предложение  <tt>fields</tt> отсутстует или список <tt><i>field-spec</i>&nbsp;...</tt>
пустой, тип записи не имеет полей (кроме родительских полей, если они есть).

</p><p>
</p><p><b>Предложение описания Родителя(Parent clause).</b>&nbsp;&nbsp;A <tt>(parent&nbsp;<i>parent-name</i>)</tt> предложение объявляет тип родительской записи;
<tt><i>parent-name</i></tt> должно быть именем не запечатанного типа записи, ранее определенного
с помощью <tt>define-record-type</tt>.
Экземпляры типа записи также считаются экземплярами своего родительского типа записи
и имеют все поля своего родительского типа записи в дополнение к объявленным
в предложении  <tt>fields</tt>.

</p><p>
</p><p><b>Предложения описания генерации(Nongenerative clause).</b>&nbsp;&nbsp;Предложение <tt>nongenerative</tt> 
может иметь две формы:

</p><p>

</p><p><tt>(nongenerative)<br>

(nongenerative&nbsp;<i>uid</i>)</tt>
</p><p>где <tt><i>uid</i></tt> является символом.
Первая форма эквивалентна второй, с uid генерируемым реализацией
в момент макрорасширения.
Когда вычисляется форма <tt>define-record-type</tt> с предложением nongenerative,
новый тип создается тогда и только тогда, когда uid не является uid-ом
существующего типа записи.

</p><p>
Если это uid of существующего типа записи, родитель, имена полей, свойство sealed,
и свойство opaque должны соответствовать следующим образом.

</p><p>
</p><ul>
<li>Если родитель указан, существующий тип записи должен иметь один и тот же
родительский rtd (по <tt>eqv?</tt>).
Если родитель не указан, существующий тип записи не должен иметь родителя.

<p>
</p></li><li>Необходимо указать одинаковое количество полей с одинаковыми именами и
в том же порядке, а изменчивость каждого поля должна быть одинаковой.

<p>
</p></li><li>Если присутствует предложение <tt>(sealed&nbsp;#t)</tt>, существующий тип записи
должен быть запечатан(sealed).
В противном случае, существущий тип записи не должен быть запечатан.

<p>
</p></li><li>Если присутствует предложение <tt>(opaque&nbsp;#t)</tt>, существующий тип записи
должен быть непрозрачным(opaque).
В противном случае, существующий тип записи должен быть непрозрачным(opaque) тогда и только тогда,
когда указан непрозрачный(opaque) родительский тип.
</li></ul>
<p>

</p><p>
Если эти ограничения выполнены, новый тип записи не создается, а другие
продукты определения типа записи(конструктор, предикат, процедуры доступа,
процедуры изменения) работают с записями существующего типа.
Если эти ограничения не выполняются, реализация может рассматривать это
как нарушение синтаксиса, или может вызвать исключение во время выполнения
с условием типа <tt>&amp;assertion</tt>.

</p><p>
С первой формой предложения <tt>nongenerative</tt>, генерируемый
uid может быть uid существующего типа записи только в том случае,
если одно и тоже определение выполняется несколько раз, например,
если оно появляется в теле процедуры, которая вызывается 
несколько раз.

</p><p>
Если <tt><i>uid</i></tt> не является uid-ом сущетствующего типа записи или если
не отсутствует предложение <tt>nongenerative</tt> , создается новый тип записи.

</p><p>
</p><p><b>Предложение протокола(Protocol clause).</b>&nbsp;&nbsp;A <tt>(protocol&nbsp;<i>expression</i>)</tt> определяет протокол который сгенерированный конструктор использует для создания
экземпляров данного типа записи.
Он должен вычислять процедуру, и эта процедура должна быть подходящим протоколом
для типа записи, как описано на странице
&nbsp;<a href="records.html#page:protocols">326</a>.

</p><p>
</p><p><b>Предложение печати(Sealed clause).</b>&nbsp;&nbsp;<a name="./records:s14"></a><a name="page:sealed"></a>
Предложение <tt>sealed</tt> формы <tt>(sealed&nbsp;#t)</tt> объявляет что
тип записи является запечатанным( <i>sealed</i>).
Это означает что он не может быть расширен, т.е. не может использоваться
в качаестве родителя для другого определения записи или вызова
<tt>make-record-type-descriptor</tt>.
Если предложение <tt>sealed</tt> отсутствует или имеется одна из форм
<tt>(sealed&nbsp;#f)</tt>, тип записи не запечатан.

</p><p>
</p><p><b>Предложение Непрозрачности(Opaque clause).</b>&nbsp;&nbsp;<a name="./records:s15"></a><a name="page:opaque"></a>
В предложении  <tt>opaque</tt> формы <tt>(opaque&nbsp;#t)</tt> указано, что
тип записи является непрозрачным( <i>opaque</i>).
Экземпляры непрозрачного(opaque) типа записи не рассматриваются предикатом
<tt>record?</tt> или, что более важно, процедурой извлечения rtd
<tt>record-rtd</tt>, которые описаны в разделе &nbsp;<a href="records.html#g141">9.3</a>.
Таким образом, код, который не имеет доступа к <tt>record-name</tt>, процедурам доступа,
или процедурам изменения не имеет возможности получить доступ или изменить
поля  непрозрачного(opaque) типа записи.
Тип записи так же будет непрозрачен(opaque) если его родитель непрозрачен.
Если отстутствует предложение <tt>opaque</tt> или присутствует одна из форма
<tt>(opaque&nbsp;#f)</tt>, а родительский элемент не является не прозрачным,
тип записи не является непрозрачным.

</p><p>
</p><p><b>Предложение дескриптора Родителя(Parent-rtd clause).</b>&nbsp;&nbsp;
Предложение <tt>(parent-rtd&nbsp;<i>parent-rtd</i>&nbsp;<i>parent-rcd</i>)</tt> является
альтернативой предложению <tt>parent</tt> для указания типа родительской записи, вместе 
с указанием дескриптора конструктора родительской записи.
Это в первую очередь полезно, когда родительские rtd и rcd были получены с помощью
вызовов <tt>make-record-type-descriptor</tt> и <tt>make-record-constructor-descriptor</tt>.

</p><p>
<tt><i>parent-rtd</i></tt> должен вычисляться как rtd или <tt>#f</tt>.
Если <tt><i>parent-rtd</i></tt> вычисляется в <tt>#f</tt>, <tt><i>parent-rcd</i></tt> также
должен вычисляться в <tt>#f</tt>.
В противном случае, <tt><i>parent-rcd</i></tt> должен вычисляться как rcd или <tt>#f</tt>.
Если <tt><i>parent-rcd</i></tt> вычисляется как  rcd, он может инкасулировать rtd
эквивалентный (по <tt>eqv?</tt>) в значение <tt><i>parent-rtd</i></tt>.
Если значение  <tt><i>parent-rcd</i></tt> является <tt>#f</tt>, оно заставляет рассматривать, 
что rcd для значения <tt><i>parent-rtd</i></tt> является протокол по умолчанию.

</p><p>
Форма <tt>define-record-type</tt> сконструирована таким образом, что компилятор
обычно может определять формы типов записей, которые он определяет,
включая смещения для всех полей.
Однако эта гаранетия не выполняется, когда используется предложение
<tt>parent-rtd</tt>, так как родительский rtd может не определяться до
момента выполнения программы.
Таким образом, предложение <tt>parent</tt> предпочтительнее по отношениею
к предложению <tt>parent-rtd</tt>
всякий раз, когда имеет место <tt>parent</tt> предложение.

</p><p>
<a name="./records:s16"></a><span class="formdef"><b>syntax</b>: <tt>fields</tt></span>
<br>
<span class="formdef"><b>syntax</b>: <tt>mutable</tt></span>
<br>
<span class="formdef"><b>syntax</b>: <tt>immutable</tt></span>
<br>
<span class="formdef"><b>syntax</b>: <tt>parent</tt></span>
<br>
<span class="formdef"><b>syntax</b>: <tt>protocol</tt></span>
<br>
<span class="formdef"><b>syntax</b>: <tt>sealed</tt></span>
<br>
<span class="formdef"><b>syntax</b>: <tt>opaque</tt></span>
<br>
<span class="formdef"><b>syntax</b>: <tt>nongenerative</tt></span>
<br>
<span class="formdef"><b>syntax</b>: <tt>parent-rtd</tt></span>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;syntactic)</tt>, <tt>(rnrs)</tt>

</p><p>Эти идентификаторы являются вспомогательными ключевыми словами для <tt>define-record-type</tt>.
Будет нарушением синтаксиса ссылаться на эти идентификаторы, за исключением контекстов,
где они распознаются как вспомогательные ключевые слова.

</p><p>

</p><h3><a name="g140"></a><a name="./records:h2"></a>Section 9.2. Процедурный Интефрейс<a name="SECTRECORDPROCEDURAL"></a></h3>

<p>
<a name="./records:s17"></a><a name="./records:s18"></a><a name="./records:s19"></a>Процедурный
интерфейс (<tt>make-record-type-descriptor</tt>) может так же использоваться
для создания нового типа записи.
Процедурный интерфейс более гибкий, чем синтаксический интерфейс, но эта гибкость
может привести к созданию трудно читаемых и менее эффективных программ, поэтому
программисты должны использовать синтаксический интерфейс всякий раз, когда
этого достаточно.

</p><p>
<a name="./records:s20"></a><span class="formdef"><b>procedure</b>: <tt>(make-record-type-descriptor&nbsp;<i>name</i>&nbsp;<i>parent</i>&nbsp;<i>uid</i>&nbsp;<i>s?</i>&nbsp;<i>o?</i>&nbsp;<i>fields</i>)</tt></span>
<br>
<b>returns: </b>дескриптор типа записи (rtd) для нового или существующего типа записи
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;procedural)</tt>, <tt>(rnrs)</tt>

</p><p><a name="./records:s21"></a><a name="./records:s22"></a><tt><i>name</i></tt> должно быть символом,
<tt><i>parent</i></tt> должен быть <tt>#f</tt> или
rtd не запечатаного типа записи, <tt><i>uid</i></tt> должен быть <tt>#f</tt> или
символом, и <tt><i>fields</i></tt> должен быть вектором, каждый элемент которого
представляет собой двух элементный список в форме <tt>(mutable&nbsp;<i>field-name</i>)</tt>
или <tt>(immutable&nbsp;<i>field-name</i>)</tt>.
Имена полей <tt><i>field-name</i>&nbsp;...</tt> должны быть символом и должны отличаться друг
от друга.

</p><p>
Если <tt><i>uid</i></tt> это <tt>#f</tt> или  типа записи с данным  uid  ранее не существовало,
данная процедура создает новый тип записи и возвращает дескриптор типа записи (record-type
descriptor (rtd) для нового типа. 
Тип имеет родительский тип(page&nbsp;<a href="records.html#page:parent-type">325</a>) описанный
<tt><i>parent</i></tt>, если поле не ложь;  uid указыанный  <tt><i>uid</i></tt>, если он не ложь;
и поля описанные в <tt><i>fields</i></tt>.
Он будет запечатан (page&nbsp;<a href="records.html#page:sealed">330</a>) если <tt><i>s?</i></tt> не ложь.
Он будет непрозрачен (page&nbsp;<a href="records.html#page:opaque">330</a>) если <tt><i>opaque</i></tt> не ложь или
родитель (если указан) является непрозрачным(opaque).
Имя нового типа записи будет <tt><i>name</i></tt> и имена полей - 
<tt><i>field-name</i>&nbsp;...</tt>.

</p><p>
Если <tt><i>uid</i></tt> не ложь и является uid (page&nbsp;<a href="records.html#page:record-uid">325</a>)
существующего типа записи, аргументы <tt><i>parent</i></tt>, <tt><i>fields</i></tt>, <tt><i>s?</i></tt>,
и <tt><i>o?</i></tt> должны совпадать с соответствующими характеристиками существующего типа записи.
Тоесть, <tt><i>parent</i></tt> должны быть одинаковымм (по <tt>eqv?</tt>); число полей
должно быть одинаковым; поля должны иметь одинаковые имена, и стоять в том же порядке, и иметь
одинаковые свойства изменяемости.
<tt><i>s?</i></tt> должно быть ложным тогда и только тогда, когда существующий тип записи
запчатан(sealed); и если родитель не указан или не является непрозрачным(opaque), 
<tt><i>o?</i></tt> должен быть ложным тогда и только тогда, когда существующий тип записи
непрозрачен.
В этом случае, <tt>make-record-type-descriptor</tt>
вернет rtd существующего типа записи.
В противном случае, возникает исключение с типом условия <tt>&amp;assertion</tt>.

</p><p>
Используя rtd возвращаемый <tt>make-record-type-descriptor</tt>, программы
могут динамически генерировать конструкторы, предикаты типа, процедуры доступа к полям и
процедуры изменения полей.
Следующий код демонстрирует, как можно использовать процедурный интерфейс для создания
типа записи <tt>point</tt> и связанных определений, аналогичных определениям
второго определения <tt>point</tt> в разделе &nbsp;<a href="records.html#g139">9.1</a>, 
с изменямым полем <tt>x</tt> и неизменяемым полем <tt>y</tt>.

</p><p>

</p><p><tt>(define&nbsp;point-rtd&nbsp;(make-record-type-descriptor&nbsp;'point&nbsp;#f&nbsp;#f&nbsp;#f&nbsp;#f<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'#((mutable&nbsp;x)&nbsp;(immutable&nbsp;y))))<br>

(define&nbsp;point-rcd&nbsp;(make-record-constructor-descriptor&nbsp;point-rtd<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#f&nbsp;#f))<br>

(define&nbsp;make-point&nbsp;(record-constructor&nbsp;point-rcd))<br>

(define&nbsp;point?&nbsp;(record-predicate&nbsp;point-rtd))<br>

(define&nbsp;point-x&nbsp;(record-accessor&nbsp;point-rtd&nbsp;0))<br>

(define&nbsp;point-y&nbsp;(record-accessor&nbsp;point-rtd&nbsp;1))<br>

(define&nbsp;point-x-set!&nbsp;(record-mutator&nbsp;point-rtd&nbsp;0))</tt>
</p><p>См. Дополнительные примеры, приведенные в конце этого раздела.

</p><p>
<a name="./records:s23"></a><span class="formdef"><b>procedure</b>: <tt>(record-type-descriptor?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> если <tt><i>obj</i></tt> это дескриптор типа записи(record-type descriptor), 
в противном случае <tt>#f</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;procedural)</tt>, <tt>(rnrs)</tt>

</p><p>Смотри пример в конце этого раздела.

</p><p>
<a name="./records:s24"></a><span class="formdef"><b>procedure</b>: <tt>(make-record-constructor-descriptor&nbsp;<i>rtd</i>&nbsp;<i>parent-rcd</i>&nbsp;<i>protocol</i>)</tt></span>
<br>
<b>returns: </b>дескриптор конструктора записи(record-constructor descriptor) (rcd)
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;procedural)</tt>, <tt>(rnrs)</tt>

</p><p><a name="./records:s25"></a><a name="./records:s26"></a><a name="./records:s27"></a>
Одного только rtd достаточно для создания предикатов, процедур доступа, и процедур изменения.
Однако для создания конструктора сначала необходимо создать дескриптор конструктора записи (rcd)
для типа записи.
rcd инкапсулирует три части информации: rtd типа записи для которого был создан rcd,
родительский rcd (если есть), и протокол.

</p><p>
Аргумент<tt><i>parent-rcd</i></tt> должен быть rcd или <tt>#f</tt>.
Если это rcd, <tt><i>rtd</i></tt> должен иметь родительский rtd, и родительский  rtd должен быть
таким же, как rtd инкапсулированный в <tt><i>parent-rcd</i></tt>.
Если <tt><i>parent-rcd</i></tt> это ложь, то предполагается что для <tt><i>rtd</i></tt> нет родительского 
элемента или для него используется rcd с протоколом по умолчанию.

</p><p>
Аргумент <tt><i>protocol</i></tt> должен быть процедурой или <tt>#f</tt>.
Если он равен <tt>#f</tt>, предполагается что используется протокол по умолчанию.
Протоколы обсуждаются на странице&nbsp;<a href="records.html#page:protocols">326</a>.

</p><p>
См. примеры приведенные в конце этого раздела.

</p><p>
<a name="./records:s28"></a><span class="formdef"><b>syntax</b>: <tt>(record-type-descriptor&nbsp;<i>record-name</i>)</tt></span>
<br>
<b>returns: </b> rtd для типа записи идентифицируемого <tt>record-name</tt>
<br>
<span class="formdef"><b>syntax</b>: <tt>(record-constructor-descriptor&nbsp;<i>record-name</i>)</tt></span>
<br>
<b>returns: </b> rcd для типа записи идентифицируемого <tt>record-name</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;syntactic)</tt>, <tt>(rnrs)</tt>

</p><p>Каждое определение записи создает за кулисами rtd и rcd для 
определяемого типа записи.
Эти процедуры позволяют получить rtd и rcd как и любые другие
rtd или rcd.
<tt><i>record-name</i></tt> дожно быть именем записи определенной с помощью
<tt>define-record-type</tt>.

</p><p>
<a name="./records:s29"></a><span class="formdef"><b>procedure</b>: <tt>(record-constructor&nbsp;<i>rcd</i>)</tt></span>
<br>
<b>returns: </b>конструктор записи для типа записи, инкапсулированного в  <tt><i>rcd</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;procedural)</tt>, <tt>(rnrs)</tt>

</p><p>Поведение конструктора записи определяется протоколом и родительским rcd (если есть),
также инкапсулированным внутри <tt><i>rcd</i></tt>.

</p><p>
См. примеры приведенные в конце этого раздела.

</p><p>
<a name="./records:s30"></a><span class="formdef"><b>procedure</b>: <tt>(record-predicate&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b>предикат для <tt><i>rtd</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;procedural)</tt>, <tt>(rnrs)</tt>

</p><p>Эта процедура возвращает предикат, который принимает один аргумент и
возвращает <tt>#t</tt> если аргумент является экземпляром типа записи,
описанным в <tt><i>rtd</i></tt>, <tt>#f</tt> в противном случае.

</p><p>
См. примеры приведенные в конце этого раздела.

</p><p>
<a name="./records:s31"></a><span class="formdef"><b>procedure</b>: <tt>(record-accessor&nbsp;<i>rtd</i>&nbsp;<i>idx</i>)</tt></span>
<br>
<b>returns: </b>процедуру доступа для поля  <tt><i>rtd</i></tt> указываемого <tt><i>idx</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;procedural)</tt>, <tt>(rnrs)</tt>

</p><p><tt><i>idx</i></tt> должен быть неотритцательным целым числом меньшим
числа полей <tt><i>rtd</i></tt>, не считая родительских полей.
Значение <tt><i>idx</i></tt> равное 0 задает первое поле указанное в
<tt>define-record-type</tt> или вызове <tt>make-record-type-descriptor</tt>
который создал тип записи, 1 указывает второе и т.д.

</p><p>
Дочерний rtd нельзя использовать напрямую для создания процедур доступа
для родительских полей.
Чтобы создать процедуру доступа для родительского поля, надо использовать
вместо него родительский дескриптор типа записи.

</p><p>
См. примеры приведенные в конце этого раздела.

</p><p>
<a name="./records:s32"></a><span class="formdef"><b>procedure</b>: <tt>(record-mutator&nbsp;<i>rtd</i>&nbsp;<i>idx</i>)</tt></span>
<br>
<b>returns: </b>процедура изменения для поля <tt><i>rtd</i></tt> указываемого <tt><i>idx</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;procedural)</tt>, <tt>(rnrs)</tt>

</p><p><tt><i>idx</i></tt> должен быть неотритцательным целым числом меньшим
числа полей <tt><i>rtd</i></tt>, не считая родительских полей.
Значение <tt><i>idx</i></tt> равное 0 задает первое поле указанное в форме
<tt>define-record-type</tt> или вызове <tt>make-record-type-descriptor</tt>
который создал тип записи, 1 указывает второе поле и т.д.
Указанное поле дожно быть изменяемым; в противном случае возникает исключение
с типом условия <tt>&amp;assertion</tt>.

</p><p>
Дочерний rtd нельзя использовать напрямую для создания процедур изменения
для родительских полей.
Чтобы создать процедуру изменения для родительского поля, надо использовать
вместо него родительский дескриптор типа записи.

</p><p>
</p><p>Следующий пример иллюстрирует создание родительских и дочерних типов записей,
предикатов, процедур доступа и изменения, конструктров  с использованием процедур
описанных в этом разделе.

</p><p>

</p><p><tt>(define&nbsp;rtd/parent<br>

&nbsp;&nbsp;(make-record-type-descriptor&nbsp;'parent&nbsp;#f&nbsp;#f&nbsp;#f&nbsp;#f<br>

&nbsp;&nbsp;&nbsp;&nbsp;'#((mutable&nbsp;x))))
<br>
<br>
(record-type-descriptor?&nbsp;rtd/parent)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#t<br>

(define&nbsp;parent?&nbsp;(record-predicate&nbsp;rtd/parent))<br>

(define&nbsp;parent-x&nbsp;(record-accessor&nbsp;rtd/parent&nbsp;0))<br>

(define&nbsp;set-parent-x!&nbsp;(record-mutator&nbsp;rtd/parent&nbsp;0))
<br>
<br>
(define&nbsp;rtd/child<br>

&nbsp;&nbsp;(make-record-type-descriptor&nbsp;'child&nbsp;rtd/parent&nbsp;#f&nbsp;#f&nbsp;#f<br>

&nbsp;&nbsp;&nbsp;&nbsp;'#((mutable&nbsp;x)&nbsp;(immutable&nbsp;y))))
<br>
<br>
(define&nbsp;child?&nbsp;(record-predicate&nbsp;rtd/child))<br>

(define&nbsp;child-x&nbsp;(record-accessor&nbsp;rtd/child&nbsp;0))<br>

(define&nbsp;set-child-x!&nbsp;(record-mutator&nbsp;rtd/child&nbsp;0))<br>

(define&nbsp;child-y&nbsp;(record-accessor&nbsp;rtd/child&nbsp;1))
<br>
<br>
(record-mutator&nbsp;rtd/child&nbsp;1)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;<i>exception:&nbsp;immutable&nbsp;field</i>
<br>
<br>
(define&nbsp;rcd/parent<br>

&nbsp;&nbsp;(make-record-constructor-descriptor&nbsp;rtd/parent&nbsp;#f<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(new)&nbsp;(lambda&nbsp;(x)&nbsp;(new&nbsp;(*&nbsp;x&nbsp;x))))))
<br>
<br>
(record-type-descriptor?&nbsp;rcd/parent)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#f
<br>
<br>
(define&nbsp;make-parent&nbsp;(record-constructor&nbsp;rcd/parent))
<br>
<br>
(define&nbsp;p&nbsp;(make-parent&nbsp;10))<br>

(parent?&nbsp;p)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#t<br>

(parent-x&nbsp;p)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;100<br>

(set-parent-x!&nbsp;p&nbsp;150)<br>

(parent-x&nbsp;p)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;150
<br>
<br>
(define&nbsp;rcd/child<br>

&nbsp;&nbsp;(make-record-constructor-descriptor&nbsp;rtd/child&nbsp;rcd/parent<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(pargs-&gt;new)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((pargs-&gt;new&nbsp;x)&nbsp;(+&nbsp;x&nbsp;5)&nbsp;y)))))
<br>
<br>
(define&nbsp;make-child&nbsp;(record-constructor&nbsp;rcd/child))<br>

(define&nbsp;c&nbsp;(make-child&nbsp;10&nbsp;'cc))<br>

(parent?&nbsp;c)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#t<br>

(child?&nbsp;c)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#t<br>

(child?&nbsp;p)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#f
<br>
<br>
(parent-x&nbsp;c)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;100<br>

(child-x&nbsp;c)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;15<br>

(child-y&nbsp;c)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;cc
<br>
<br>
(child-x&nbsp;p)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;<i>exception:&nbsp;invalid&nbsp;argument&nbsp;type</i></tt>
</p><p>
</p><h3><a name="g141"></a><a name="./records:h3"></a>Section 9.3. Инспекция<a name="SECTRECORDINSPECTION"></a></h3>

<p>
В этом разделе описываются различные процедуры для задания вопросов
или извлечения информации из дескрипторов типа записи(record-type descriptors) (rtd).
В ней также описывается процедура <tt>record-rtd</tt>, с помощью которой
может быть извлечен rtd экземпляра прозрачной записи, позволяющий проверять
тип записи экземпляра, а так же процедуры чтения и изменения, сгенерированные
из rtd, сама запись может быть осмотрена и изменена.
Это мощная функция, которая позволяет кодировать печатаемые переносимые записи и
инспекторы.

</p><p>
<a name="./records:s33"></a>Дескриптор типа записи не может быть извлечен из экземпляра непрозрачного
типа записи, это особенность которая отличает непрозрачные от прозрачных типов записей.

</p><p>
<a name="./records:s34"></a><span class="formdef"><b>procedure</b>: <tt>(record-type-name&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b>имя связанное с <tt><i>rtd</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;inspection)</tt>, <tt>(rnrs)</tt>

</p><p>
</p><p><tt>
(define&nbsp;record-&gt;name<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(record?&nbsp;x)&nbsp;(record-type-name&nbsp;(record-rtd&nbsp;x)))))
<br>
<br>
(define-record-type&nbsp;dim&nbsp;(fields&nbsp;w&nbsp;l&nbsp;h))<br>

(record-&gt;name&nbsp;(make-dim&nbsp;10&nbsp;15&nbsp;6))&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;dim
<br>
<br>
(define-record-type&nbsp;dim&nbsp;(fields&nbsp;w&nbsp;l&nbsp;h)&nbsp;(opaque&nbsp;#t))<br>

(record-&gt;name&nbsp;(make-dim&nbsp;10&nbsp;15&nbsp;6))&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#f</tt>
</p><p><a name="./records:s35"></a><span class="formdef"><b>procedure</b>: <tt>(record-type-parent&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b>родительский <tt><i>rtd</i></tt>, или <tt>#f</tt> если нет родителя
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;inspection)</tt>, <tt>(rnrs)</tt>

</p><p>
</p><p><tt>
(define-record-type&nbsp;point&nbsp;(fields&nbsp;x&nbsp;y))<br>

(define-record-type&nbsp;cpoint&nbsp;(parent&nbsp;point)&nbsp;(fields&nbsp;color))<br>

(record-type-parent&nbsp;(record-type-descriptor&nbsp;point))&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#f<br>

(record-type-parent&nbsp;(record-type-descriptor&nbsp;cpoint))&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#&lt;rtd&gt;</tt>
</p><p><a name="./records:s36"></a><span class="formdef"><b>procedure</b>: <tt>(record-type-uid&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b>некий идентификатор uid связанный с <tt><i>rtd</i></tt>, или <tt>#f</tt> если uid отсутствует
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;inspection)</tt>, <tt>(rnrs)</tt>

</p><p>Независимо от типа записи uid создается без запрограммированного
программистом uid, так или иначе это зависит от реализации, поэтому эта
процедура никогда не гарантирует возврата <tt>#f</tt>.

</p><p>

</p><p><tt>(define-record-type&nbsp;point&nbsp;(fields&nbsp;x&nbsp;y))<br>

(define-record-type&nbsp;cpoint<br>

&nbsp;&nbsp;(parent&nbsp;point)<br>

&nbsp;&nbsp;(fields&nbsp;color)<br>

&nbsp;&nbsp;(nongenerative&nbsp;e40cc926-8cf4-4559-a47c-cac636630314))<br>

(record-type-uid&nbsp;(record-type-descriptor&nbsp;point))&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;<i>unspecified</i><br>

(record-type-uid&nbsp;(record-type-descriptor&nbsp;cpoint))&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;"><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e40cc926-8cf4-4559-a47c-cac636630314</tt>
</p><p><a name="./records:s37"></a><span class="formdef"><b>procedure</b>: <tt>(record-type-generative?&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> если тип записи определенный <tt><i>rtd</i></tt> является генеративным
(сгенерированным реализацией uid), <tt>#f</tt> 
в противном случае
<br>
<span class="formdef"><b>procedure</b>: <tt>(record-type-sealed?&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> если тип записи определенный <tt><i>rtd</i></tt> является запечатанным, <tt>#f</tt> 
в противном случае
<br>
<span class="formdef"><b>procedure</b>: <tt>(record-type-opaque?&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> если тип записи определенный <tt><i>rtd</i></tt> является непрозрачным, <tt>#f</tt>
в противном случае
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;inspection)</tt>, <tt>(rnrs)</tt>

</p><p>
</p><p><tt>
(define-record-type&nbsp;table<br>

&nbsp;&nbsp;(fields&nbsp;keys&nbsp;vals)<br>

&nbsp;&nbsp;(opaque&nbsp;#t))<br>

(define&nbsp;rtd&nbsp;(record-type-descriptor&nbsp;table))<br>

(record-type-generative?&nbsp;rtd)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#t<br>

(record-type-sealed?&nbsp;rtd)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#f<br>

(record-type-opaque?&nbsp;rtd)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#t
<br>
<br>
(define-record-type&nbsp;cache-table<br>

&nbsp;&nbsp;(parent&nbsp;table)<br>

&nbsp;&nbsp;(fields&nbsp;key&nbsp;val)<br>

&nbsp;&nbsp;(nongenerative))<br>

(define&nbsp;rtd&nbsp;(record-type-descriptor&nbsp;cache-table))<br>

(record-type-generative?&nbsp;rtd)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#f<br>

(record-type-sealed?&nbsp;rtd)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#f<br>

(record-type-opaque?&nbsp;rtd)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#t</tt>
</p><p><a name="./records:s38"></a><span class="formdef"><b>procedure</b>: <tt>(record-type-field-names&nbsp;<i>rtd</i>)</tt></span>
<br>
<b>returns: </b>вектор, содержащий имена полей типа описываемого <tt><i>rtd</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;inspection)</tt>, <tt>(rnrs)</tt>

</p><p>Вектор, возвращаемый этой процедурой является неизменяемым: влияние модификации
на <tt><i>rtd</i></tt> неопределено.
Вектор не содержит имен родительских полей.
Порядок имен в векторе совпадает с порядком, в котором поля были указаны в 
форме <tt>define-record-type</tt> или вызове
<tt>make-record-type-descriptor</tt>, который создал этот тип записи.

</p><p>

</p><p><tt>(define-record-type&nbsp;point&nbsp;(fields&nbsp;x&nbsp;y))<br>

(define-record-type&nbsp;cpoint&nbsp;(parent&nbsp;point)&nbsp;(fields&nbsp;color))<br>

(record-type-field-names<br>

&nbsp;&nbsp;(record-type-descriptor&nbsp;point))&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#(x&nbsp;y)<br>

(record-type-field-names<br>

&nbsp;&nbsp;(record-type-descriptor&nbsp;cpoint))&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#(color)</tt>
</p><p><a name="./records:s39"></a><span class="formdef"><b>procedure</b>: <tt>(record-field-mutable?&nbsp;<i>rtd</i>&nbsp;<i>idx</i>)</tt></span>
<br>
<b>returns: </b><tt>#t&nbsp;если указанное поле <i>rtd</i></tt> является изменяемымis mutable, <tt>#f</tt> в противном
случае
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;inspection)</tt>, <tt>(rnrs)</tt>

</p><p><tt><i>idx</i></tt> должне быть неотритцательным целым числом меньшим
числа полей <tt><i>rtd</i></tt>, не считая родительских полей.
Значение <tt><i>idx</i></tt> равное 0 указывает первое поле, указанное в форме
<tt>define-record-type</tt> или вызове <tt>make-record-type-descriptor</tt>
который создал данный тип записи, 1 указывает второе и т.д.

</p><p>

</p><p><tt>(define-record-type&nbsp;point&nbsp;(fields&nbsp;(mutable&nbsp;x)&nbsp;(mutable&nbsp;y)))<br>

(define-record-type&nbsp;cpoint&nbsp;(parent&nbsp;point)&nbsp;(fields&nbsp;color))
<br>
<br>
(record-field-mutable?&nbsp;(record-type-descriptor&nbsp;point)&nbsp;0)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#t<br>

(record-field-mutable?&nbsp;(record-type-descriptor&nbsp;cpoint)&nbsp;0)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#f</tt>
</p><p><a name="./records:s40"></a><span class="formdef"><b>procedure</b>: <tt>(record?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> если <tt><i>obj</i></tt> является прозрачным экзепляром записи, <tt>#f</tt> 
в противном случае
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;inspection)</tt>, <tt>(rnrs)</tt>

</p><p>Когда передан экземпляр непрозрачного типа записи, <tt>record?</tt> возвращает
<tt>#f</tt>.
Хотя экземпляр непрозрачного(opaque) типа записи является, по сути, записью,
целью непрозрачности является скрыть всю информацию о представлении от частей
программы, которые не должны иметь доступ к этой информации,
и это включает в себя возможность определения является ли объект записью.
Кроме того, основная цель этого предиката - разрешить программам проверять
можно ли получеть из аргумента rtd через процедуру
<tt>record-rtd</tt>, описанную ниже(а для непрозрачной записи это невозможно).

</p><p>

</p><p><tt>(define-record-type&nbsp;statement&nbsp;(fields&nbsp;str))<br>

(define&nbsp;q&nbsp;(make-statement&nbsp;"He's&nbsp;dead,&nbsp;Jim"))<br>

(statement?&nbsp;q)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#t<br>

(record?&nbsp;q)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#t
<br>
<br>
(define-record-type&nbsp;opaque-statement&nbsp;(fields&nbsp;str)&nbsp;(opaque&nbsp;#t))<br>

(define&nbsp;q&nbsp;(make-opaque-statement&nbsp;"He's&nbsp;moved&nbsp;on,&nbsp;Jim"))<br>

(opaque-statement?&nbsp;q)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#t<br>

(record?&nbsp;q)&nbsp;<img src="./records_files/0.gif" alt="&lt;graphic&gt;">&nbsp;#f</tt>
</p><p><a name="./records:s41"></a><span class="formdef"><b>procedure</b>: <tt>(record-rtd&nbsp;<i>record</i>)</tt></span>
<br>
<b>returns: </b>дескриптор типа записи (rtd)  <tt><i>record</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;records&nbsp;inspection)</tt>, <tt>(rnrs)</tt>

</p><p>Аргумент должен быть экземпляром прозрачного типа записи.
В сочетании с некоторыми другими процедурами, описанными в этом
разделе и Разделе&nbsp;<a href="records.html#g140">9.2</a>,
<tt>record-rtd</tt> позволяет инспектировать или изменять запись
экземпляра, даже если тип экземпляра неизвестен инспектору.
Эта возможность илюстрируется приведенной ниже процедурой <tt>print-fields</tt>,
которая принимает в качестве аргумента запись и печатает
имя и значение каждого поля записи.

</p><p>

</p><p><tt>(define&nbsp;print-fields<br>

&nbsp;&nbsp;(lambda&nbsp;(r)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(unless&nbsp;(record?&nbsp;r)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assertion-violation&nbsp;'print-fields&nbsp;"not&nbsp;a&nbsp;record"&nbsp;r))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;loop&nbsp;([rtd&nbsp;(record-rtd&nbsp;r)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([prtd&nbsp;(record-type-parent&nbsp;rtd)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(when&nbsp;prtd&nbsp;(loop&nbsp;prtd)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let*&nbsp;([v&nbsp;(record-type-field-names&nbsp;rtd)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[n&nbsp;(vector-length&nbsp;v)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([i&nbsp;0&nbsp;(+&nbsp;i&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;i&nbsp;n))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(write&nbsp;(vector-ref&nbsp;v&nbsp;i))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;"=")<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(write&nbsp;((record-accessor&nbsp;rtd&nbsp;i)&nbsp;r))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(newline))))))</tt>
</p><p>С уже знакомыми определениями <tt>point</tt> и <tt>cpoint</tt>:

</p><p>

</p><p><tt>(define-record-type&nbsp;point&nbsp;(fields&nbsp;x&nbsp;y))<br>

(define-record-type&nbsp;cpoint&nbsp;(parent&nbsp;point)&nbsp;(fields&nbsp;color))</tt>
</p><p>выражение <tt>(print-fields&nbsp;(make-cpoint&nbsp;-3&nbsp;7&nbsp;'blue))</tt> отобразит
следующие три строки.

</p><p>

</p><p><tt>x=-3<br>

y=7<br>

color=blue</tt>
</p><p>

</p><hr class="copyright" align="left">
<p>
R. Kent Dybvig / <it>The Scheme Programming Language, Fourth Edition</it><br>
Copyright © 2009 <a class="plain" href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&amp;tid=11984">The MIT Press</a>.  Electronically reproduced by permission.<br>
Illustrations © 2009 <a class="plain" href="http://hebert.kitp.ucsb.edu/">Jean-Pierre Hébert</a><br>
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93<br>
<a class="plain" href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&amp;tid=11984">to order this book</a> / <a class="plain" href="canned/about.html">about this book</a>
</p>
<p><a class="plain" href="http://www.scheme.com/">http://www.scheme.com</a></p>

</body></html>