#
# NuINu <don't@send.my>, 2018.
#
#. extracted from intro.html
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-07-24 12:28+0300\n"
"PO-Revision-Date: 2018-10-17 15:17+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: intro.html:10
msgid ""
"<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://"
"www.w3.org/TR/html4/loose.dtd\">\n"
"<!-- saved from url=(0046)intro.html#./intro:h0 -->\n"
"<html><head><meta http-equiv=\"Content-Type\" content=\"text/html; "
"charset=windows-1252\">\n"
"<title>Introduction</title>\n"
"<link href=\"./intro_files/tspl.css\" rel=\"stylesheet\" type=\"text/css\">\n"
"</head>\n"
"<body>\n"
"<a name=\"g0\"></a>\n"
"<a name=\"./intro:h0\"></a>"
msgstr ""
"<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://"
"www.w3.org/TR/html4/loose.dtd\">\n"
"<!-- saved from url=(0046)intro.html#./intro:h0 -->\n"
"<html><head><meta http-equiv=\"Content-Type\" content=\"text/html; "
"charset=utf-8\">\n"
"<title>Введение</title>\n"
"<link href=\"./intro_files/tspl.css\" rel=\"stylesheet\" type=\"text/css\">\n"
"</head>\n"
"<body>\n"
"<a name=\"g0\"></a>\n"
"<a name=\"./intro:h0\"></a>"

#: intro.html:15
msgid ""
"<div style=\"font-size: 12px; width: 500px; height: 500px; border: solid thin"
"\">\n"
"<img style=\"padding: 20px 10px 20px 20px\" src=\"./intro_files/ch1.png"
"\"><img src=\"./intro_files/jph.png\">\n"
"</div>\n"
"<h1>Chapter 1. Introduction<a name=\"CHPTINTRO\"></a></h1>"
msgstr ""
"<div>\n"
"<img  src=\"./intro_files/ch1.png\">\n"
"</div>\n"
"<h1>Chapter 1. Введение<a name=\"CHPTINTRO\"></a></h1>"

#: intro.html:40
msgid ""
"<p>\n"
"Scheme is a general-purpose computer programming language.\n"
"It is a high-level language, supporting operations on structured\n"
"data such as strings, lists, and vectors, as well as operations on\n"
"more traditional data such as numbers and characters.\n"
"While Scheme is often identified with symbolic\n"
"applications, its rich set of data types and flexible\n"
"control structures make it a truly versatile language.\n"
"Scheme has been employed to write text editors, optimizing\n"
"compilers, operating systems, graphics packages, expert systems,\n"
"numerical applications, financial analysis packages,\n"
"virtual reality systems,\n"
"and practically every other type of application imaginable.\n"
"Scheme is a fairly simple language to learn, since it is based\n"
"on a handful of syntactic forms and semantic concepts and\n"
"since the interactive nature of most implementations encourages\n"
"experimentation.\n"
"Scheme is a challenging language to understand fully, however;\n"
"developing the ability to use its full potential requires careful study\n"
"and practice."
msgstr ""
"<p>\n"
"Scheme это универсальный компьютерный язык программирования. Это язык\n"
"высокого уровня, поддерживающий операции со структурированными данными, \n"
"такими как строки, списки и векторы. а также операции над более\n"
"традиционными данными, такими как числа и символы.\n"
"Хотя Scheme часто ассоциируется с символическими приложениями, его богатый\n"
"набор типов данных и гибкие структуры управления делают его действительно\n"
"универсальным языком. Scheme был использован для написания текстовых\n"
"редакторов, оптимизирующих компиляторов, операционных систем, графических\n"
"пакетов, экспертных систем, числовых приложений, пактов финансового\n"
"анализа, систем виртуальной реальности, и приктически любого другого вида\n"
"приложений, которое можно себе представить. Scheme - довольно простой\n"
"язык для изучения, поскольку он основан на нескольких синтаксических формах\n"
"и семантических концепциях, и интерактивный характер большинства его "
"реализаций\n"
"стимулирует эксперименты. Однако Scheme - сложный язык, чтобы понять его;\n"
"развитие способности использовать весь его потенциал требует тщательного\n"
"изучения и практики."

#: intro.html:53
msgid ""
"</p><p>\n"
"Scheme programs are highly portable across versions of\n"
"the same Scheme implementation on different machines, because machine\n"
"dependencies are almost completely hidden from the programmer.\n"
"They are also portable across different implementations because of the\n"
"efforts of a group of Scheme language designers who have published\n"
"a series of reports,\n"
"the \"<a name=\"./intro:s0\"></a>Revised Reports\" on Scheme.\n"
"The most recent, the \n"
"\"Revised<sup>6</sup> Report\"&nbsp;[<a class=\"citation\" href="
"\"bibliography.html#g242\">24</a>], emphasizes portability\n"
"through a set of standard libraries and a standard mechanism for\n"
"defining new portable libraries and top-level programs."
msgstr ""
"</p><p>\n"
"Программы Scheme легко переносимы в разных версиях одной и тойже реализации\n"
"Scheme на разных машинах, потому что зависимости от машины почти полностью\n"
"скрыты от программиста. Они также переносимы в разных реализациях из-за "
"усилий\n"
"группы разработчиков языка Scheme, опубликовавших серию отчетов, \n"
"\"<a name=\"./intro:s0\"></a>Revised Reports\" on Scheme. The most recent, "
"the \n"
"\"Revised<sup>6</sup> Report\"&nbsp;[<a class=\"citation\" href="
"\"bibliography.html#g242\">24</a>], \n"
"подчеркивает переносимость через набор стандартных библиотек и стандартный "
"механизм\n"
"для определения новых переносимых библиотек и программ верхнего уровня."

#: intro.html:64
msgid ""
"</p><p>\n"
"Although some early Scheme systems were inefficient and slow,\n"
"many newer compiler-based implementations are fast, with programs\n"
"running on par with equivalent programs written in\n"
"lower-level languages.\n"
"The relative inefficiency that sometimes remains results from run-time\n"
"checks that support generic arithmetic and help programmers\n"
"detect and correct various common\n"
"programming errors.\n"
"These checks may be disabled in many implementations."
msgstr ""
"</p><p>\n"
"Хотя некоторые ранние версии системы Scheme были неэффективными и "
"медленными,\n"
"многие новые реализации на основе компилятора бывают быстрыми, а программы\n"
"работают наравне с эквивалентными программами, написанными на языках\n"
"более низкого уровня.  Относительная неэффективность, которая иногда "
"остается\n"
"результатом проверок во время выполнения, которые поддерживают общую "
"арифметику\n"
"и помогают программистам обнаруживать и исправлять различные "
"распространенные\n"
"ошибки программирования. Эти проверки могут быть отключены во многих "
"реализациях."

#: intro.html:70
msgid ""
"</p><p>\n"
"</p><p>Scheme supports many types of data values, or\n"
"<a name=\"./intro:s1\"></a><i>objects</i>, including characters, strings, "
"symbols,\n"
"lists or vectors of objects, and a full set of numeric data types,\n"
"including complex, real, and arbitrary-precision rational numbers."
msgstr ""
"</p><p>\n"
"</p><p>Scheme поддерживает множество типов значений данных, или\n"
"<a name=\"./intro:s1\"></a><i>объектов</i>, включая символьные "
"знаки(char), \n"
"строки, символы(symbols), списки и векторы объектов, и полный набор\n"
"числовых типов данных, включая комплексные, вещественные и произвольные\n"
"значения рациональных чисел."

#: intro.html:81
msgid ""
"</p><p>\n"
"The storage required to hold the contents of an object is\n"
"<a name=\"./intro:s2\"></a>dynamically allocated as\n"
"necessary and retained until no longer needed, then automatically\n"
"deallocated, typically by a\n"
"<a name=\"./intro:s3\"></a><i>garbage collector</i> that\n"
"periodically recovers the storage used by inaccessible objects.\n"
"Simple atomic values, such as small integers, characters, booleans,\n"
"and the empty list, are typically represented as immediate values and\n"
"thus incur no allocation or deallocation overhead."
msgstr ""
"</p><p>\n"
"Хранилище требуемое для хранения содержимого объекта, \n"
"<a name=\"./intro:s2\"></a>динамически распределяется\n"
"по мере необходимости и сохраняется до тех пор, пока оно\n"
"больше не понадобиться, а затем автоматически освобождается,\n"
"как правило <a name=\"./intro:s3\"></a><i>сборщиком мусора</i> который\n"
"переодически востанавливает хранилище, используемое недоступными\n"
"объектами. Простые неделимые значения, такие как малые целые числа,\n"
"буквы, булевы значения и пустые списки, обычно представляются в виде\n"
"непосредственных значений и следовательно, не несут накладных расходов\n"
"на распределение и сопровождение."

#: intro.html:93
msgid ""
"</p><p>\n"
"Regardless of representation,\n"
"all objects are <a name=\"./intro:s4\"></a><i>first-class</i> data values;\n"
"because they are retained indefinitely, they may be passed freely\n"
"as arguments to procedures, returned as values from procedures, and\n"
"combined to form new objects.\n"
"This is in contrast with many other languages where composite data\n"
"values such as arrays are either statically allocated and never\n"
"deallocated, allocated on entry to a block of code and unconditionally\n"
"deallocated on exit from the block, or explicitly allocated <i>and</i>\n"
"deallocated by the programmer."
msgstr ""
"</p><p>\n"
"Независимо от представления, все объекты являюстя \n"
"<a name=\"./intro:s4\"></a><i>первоклассными</i> значениями данных;\n"
"поскольку они могу сохраняться на неопределенный срок, они могут\n"
"свободно передаваться в качестве аргументов процедуры, возвращаться\n"
"как значения из процедур и объединяться для формирования новых \n"
"объектов. Это контрастирует  со многими другими языками, на которых\n"
"совокумные значения данных, такие как массивы, либо статически\n"
"распределяются, либо никогда не освобождаются от работы, выделяются\n"
"при входе в блок кода и безоговорочно освобождаются при выходе из\n"
"блока или явно распределяются и освобождаются программистом."

#: intro.html:102
msgid ""
"</p><p>\n"
"Scheme is a call-by-value language, but for at least mutable objects "
"(objects\n"
"that can be modified), the values are <a name=\"./intro:s5\"></a>pointers\n"
"to the actual storage.\n"
"These pointers remain behind the scenes, however, and programmers need\n"
"not be conscious of them except to understand that the storage for an\n"
"object is not copied when an object is passed to or returned from\n"
"a procedure."
msgstr ""
"</p><p>\n"
"Scheme это язык с вызовом по значению, по крайней мере для изменяемых "
"объектов\n"
"(объектов, которые могут быть изменены), значения являются <a name=\"./intro:"
"s5\"></a>\n"
"указателями на фактическое хранилище. Однако эти указатели остаются за "
"кулисами\n"
"и программисты не должны осознавать их, кроме понимания того, что хранилище "
"объекта\n"
"не копируется, когда объект передается или возвращается из процедуры."

#: intro.html:114
msgid ""
"</p><p>\n"
"<a name=\"./intro:s6\"></a>At the heart of the Scheme language is a\n"
"small core of syntactic forms from which all other forms are built.\n"
"These core forms, a set of extended syntactic forms derived from\n"
"them, and a set of <a name=\"./intro:s7\"></a>primitive procedures\n"
"make up the full Scheme language.\n"
"An <a name=\"./intro:s8\"></a>interpreter or <a name=\"./intro:s9\"></"
"a>compiler for Scheme\n"
"can be quite small and potentially fast and highly reliable.\n"
"The extended syntactic forms and many primitive procedures can be\n"
"defined in Scheme itself, simplifying the implementation and\n"
"increasing reliability."
msgstr ""
"</p><p>\n"
"<a name=\"./intro:s6\"></a>В основе языка Scheme лежит небольшое ядро\n"
"синтаксическх форм, из которых построены все остальные формы.\n"
"Эти основные формы, набор расширенных синтаксических форм полученый\n"
"из них, и набор <a name=\"./intro:s7\"></a>примитивных процедур составляют\n"
"полный язык Scheme.\n"
"Интерпретатор<a name=\"./intro:s8\"></a> или <a name=\"./intro:s9\"></a> "
"компилятор для\n"
"Scheme могут быть довольно маленькими и потенциально быстрыми и надежными. "
"Расширенные\n"
"синтаксические формы и многие примитивные процедуры могут быть определены в "
"самой\n"
"Scheme, упрощая реализацию и повышая надежность."

#: intro.html:129
msgid ""
"</p><p>\n"
"Scheme programs share a common printed representation with Scheme\n"
"data structures.\n"
"As a result, any Scheme program has a natural and obvious internal\n"
"representation as a Scheme object.\n"
"For example, <a name=\"./intro:s10\"></a>variables and syntactic <a name=\"./"
"intro:s11\"></a>keywords correspond to\n"
"symbols, while structured syntactic forms correspond to lists.\n"
"This representation is the basis for the syntactic extension\n"
"facilities\n"
"provided by Scheme for the definition of new syntactic\n"
"forms in terms of existing syntactic forms and procedures.\n"
"It also facilitates the implementation of interpreters, compilers, and\n"
"other program transformation tools for Scheme directly in Scheme, as\n"
"well as program transformation tools for other languages in Scheme."
msgstr ""
"</p><p>\n"
"Программы Scheme имеют общее печатное представление со структурами\n"
"данных Scheme.\n"
"В результате любая программа Scheme имеет естественное и очевидное\n"
"внутренне представление как объект Scheme.\n"
"Например, <a name=\"./intro:s10\"></a>переменные и синтаксические<a name=\"./"
"intro:s11\"></a> ключевые слова\n"
"соответствуют символам, а структурированные синтаксические формы "
"соответствуют спискам.\n"
"Это представление является основой для возможностей синтаксического "
"расширения,\n"
"предоставляемых Scheme для определения новых синтаксических форм в терминах\n"
"существующих синтаксических форм и процедур.\n"
"Это также облегчает реализацию интерпретаторов, компиляторов и других "
"инструментов\n"
"преобразования программ для Scheme непосредственно на Scheme, а также\n"
"инструментов преобразования программ для других языков в Scheme."

#: intro.html:160
msgid ""
"</p><p>\n"
"</p><p>Scheme variables and keywords are\n"
"<a name=\"./intro:s12\"></a><i>lexically scoped</i>, and\n"
"Scheme programs are\n"
"<a name=\"./intro:s13\"></a><i>block-structured</i>.\n"
"Identifiers may be imported into a program or library or bound locally\n"
"within a given block of code such as a library, program, or procedure\n"
"body.\n"
"A local <a name=\"./intro:s14\"></a>binding is visible only lexically, i.e., "
"within the program text\n"
"that makes up the particular block of code.\n"
"An occurrence of an identifier of the same name outside this block\n"
"refers to a different binding; if no binding for the identifier\n"
"exists outside\n"
"the block, then the reference is invalid.\n"
"Blocks may be nested, and a binding in\n"
"one block may <a name=\"./intro:s15\"></a><i>shadow</i> a binding for an "
"identifier\n"
"of the same name in a surrounding block.\n"
"The <i>scope</i> of a binding is the block in which the bound identifier\n"
"is visible\n"
"minus any portions of the block in which the identifier is\n"
"shadowed.\n"
"Block structure and lexical scoping help create\n"
"programs that are\n"
"modular, easy to read, easy to maintain, and reliable.\n"
"Efficient code for lexical scoping is possible because a compiler\n"
"can determine before program evaluation the scope of all bindings\n"
"and the binding to which each identifier reference resolves.\n"
"This does not mean, of course, that a compiler can determine the\n"
"values of all variables, since the actual values are not computed\n"
"in most cases until the program executes."
msgstr ""
"</p><p>\n"
"</p><p>Переменные и ключевые слова Scheme \n"
"<a name=\"./intro:s12\"></a><i>лексически ограничены</i>, и программы\n"
"Scheme\n"
"<a name=\"./intro:s13\"></a><i>блочно-структурированы</i>.\n"
"Идентификаторы могут быть импортированы в программу или библиотеку или\n"
"связаны локально в пределах определенного блока кода, такого как\n"
"библиотека, программа или тело процедуры.\n"
"Лоакльное <a name=\"./intro:s14\"></a>связывание видно только лексически,\n"
"то есть внутри текста программы, который составляет конкретный блок кода.\n"
"Вхождение идентификатора с тем же именем вне этого блока относится к другой\n"
"привязке; если привязка для идентификатора не существует за пределами "
"блока,\n"
"то ссылка не действительна.\n"
"Блоки могут быть вложенными, а привязка в одном блоке может \n"
"<a name=\"./intro:s15\"></a><i>затенять</i> привязку для идентификатора с "
"тем \n"
"же именем в окружающем блоке.\n"
"<i>Область</i> привязки это блок, в котором видиться связанный "
"идентификатор\n"
"минус любые части блока, в котором идентификатор затеняется.\n"
"Блочная структура и лексическая область помогают создавать программы, "
"которые \n"
"являются модульными, легко читаемыми, простыми в обслуживании и надежными.\n"
"Эффективный код для лексического охвата возможен, потому что компилятор "
"может\n"
"определить перед выполнением программы область всех привязок и привязку, к\n"
"которой ссылается каждый идентификатор. Это, конечно, не означает, что\n"
"компилятор может определить значения всех переменных, так как фактические\n"
"значения не вычисляются в большинстве случаев до тех пор, пока программа\n"
"не выполниться."

#: intro.html:175
msgid ""
"</p><p>\n"
"</p><p>In most languages, a <a name=\"./intro:s16\"></a>procedure definition "
"is simply the association\n"
"of a name with a block of code.\n"
"Certain variables local to the block are the parameters of the\n"
"procedure.\n"
"In some languages, a procedure definition may appear within another\n"
"block or procedure so long as the procedure is invoked only during\n"
"execution of the enclosing block.\n"
"In others, procedures can be defined only at top level.\n"
"In Scheme, a procedure definition may appear within another block or\n"
"procedure, and the procedure may be invoked at any time thereafter,\n"
"even if the enclosing block has completed its execution.\n"
"To support <a name=\"./intro:s17\"></a>lexical scoping, a procedure carries "
"the lexical context\n"
"(environment) along with its code."
msgstr ""
"</p><p>\n"
"</p><p>В большинстве языков, <a name=\"./intro:s16\"></a>определение "
"процедуры - это\n"
"просто ассоциация имени с блоком кода. Некоторые переменные, локальные для\n"
"блока кода, являются параметрами процедуры.\n"
"В некотрых языках, определение процедуры может появляться в пределах другого "
"блока\n"
"или процедуры, такая процедура вызывается только во время выполнения "
"охватывающего\n"
"блока.\n"
"В других случаях, процедуры могут быть определены только на верхнем "
"уровне. \n"
"В Scheme, определение процедуры может выполняться в любом блоке или "
"процедуре,\n"
"и процедура может быть вызвана в любое время после этого, даже если "
"охватывающий\n"
"блок завершил выполнение. Для поддержки <a name=\"./intro:s17\"></a> "
"лексического охвата \n"
"процедура хранит лексический контекст(окружение) вместе с кодом.\n"

#: intro.html:182
msgid ""
"</p><p>\n"
"Furthermore, Scheme procedures are not always named.\n"
"Instead, procedures are <a name=\"./intro:s18\"></a>first-class data\n"
"objects like strings\n"
"or numbers, and variables are bound to procedures in the same way they\n"
"are bound to other objects."
msgstr ""
"</p><p>\n"
"Кроме того, процедуры Scheme не всегда имеют имя.\n"
"Вместо этого процедуры являются объектами данных <a name=\"./intro:s18\"></"
"a>первого\n"
"класса! такими как строки или числа, и переменные связываются с процедурами "
"так же,\n"
"как они связываются с другими объектами."

#: intro.html:199
msgid ""
"</p><p>\n"
"As with procedures in most other languages, Scheme procedures may\n"
"be recursive.\n"
"That is, any procedure may invoke itself directly or indirectly.\n"
"Many algorithms are most elegantly or efficiently specified recursively.\n"
"A special case of <a name=\"./intro:s19\"></a>recursion, called <a name=\"./"
"intro:s20\"></a>tail recursion, is used to\n"
"express <a name=\"./intro:s21\"></a>iteration, or <a name=\"./intro:s22\"></"
"a>looping.\n"
"A <a name=\"./intro:s23\"></a><i>tail call</i> occurs when one procedure "
"directly returns the result of\n"
"invoking another procedure; <i>tail recursion</i> occurs when\n"
"a procedure recursively tail-calls itself, directly or indirectly.\n"
"Scheme implementations are required to implement tail calls as\n"
"jumps (gotos), so the storage overhead normally associated with recursion\n"
"is avoided.\n"
"As a result, Scheme programmers need master only simple procedure calls\n"
"and recursion and need not be burdened with the usual assortment\n"
"of looping constructs."
msgstr ""
"</p><p>\n"
"Как и в случае процедур в большинстве языков программирования, процедуры "
"Scheme\n"
"могут быть рекурсивными.\n"
"То есть, любая процедура может вызывать себя прямо или косвенно.\n"
"Многие алгоритмы изящно или эффективно определяются рекурсивно.\n"
"Специальнй случай <a name=\"./intro:s19\"></a>рекурсии, называемый\n"
"<a name=\"./intro:s20\"></a>хвостовой рекурсией, используется для выражения\n"
"<a name=\"./intro:s21\"></a>итерации или <a name=\"./intro:s22\"></"
"a>циклов.\n"
"<a name=\"./intro:s23\"></a><i>Хвостовой вызов</i> происходит, когда одна "
"процедура\n"
"напрямую возвращает результат вызова другой процедуры; <i>хвостовая "
"рекурсия</i> \n"
"возникает когда процедура рекурсивно выполняет хвостовой вызов самой себя\n"
"прямо или косвенно.\n"
"Реализации Scheme требуют реализации хвостовых вызовов как "
"переходов(gotos),\n"
"поэтому издержки хранения(рост стека), обычно связанные с рекурсией "
"устраняются.\n"
"Как результат, программистам Scheme необходимо овладеть только простым "
"вызовом\n"
"процедур и рекрсией и не нужно обременяться использованием обычного "
"ассортимента\n"
"циклических конструкций."

#: intro.html:213
msgid ""
"</p><p>\n"
"</p><p>Scheme supports the definition of arbitrary control structures with\n"
"<a name=\"./intro:s24\"></a><i>continuations</i>.\n"
"A continuation is a procedure that embodies the remainder of a program\n"
"at a given point in the program.\n"
"A continuation may be obtained at any time during the execution of a\n"
"program.\n"
"As with other procedures, a continuation is a first-class object and\n"
"may be invoked at any time after its creation.\n"
"Whenever it is invoked, the program immediately continues from the\n"
"point where the continuation was obtained.\n"
"Continuations allow the implementation of complex control mechanisms\n"
"including explicit backtracking, multithreading, and coroutines."
msgstr ""
"</p><p>\n"
"</p><p>Scheme поддерживает определение произвольных структур управления с\n"
"<a name=\"./intro:s24\"></a><i>продолжением</i>.\n"
"Продолжение это процедура, которая олицетовряет оставшуюся часть программы "
"в \n"
"заданной точке программы.\n"
"Продолжение может быть получено в любое время выполнения программы. Как и \n"
"в случае с другими процедурами, продолжение является объектом первого "
"класса\n"
"и может быть вызвано в любое время после его создания.\n"
"Всякий раз, когда оно вызывается, программа немедленно продолжается с того "
"места,\n"
"где было получено продолжение. Продолжения позволяют реализовать сложные "
"механизмы\n"
"управления, включая явное обратное отслеживание, многопоточность и "
"сопрограммы."

#: intro.html:230
msgid ""
"</p><p>\n"
"<a name=\"./intro:s25\"></a>Scheme also allows programmers to define new "
"syntactic forms, or\n"
"<i>syntactic extensions</i>, by writing transformation procedures that\n"
"determine how each new syntactic form maps to existing syntactic forms.\n"
"These transformation procedures are themselves expressed in Scheme\n"
"with the help of a convenient high-level pattern language that automates\n"
"syntax checking, input deconstruction, and output reconstruction.\n"
"By default, lexical scoping is maintained through the transformation\n"
"process, but the programmer can exercise control over the scope of all\n"
"identifiers appearing in the output of a transformer.\n"
"Syntactic extensions are useful for defining new language constructs,\n"
"for emulating language constructs found in other languages, for\n"
"achieving the effects of in-line code expansion, and even for\n"
"emulating entire languages in Scheme.\n"
"Most large Scheme programs are built from a mix of\n"
"syntactic extensions and procedure definitions."
msgstr ""
"</p><p>\n"
"<a name=\"./intro:s25\"></a>Scheme также позволяет программистам определять "
"новые синтаксические\n"
"формы, или <i>синтаксические расширения</i>, записывая процедуры "
"синтаксического преобразования,\n"
"которые определяют как новая синтаксическая форма сопоставляется с "
"существующими синтаксическими\n"
"формами. Эти процедуры преобразования сами выражаются на Scheme с помощью "
"удобного\n"
"высокоуровневого языка шаблонов, который автоматизирует проверку синтаксиса, "
"деконструкцию ввода\n"
"и реконструкцию вывода.\n"
"По умолчанию, лексический охват поддерживается процессом преобразования, но "
"программист\n"
"может осуществлять контроль над охватом всех идентификаторов, появляющихся "
"на выходе преобразователя.\n"
"Синтаксические расширения полезны для определения новых языковых "
"конструкций, для эмуляции языковых\n"
"конструкций, найденых на других языках, для достижения эффектов расширения "
"встроенного кода и даже\n"
"для эмуляции целых языков на Scheme.\n"
"Большинство крупных программ Scheme построены из сочетания синтаксических "
"расширений\n"
"и определения процедур."

#: intro.html:243
msgid ""
"</p><p>\n"
"</p><p>Scheme evolved from the <a name=\"./intro:s26\"></a>Lisp language and "
"is considered to be a\n"
"dialect of Lisp.\n"
"Scheme inherited from Lisp the treatment of values as first-class\n"
"objects, several important data types, including symbols and lists,\n"
"and the representation of programs as objects, among other things.\n"
"Lexical scoping and block structure are features taken from\n"
"<a name=\"./intro:s27\"></a>Algol 60&nbsp;[<a class=\"citation\" href="
"\"bibliography.html#g239\">21</a>].\n"
"Scheme was the first Lisp dialect to adopt lexical scoping and block\n"
"structure, first-class procedures, the treatment of tail\n"
"calls as jumps, continuations, and lexically scoped syntactic\n"
"extensions."
msgstr ""
"</p><p>\n"
"</p><p>Scheme эволюционировала от <a name=\"./intro:s26\"></a>языка Lisp и "
"считается диалектом Lisp.\n"
"Scheme унаследовала от Lisp обработку значений как объектов первого класса, "
"несколько очень\n"
"важных типов данных, включая символы и списки, а также представления "
"программ как объектов,\n"
"среди прочего.\n"
"Лексический охват и блочная структура - эти понятия взятые из\n"
"<a name=\"./intro:s27\"></a>Algol 60&nbsp;[<a class=\"citation\" href="
"\"bibliography.html#g239\">21</a>].\n"
"Scheme была первым диалектом Lisp, принявшая лексическую область видимости и "
"блочную\n"
"структуру, процедуры первого класса, обработку хвостовых вызовов как простых "
"переходов(jump),\n"
"продолжений и лексического охвата синтаксических расширений."

#: intro.html:263
msgid ""
"</p><p>\n"
"<a name=\"./intro:s28\"></a>Common Lisp&nbsp;[<a class=\"citation\" href="
"\"bibliography.html#g245\">27</a>] and Scheme are both contemporary Lisp\n"
"languages, and the development of each has been influenced by the other.\n"
"Like Scheme but unlike earlier Lisp languages, Common Lisp\n"
"adopted lexical scoping and first-class procedures, although\n"
"Common Lisp's syntactic extension facility does not\n"
"respect lexical scoping.\n"
"Common Lisp's evaluation rules for procedures are different\n"
"from the evaluation rules for other objects, however, and it maintains a\n"
"separate namespace for procedure variables, thereby inhibiting\n"
"the use of procedures as first-class objects.\n"
"Also, Common Lisp does not support continuations or require proper\n"
"treatment of tail calls,\n"
"but it does support several less general control structures not found\n"
"in Scheme.\n"
"While the two languages are similar, Common\n"
"Lisp includes more specialized constructs, while Scheme includes\n"
"more general-purpose building blocks out of which such constructs (and\n"
"others) may be built."
msgstr ""
"</p><p>\n"
"<a name=\"./intro:s28\"></a>Common Lisp&nbsp;[<a class=\"citation\" href="
"\"bibliography.html#g245\">27</a>] и Scheme \n"
"являются двумя современными языками Lisp, и на развитие одного из них влияет "
"другой.\n"
"Подобно Scheme, но в отличие от предыдущих языков Lisp, Common Lisp\n"
"применяет лексическое окружение и процедуры первого класса, хотя средства\n"
"синтаксического расширения Common Lisp не учитывают лексический охват.\n"
"Однако правила вычисления Common Lisp для процедур отличаются от правил\n"
"вычисления для других объектов, и он поддерживает отдельное пространство "
"имен\n"
"для переменных процедур, тем самым препятствуя использованию процедур в "
"качестве\n"
"объектов первого класса.\n"
"Кроме того, Common Lisp не поддерживает продолжения или требует надлежащего\n"
"исправления хвостовых вызовов, но он поддерживает несколько менее общих "
"структур\n"
"управления, не найденых в Scheme.\n"
"Хотя оба языка похожи, Common Lisp включает в себя более специализированные "
"конструкции,\n"
"в то время как Scheme включает в себя более универсальные строительные "
"блоки, из которых\n"
"могут быть построены такие(и другие) конструкции."

#: intro.html:268
msgid ""
"</p><p>\n"
"</p><p>The remainder of this chapter describes Scheme's syntax and naming\n"
"conventions and the typographical conventions used throughout this\n"
"book."
msgstr ""
"</p><p>\n"
"</p><p>В оставшейся части этой главы описаны синтаксис Scheme и соглашение\n"
"об именовании и типографские соглашения используемые в этой книге."

#: intro.html:270
msgctxt "intro.html:270"
msgid "</p><p>"
msgstr ""

#: intro.html:272
msgid ""
"</p><h3><a name=\"g1\"></a><a name=\"./intro:h1\"></a>Section 1.1. Scheme "
"Syntax<a name=\"SECTINTROSYNTAX\"></a></h3>"
msgstr ""
"</p><h3><a name=\"g1\"></a><a name=\"./intro:h1\"></a>Section 1.1. Синтаксис "
"Scheme<a name=\"SECTINTROSYNTAX\"></a></h3>"

#: intro.html:279
msgid ""
"<p>\n"
"Scheme programs are made up of keywords, variables, <a name=\"./intro:"
"s29\"></a>structured forms,\n"
"constant data (numbers, characters, strings, quoted vectors, quoted\n"
"lists, quoted symbols, etc.), whitespace, and comments."
msgstr ""
"<p>\n"
"Программы Scheme состоят из ключевых слов, переменных, <a name=\"./intro:"
"s29\"></a>структурных форм,\n"
"постоянных данных (чисел, букв, строк, квотированных векторов, квотированных "
"списков, квотированных символов,\n"
"и т.д.), пробелов и коментариев."

#: intro.html:303
msgid ""
"</p><p>\n"
"Keywords, variables, and symbols are collectively called\n"
"<a name=\"./intro:s30\"></a>identifiers.\n"
"Identifiers may be formed from letters, digits, and certain special\n"
"characters, including <tt>?</tt>, <tt>!</tt>, <tt>.</tt>, <tt>+</tt>,\n"
"<tt>-</tt>, <tt>*</tt>, <tt>/</tt>, <tt>&lt;</tt>, <tt>=</tt>, <tt>&gt;</"
"tt>,\n"
"<tt>:</tt>, <tt>$</tt>, <tt>%</tt>, <tt>^</tt>, <tt>&amp;</tt>, <tt>_</tt>,\n"
"<tt>~</tt>, and <tt>@</tt>, as well as a set of additional Unicode\n"
"characters.\n"
"Identifiers cannot start with an at sign&nbsp;(&nbsp;<tt>@</tt>&nbsp;) and\n"
"normally cannot start with any character that can start\n"
"a number, i.e., a digit, plus sign&nbsp;(&nbsp;<tt>+</tt>&nbsp;), minus "
"sign&nbsp;(&nbsp;<tt>-</tt>&nbsp;), or\n"
"decimal point&nbsp;(&nbsp;<tt>.</tt>&nbsp;).\n"
"Exceptions are&nbsp;<tt>+</tt>,&nbsp;<tt>-</tt>, and&nbsp;<tt>...</tt>, "
"which are valid identifiers,\n"
"and any identifier starting with <tt>-&gt;</tt>.\n"
"For example, <tt>hi</tt>, <tt>Hello</tt>, <tt>n</tt>, <tt>x</tt>, <tt>x3</"
"tt>, <tt>x+2</tt>, and <tt>?$&amp;*!!!</tt> are all\n"
"identifiers.\n"
"Identifiers are delimited by whitespace, comments, parentheses, brackets, "
"string\n"
"(double) quotes&nbsp;(&nbsp;<tt>\"</tt>&nbsp;), and hash marks(&nbsp;<tt>#</"
"tt>&nbsp;).\n"
"A delimiter or any other Unicode character may be included anywhere within "
"the\n"
"name of an identifier as an escape of the form <tt>\\x<i>sv</i>;</tt>,\n"
"where <tt><i>sv</i></tt> is the scalar value of the character in "
"hexadecimal\n"
"notation."
msgstr ""
"</p><p>\n"
"Ключевые слова, переменные и символы называются\n"
"<a name=\"./intro:s30\"></a>идентификаторами.\n"
"Идентификаторы могут быть сформированы из букв, цифр и специальных значков,\n"
"включая <tt>?</tt>, <tt>!</tt>, <tt>.</tt>, <tt>+</tt>,\n"
"<tt>-</tt>, <tt>*</tt>, <tt>/</tt>, <tt>&lt;</tt>, <tt>=</tt>, <tt>&gt;</"
"tt>,\n"
"<tt>:</tt>, <tt>$</tt>, <tt>%</tt>, <tt>^</tt>, <tt>&amp;</tt>, <tt>_</tt>,\n"
"<tt>~</tt>, and <tt>@</tt>, а также набора дополнительных знаков Unicode.\n"
"Идентификаторы не могут начинаться со знака&nbsp;(&nbsp;<tt>@</tt>&nbsp;) и\n"
"обычно не могут начинаться с любого знака который может начинать число, \n"
"то есть цифры, знака плюс&nbsp;(&nbsp;<tt>+</tt>&nbsp;), знака минус&nbsp;"
"(&nbsp;<tt>-</tt>&nbsp;), или\n"
"десятичной точки&nbsp;(&nbsp;<tt>.</tt>&nbsp;).\n"
"Исключениямии являются &nbsp;<tt>+</tt>,&nbsp;<tt>-</tt>, и&nbsp;<tt>...</"
"tt>, которые являются действительными идентификаторами и любым "
"идентификатором, начинающимся с <tt>-&gt;</tt>.\n"
"Например, <tt>hi</tt>, <tt>Hello</tt>, <tt>n</tt>, <tt>x</tt>, <tt>x3</tt>, "
"<tt>x+2</tt>, и <tt>?$&amp;*!!!</tt> \n"
"вся идентификаторы.\n"
"Идентификаторы разделяются пробелами, коментариями, круглыми скобками, "
"квадратными скобками, строковыми кавычками\n"
"(двойными)&nbsp;(&nbsp;<tt>\"</tt>&nbsp;), и хеш-метками(&nbsp;<tt>#</"
"tt>&nbsp;).\n"
"Разделитель или любой другой знак Unicode может быть включен в любом месте "
"имени\n"
"идентификатора в виде escape-формы <tt>\\x<i>sv</i>;</tt>,\n"
"где <tt><i>sv</i></tt> это скалярное значение буквы(знака) в "
"шестнадцатеричной системе счисления."

#: intro.html:312
msgid ""
"</p><p>\n"
"There is no inherent limit on the length of a Scheme identifier;\n"
"programmers may use as many characters as necessary.\n"
"Long identifiers are no substitute for comments, however, and\n"
"frequent use of long identifiers can make a program difficult to\n"
"format and consequently difficult to read.  \n"
"A good rule is to use short identifiers when the scope of the identifier\n"
"is small and longer identifiers when the scope is larger."
msgstr ""
"</p><p>\n"
"Нет ограничений на длину идентификатора Scheme;\n"
"программисты могут использовать столько символов, сколько необходимо.\n"
"Однако длинные идентификаторы не заменяют комментарии, и частое\n"
"использование длинных идентификаторов может затруднить форматирование\n"
"программы и, следовательно, ее трудно прочитать. \n"
"Хорошим правилом является использование коротких идентификаторов, когда "
"охват\n"
"идентификатора является небольшим, и более длинных идентификаторов, когда\n"
"область действия больше."

#: intro.html:320
msgid ""
"</p><p>\n"
"Identifiers may be written in any mix of upper- and lower-case letters,\n"
"and case is significant, i.e., two identifiers are different even if\n"
"they differ only in case.\n"
"For example, <tt>abcde</tt>, <tt>Abcde</tt>, <tt>AbCdE</tt>, and <tt>ABCDE</"
"tt>\n"
"all refer to different identifiers.\n"
"This is a change from previous versions of the Revised Report."
msgstr ""
"</p><p>\n"
"Идентификаторы могут быть записаны в любом сочетании букв верхнего и "
"нижнего\n"
"регистров, и регистр важен, т.е два идентификатора отличаются друг от "
"друга,\n"
"если регстр их букв различен.\n"
"Например, <tt>abcde</tt>, <tt>Abcde</tt>, <tt>AbCdE</tt>, и <tt>ABCDE</tt>\n"
"относятся к различным идентификаторам.\n"
"Это изменение из предыдущей версии Revised Report."

#: intro.html:335
msgid ""
"</p><p>\n"
"Structured forms and <a name=\"./intro:s31\"></a>list constants are "
"enclosed\n"
"within parentheses, e.g., <tt>(a&nbsp;b&nbsp;c)</tt> or <tt>(*&nbsp;(-&nbsp;"
"x&nbsp;2)&nbsp;y)</tt>.\n"
"The <a name=\"./intro:s32\"></a>empty list is written <a name=\"./intro:"
"s33\"></a><tt>()</tt>.\n"
"<a name=\"./intro:s34\"></a>Matched sets of brackets\n"
"(&nbsp;<tt>[</tt>&nbsp;<tt>]</tt>&nbsp;) may be used in place of parentheses "
"and are\n"
"often used to set off the subexpressions of certain standard\n"
"syntactic forms for readability, as shown in examples throughout this book.\n"
"Vectors are written similarly to lists, except that they are\n"
"preceded by <tt>#(</tt> and terminated by <tt>)</tt>, e.g.,\n"
"<tt>#(this&nbsp;is&nbsp;a&nbsp;vector&nbsp;of&nbsp;symbols)</tt>.\n"
"Bytevectors are written as sequences of unsigned byte values (exact\n"
"integers in the range 0 through 255) bracketed by <tt>#vu8(</tt> and\n"
"<tt>)</tt>, e.g., <tt>#vu8(3&nbsp;250&nbsp;45&nbsp;73)</tt>."
msgstr ""
"</p><p>\n"
"Структурные формы и <a name=\"./intro:s31\"></a>константные списки "
"заключаются в круглы\n"
"скобки, например, <tt>(a&nbsp;b&nbsp;c)</tt> or <tt>(*&nbsp;(-&nbsp;"
"x&nbsp;2)&nbsp;y)</tt>.\n"
"<a name=\"./intro:s32\"></a>пустой список записывается как <a name=\"./intro:"
"s33\"></a><tt>()</tt>.\n"
"<a name=\"./intro:s34\"></a>Сгласованный набор скобок\n"
"(&nbsp;<tt>[</tt>&nbsp;<tt>]</tt>&nbsp;) может использоваться вместо круглых "
"скобок и часто\n"
"используется для выделения подвыражений определенных стандартных "
"синтаксических форм для\n"
"удобочитаемости, как показано в примерах этой книги. Векторы записываются "
"аналогично\n"
"спискам, за исключением того, что им предшествует <tt>#(</tt> и завершается "
"<tt>)</tt>, например,\n"
"<tt>#(this&nbsp;is&nbsp;a&nbsp;vector&nbsp;of&nbsp;symbols)</tt>.\n"
"Байт-вектор записывается как последовательность беззнаковых байтов( целые "
"числа в \n"
"диапазоне от 0 до 255) заключенные в скобки <tt>#vu8(</tt> и\n"
"<tt>)</tt>, например, <tt>#vu8(3&nbsp;250&nbsp;45&nbsp;73)</tt>."

#: intro.html:352
msgid ""
"</p><p>\n"
"Strings are enclosed in double quotation marks, e.g.,\n"
"<tt>\"I&nbsp;am&nbsp;a&nbsp;string\"</tt>.\n"
"Characters are preceded by <tt>#\\</tt>, e.g., <tt>#\\a</tt>.\n"
"Case is important within character and string constants, as within\n"
"identifiers.\n"
"Numbers may be written as integers, e.g., -123, as ratios, e.g., 1/2,\n"
"in floating-point or scientific notation,\n"
"e.g., 1.3 or 1e23, or as complex numbers in rectangular or polar\n"
"notation, e.g., 1.3-2.7i or -1.2@73.\n"
"Case is not important in the syntax of a number.\n"
"The <a name=\"./intro:s35\"></a>boolean values representing <a name=\"./"
"intro:s36\"></a><i>true</i> and <a name=\"./intro:s37\"></a><i>false</i>\n"
"are written <a name=\"./intro:s38\"></a><tt>#t</tt> and <a name=\"./intro:"
"s39\"></a><tt>#f</tt>.\n"
"Scheme conditional expressions actually treat <tt>#f</tt> as false and all\n"
"other objects as true, so\n"
"<tt>3</tt>, <tt>0</tt>, <tt>()</tt>, <tt>\"false\"</tt>, and <tt>nil</tt> "
"all count as true."
msgstr ""
"</p><p>\n"
"Строки заключаются в двойные кавычки, например,\n"
"<tt>\"I&nbsp;am&nbsp;a&nbsp;string\"</tt>.\n"
"Буквам предшествует <tt>#\\</tt>, например <tt>#\\a</tt>.\n"
"Регистр важен в буквенных и строковых константах, как и в нутри\n"
"идентификаторов.\n"
"Числа могут быть записаны в виде целых чисел, например, -123, в виде "
"отношений, пример, 1/2,\n"
"с плавающей точкой или научной нотации,\n"
"пример, 1.3 или 1e23, или как комплексные числа в прямугольной или полярной "
"нотации\n"
"пример, 1.3-2.7i or -1.2@73.\n"
"Регистр не важен в синтаксисе чисел.\n"
"<a name=\"./intro:s35\"></a>Логические значения представляются <a name=\"./"
"intro:s36\"></a><i>true</i>\n"
"и <a name=\"./intro:s37\"></a><i>false</i>\n"
"записываются как <a name=\"./intro:s38\"></a><tt>#t</tt> и <a name=\"./intro:"
"s39\"></a><tt>#f</tt>.\n"
"Условные выражения Scheme фактически рассматривают <tt>#f</tt> как ложь и "
"все остальные объекты\n"
"как истину, поэтому <tt>3</tt>, <tt>0</tt>, <tt>()</tt>, <tt>\"false\"</tt>, "
"и <tt>nil</tt> все рассматриваются\n"
"как истина."

#: intro.html:358
msgid ""
"</p><p>\n"
"Details of the syntax for each type \n"
"of constant data are given in the individual\n"
"sections of Chapter&nbsp;<a href=\"objects.html#g106\">6</a> and in the "
"formal syntax of\n"
"Scheme starting on page&nbsp;<a href=\"grammar.html#APPENDIXFORMALSYNTAX"
"\">455</a>."
msgstr ""
"</p><p>\n"
"Подробности синтаксиса для каждого типа константных данных приведены в\n"
"отдельных разделах Главы&nbsp;<a href=\"objects.html#g106\">6</a> и в "
"формальном синтаксисе\n"
"Scheme начиная со страницы&nbsp;<a href=\"grammar.html#APPENDIXFORMALSYNTAX"
"\">455</a>."

#: intro.html:375
msgid ""
"</p><p>\n"
"Scheme <a name=\"./intro:s40\"></a>expressions may span several lines, and "
"no explicit\n"
"terminator is required.\n"
"Since the number of <a name=\"./intro:s41\"></a>whitespace characters "
"(spaces and newlines)\n"
"between expressions is not\n"
"significant, Scheme programs should be indented to show the structure\n"
"of the code in a way that makes the code as readable as possible.\n"
"<a name=\"./intro:s42\"></a>Comments may appear on any line of a Scheme "
"program, between\n"
"a <a name=\"./intro:s43\"></a><a name=\"./intro:s44\"></a>semicolon (&nbsp;"
"<tt>;</tt>&nbsp;) and the end of the line.\n"
"Comments explaining a particular Scheme expression are normally placed\n"
"at the same indentation level as the expression, on the line before\n"
"the expression.\n"
"Comments explaining a procedure or group of procedures are normally\n"
"placed before the procedures, without indentation.\n"
"Multiple comment characters are often used to set off the latter kind of\n"
"comment, e.g., <tt>;;;&nbsp;The&nbsp;following&nbsp;procedures&nbsp;...</tt>."
msgstr ""
"</p><p>\n"
"Scheme <a name=\"./intro:s40\"></a>выражения могут охватывать несколько "
"строк, и явный\n"
"терминатор не требуется.\n"
"Так как количество <a name=\"./intro:s41\"></a>пробельных знаков (пробелов и "
"новых строк)\n"
"между выражениями не велико, программы Scheme должны иметь отступ, чтобы "
"отображать\n"
"структуру кода, таким образом, чтобы делать код как можно больше "
"удобочитаемым.\n"
"<a name=\"./intro:s42\"></a>Комментарии могут появляться в любой строке "
"программы Scheme,\n"
"между <a name=\"./intro:s43\"></a><a name=\"./intro:s44\"></a>точкой с "
"запятой (&nbsp;<tt>;</tt>&nbsp;)\n"
"и концом строки.\n"
"Комментарии, объясняющие конкретное выражение схемы, обычно помещаются на "
"том же уровне\n"
"отступов, что и выражение, в строке перед выражением.\n"
"Комменарии, объясняющие процедуру или группу процедур, обычно помещаются "
"перед\n"
"процедурами без отступов.\n"
"Несколько знаков комментария часто используются что бы задать окончательный "
"вид\n"
"комментария, например, <tt>;;;&nbsp;The&nbsp;following&nbsp;"
"procedures&nbsp;...</tt>."

#: intro.html:388
msgid ""
"</p><p>\n"
"Two other forms of comments are supported: block comments and datum "
"comments.\n"
"Block comments are delimited by <tt>#|</tt> and <tt>|#</tt> pairs, and may "
"be\n"
"nested.\n"
"A datum comment consists of a <tt>#;</tt> prefix and the datum (printed data "
"value)\n"
"that follows it.\n"
"Datum comments are typically used to comment out individual definitions\n"
"or expressions.\n"
"For example, <tt>(three&nbsp;#;(not&nbsp;four)&nbsp;element&nbsp;list)</tt> "
"is just what it says.\n"
"Datum comments may also be nested, though <tt>#;#;(a)(b)</tt> has the\n"
"somewhat nonobvious effect of commenting out both <tt>(a)</tt> and\n"
"<tt>(b)</tt>."
msgstr ""
"</p><p>\n"
"Поддерживаются две другие формы комментариев: блок комментариев и "
"комментарии данные.\n"
"Блок комментариев ограничивается парой <tt>#|</tt> и <tt>|#</tt>, и может "
"быть\n"
"вложенным.\n"
"Комментарии данных состоит из префикса <tt>#;</tt> и базовой формы "
"данных(datum)(печатаемое представление данных) следующих за ним.\n"
"Комментарии данные обычно используется для комментирования отдельных "
"определений и выражений.\n"
"Например, <tt>(three&nbsp;#;(not&nbsp;four)&nbsp;element&nbsp;list)</tt> это "
"то что он говорит.\n"
"Комментарии данных также могут быть вложенными, хотя <tt>#;#;(a)(b)</tt> "
"имеет несколько\n"
"неочевидный эффект комментирования как <tt>(a)</tt> и\n"
"<tt>(b)</tt>."

#: intro.html:396
msgid ""
"</p><p>\n"
"Some Scheme values, such as procedures and ports, do not have standard\n"
"printed representations and can thus never appear as a constant in the\n"
"printed syntax of a program.\n"
"This book uses the notation <tt>#&lt;<i>description</i>&gt;</tt> when "
"showing the\n"
"output of an operation that returns such a value, e.g.,\n"
"<tt>#&lt;procedure&gt;</tt> or <tt>#&lt;port&gt;</tt>."
msgstr ""
"</p><p>\n"
"Некоторые значения Scheme, такие как процедуры и порты, не имеют стандартных "
"печатных\n"
"представлений и таким образом, никогда не моугт отображаться как константы "
"в \n"
"печатном синтаксисе программы.\n"
"В этой книге используется обозначение <tt>#&lt;<i>description</i>&gt;</tt> "
"при отображении\n"
"вывода операции, которая возрвращает такое значение, например,\n"
"<tt>#&lt;procedure&gt;</tt> or <tt>#&lt;port&gt;</tt>."

#: intro.html:398
msgctxt "intro.html:398"
msgid "</p><p>"
msgstr ""

#: intro.html:400
msgid ""
"</p><h3><a name=\"g2\"></a><a name=\"./intro:h2\"></a>Section 1.2. Scheme "
"Naming Conventions<a name=\"SECTINTRONAMING\"></a></h3>"
msgstr ""
"</p><h3><a name=\"g2\"></a><a name=\"./intro:h2\"></a>Section 1.2. "
"Соглашение об Именах Scheme<a name=\"SECTINTRONAMING\"></a></h3>"

#: intro.html:407
msgid ""
"<p>\n"
"Scheme's <a name=\"./intro:s45\"></a>naming conventions are designed to "
"provide a high degree\n"
"of regularity.\n"
"The following is a list of these naming conventions:"
msgstr ""
"<p>\n"
"Соглашениие об именах<a name=\"./intro:s45\"></a> Scheme разработано для "
"обеспечания\n"
"высокой степени единообразия.\n"
"Ниже приведен список этих соглашений об именах:"

#: intro.html:416
msgid ""
"</p><p>\n"
"</p><ul>\n"
"<li>Predicate names end in a\n"
"<a name=\"./intro:s46\"></a><a name=\"./intro:s47\"></a>question mark (&nbsp;"
"<tt>?</tt>&nbsp;).\n"
"Predicates are procedures that return a true or false\n"
"answer, such as <tt>eq?</tt>, <tt>zero?</tt>, and <tt>string=?</tt>.\n"
"The common numeric comparators <tt>=</tt>, <tt>&lt;</tt>, <tt>&gt;</tt>, "
"<tt>&lt;=</tt>,\n"
"and <tt>&gt;=</tt> are exceptions to this naming convention."
msgstr ""
"</p><p>\n"
"</p><ul>\n"
"<li>Имена предикатов заканчиваюся\n"
"<a name=\"./intro:s46\"></a><a name=\"./intro:s47\"></a>знаком вопроса "
"(&nbsp;<tt>?</tt>&nbsp;).\n"
"Предикаты это процедуры, которые возвращают ответ true или false, такой как\n"
"<tt>eq?</tt>, <tt>zero?</tt>, и <tt>string=?</tt>.\n"
"Общие операции сравнения чисел <tt>=</tt>, <tt>&lt;</tt>, <tt>&gt;</tt>, "
"<tt>&lt;=</tt>,\n"
"и <tt>&gt;=</tt> являются исклюением из этого соглашения об именах."

#: intro.html:420
msgid ""
"<p>\n"
"</p></li><li>Type <a name=\"./intro:s48\"></a>predicates, such as <tt>pair?</"
"tt>, are created from\n"
"the name of the type, in this case <tt>pair</tt>, and the question mark."
msgstr ""
"<p>\n"
"</p></li><li>Предикаты <a name=\"./intro:s48\"></a>проверки типа, такие как "
"<tt>pair?</tt>, создаются из\n"
"имени типа, в данном случае <tt>pair</tt>, и знака вопроса."

#: intro.html:427
msgid ""
"<p>\n"
"</p></li><li>The names of most character, string, and vector\n"
"procedures start with the prefix <tt>char-</tt>, <tt>string-</tt>, and\n"
"<tt>vector-</tt>, e.g., <tt>string-append</tt>.\n"
"(The names of some list procedures start with <tt>list-</tt>, but most\n"
"do not.)"
msgstr ""
"<p>\n"
"</p></li><li>Имена большинства буквенных, строковых и векторных процедур\n"
"начинаются с префиксов <tt>char-</tt>, <tt>string-</tt>, и\n"
"<tt>vector-</tt>, например, <tt>string-append</tt>.\n"
"(Имена некоторых процедур list тоже начинаются с <tt>list-</tt>, но "
"большинство\n"
"нет.)"

#: intro.html:433
msgid ""
"<p>\n"
"</p></li><li>The names of procedures that convert an object of\n"
"one type into an object of another type are written as\n"
"<a name=\"./intro:s49\"></a><tt><i>type<sub>1</sub></i>-&gt;<i>type<sub>2</"
"sub></i></tt>,\n"
"e.g., <tt>vector-&gt;list</tt>."
msgstr ""
"<p>\n"
"</p></li><li>Имена процедур которые преобразуют объект одного типа в\n"
"объект другого типа, записываются как\n"
"<a name=\"./intro:s49\"></a><tt><i>type<sub>1</sub></i>-&gt;<i>type<sub>2</"
"sub></i></tt>,\n"
"например, <tt>vector-&gt;list</tt>."

#: intro.html:443
msgid ""
"<p>\n"
"</p></li><li>The names of procedures and syntactic forms\n"
"that cause side effects end with an\n"
"<a name=\"./intro:s50\"></a><a name=\"./intro:s51\"></a>exclamation point "
"(&nbsp;<tt>!</tt>&nbsp;).\n"
"These include <tt>set!</tt> and <tt>vector-set!</tt>.\n"
"Procedures that perform input or output technically cause <a name=\"./intro:"
"s52\"></a>side effects,\n"
"but their names are exceptions to this rule.\n"
"</li></ul>\n"
"<p>"
msgstr ""
"<p>\n"
"</p></li><li>Имена процедур и синтаксических форм, которые\n"
"вызывают побочные эффекты, заканчиваются\n"
"<a name=\"./intro:s50\"></a><a name=\"./intro:s51\"></a>восклицательным "
"знаком (&nbsp;<tt>!</tt>&nbsp;).\n"
"К ним относятся <tt>set!</tt> и <tt>vector-set!</tt>.\n"
"Процедуры, которые выполняют ввод и вывод, технически вызывают<a name=\"./"
"intro:s52\"></a> побочные эффеты, но их\n"
"имена являются исключениями из этого правила.\n"
"</li></ul>\n"
"<p>"

#: intro.html:447
msgid ""
"</p><p>\n"
"Programmers should employ these same conventions in their own code whenever\n"
"possible."
msgstr ""
"</p><p>\n"
"Программисты должны использовать эти же соглашения в своем собственном "
"коде,\n"
"когда это возможно."

#: intro.html:450
msgctxt "intro.html:450"
msgid "</p><p>"
msgstr ""

#: intro.html:452
msgid ""
"</p><h3><a name=\"g3\"></a><a name=\"./intro:h3\"></a>Section 1.3. "
"Typographical and Notational Conventions<a name=\"SECTINTRONOTATION\"></a></"
"h3>"
msgstr ""
"</p><h3><a name=\"g3\"></a><a name=\"./intro:h3\"></a>Section 1.3. "
"Типографические и нотационные соглашения<a name=\"SECTINTRONOTATION\"></a></"
"h3>"

#: intro.html:469
msgid ""
"<p>\n"
"A standard procedure or syntactic form whose sole purpose is to perform\n"
"some side effect is said to return <a name=\"./intro:s53\"></"
"a><i>unspecified</i>.\n"
"This means that an implementation is free to return any number of\n"
"values, each of which can be any Scheme object,\n"
"as the value of the procedure or syntactic form.\n"
"Do not count on these values being the same across implementations, the\n"
"same across versions of the same implementation, or even the same across\n"
"two uses of the procedure or syntactic form.\n"
"Some Scheme systems routinely use a special object to represent\n"
"unspecified values.\n"
"Printing of this object is often suppressed by interactive Scheme\n"
"systems, so that the values of expressions returning unspecified values \n"
"are not printed."
msgstr ""

#: intro.html:483
msgid ""
"</p><p>\n"
"<a name=\"./intro:s54\"></a>While most standard procedures return a single "
"value, the language\n"
"supports procedures that return zero, one, more than one, or even a\n"
"variable number of values via the mechanisms described in\n"
"Section&nbsp;<a href=\"control.html#g104\">5.8</a>.\n"
"Some standard expressions can evaluate to multiple values if one of their\n"
"subexpressions evaluates to multiple values, e.g., by calling a procedure\n"
"that returns multiple values.\n"
"When this situation can occur, an expression is said to return \"the\n"
"values\" rather than simply \"the value\" of its subexpression.\n"
"Similarly, a standard procedure that returns the values resulting from a\n"
"call to a procedure argument is said to return the values returned by the\n"
"procedure argument."
msgstr ""

#: intro.html:494
msgid ""
"</p><p>\n"
"<a name=\"./intro:s55\"></a>This book uses the words \"must\" and \"should\" "
"to\n"
"describe program requirements, such as the requirement to provide an index\n"
"that is less than the length of the vector in a call to\n"
"<tt>vector-ref</tt>.\n"
"If the word \"must\" is used, it means that the requirement is enforced\n"
"by the implementation, i.e., an exception is raised, usually with\n"
"condition type <tt>&amp;assertion</tt>.\n"
"If the word \"should\" is used, an exception may or may not be raised,\n"
"and if not, the behavior of the program is undefined."
msgstr ""

#: intro.html:501
msgid ""
"</p><p>\n"
"<a name=\"./intro:s56\"></a>The phrase \"syntax violation\" is used to\n"
"describe a situation in which a program is malformed.\n"
"Syntax violations are detected prior to program execution.\n"
"When a syntax violation is detected, an exception of type <tt>&amp;syntax</"
"tt>\n"
"is raised and the program is not executed."
msgstr ""

#: intro.html:516
msgid ""
"</p><p>\n"
"The typographical conventions used in this book are straightforward.\n"
"All Scheme objects are printed in a <tt>typewriter</tt> typeface, just as "
"they\n"
"are to be typed at the keyboard.\n"
"This includes syntactic keywords, variables, constant\n"
"objects, Scheme expressions, and example programs.\n"
"An <i>italic</i> typeface is used to set off syntax variables in\n"
"the descriptions of syntactic forms and arguments in the descriptions of\n"
"procedures.\n"
"Italics are also used to set off technical terms the first time they\n"
"appear.\n"
"In general, names of syntactic forms and procedures are never\n"
"capitalized, even at the beginning of a sentence.\n"
"The same is true for syntax variables written in italics."
msgstr ""

#: intro.html:532
msgid ""
"</p><p>\n"
"In the description of a syntactic form or procedure, one or more prototype\n"
"patterns show the syntactic form or forms or the correct number or numbers\n"
"of arguments for an application of the procedure.\n"
"The keyword or procedure name is given in typewriter font,\n"
"as are parentheses.\n"
"The remaining pieces of the syntax or arguments are shown in italics,\n"
"using a name that implies the type of expression or argument expected\n"
"by the syntactic form or procedure.\n"
"Ellipses are used to specify\n"
"zero or more occurrences of a subexpression or argument.\n"
"For example, <tt>(or&nbsp;<i>expr</i>&nbsp;...)</tt> describes the <tt>or</"
"tt>\n"
"syntactic form, which has zero or more subexpressions, and\n"
"<tt>(member&nbsp;<i>obj</i>&nbsp;<i>list</i>)</tt> describes the <tt>member</"
"tt>\n"
"procedure, which expects two arguments, an object and a list."
msgstr ""

#: intro.html:544
msgid ""
"</p><p>\n"
"A syntax violation occurs if the structure of a syntactic form does\n"
"not match its prototype.\n"
"Similarly, an exception with condition type <tt>&amp;assertion</tt> is "
"raised\n"
"if the number of arguments passed to a standard procedure does not match\n"
"what it is specified to receive.\n"
"An exception with condition type <tt>&amp;assertion</tt> is also raised if "
"a\n"
"standard procedure receives an argument whose type is not the\n"
"type implied by its name or does not meet other criteria given in\n"
"the description of the procedure.\n"
"For example, the prototype for <tt>vector-set!</tt> is"
msgstr ""

#: intro.html:546
msgctxt "intro.html:546"
msgid "</p><p>"
msgstr ""

#: intro.html:557
msgid ""
"</p><p><tt>(vector-set!&nbsp;<i>vector</i>&nbsp;<i>n</i>&nbsp;<i>obj</i>)</"
"tt>\n"
"</p><p>and the description says that\n"
"<tt><i>n</i></tt> must be an exact nonnegative integer strictly less than\n"
"the length of <tt><i>vector</i></tt>.\n"
"Thus, <tt>vector-set!</tt> must receive three arguments, the first\n"
"of which must be a vector, the second of which must be an exact nonnegative\n"
"integer less than the length of the vector, and the third of which may\n"
"be any Scheme value.\n"
"Otherwise, an exception with condition type <tt>&amp;assertion</tt> is\n"
"raised."
msgstr ""

#: intro.html:566
msgid ""
"</p><p>\n"
"In most cases, the type of argument required is obvious, as with\n"
"<tt><i>vector</i></tt>, <tt><i>obj</i></tt>, or <tt><i>binary-input-port</"
"i></tt>.\n"
"In others, primarily within the descriptions of numeric routines,\n"
"abbreviations are used, such as <tt><i>int</i></tt> for integer, "
"<tt><i>exint</i></tt>\n"
"for exact integer, and <tt><i>fx</i></tt> for fixnum.\n"
"These abbreviations are explained at the start of the sections\n"
"containing the affected entries."
msgstr ""

#: intro.html:579
msgid ""
"</p><hr class=\"copyright\" align=\"left\">\n"
"<p>\n"
"R. Kent Dybvig / <it>The Scheme Programming Language, Fourth Edition</"
"it><br>\n"
"Copyright © 2009 <a class=\"plain\" href=\"http://mitpress.mit.edu/catalog/"
"item/default.asp?ttype=2&amp;tid=11984\">The MIT Press</a>.  Electronically "
"reproduced by permission.<br>\n"
"Illustrations © 2009 <a class=\"plain\" href=\"http://hebert.kitp.ucsb.edu/"
"\">Jean-Pierre Hébert</a><br>\n"
"ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93<br>\n"
"<a class=\"plain\" href=\"http://mitpress.mit.edu/catalog/item/default.asp?"
"ttype=2&amp;tid=11984\">to order this book</a> / <a class=\"plain\" href="
"\"canned/about.html\">about this book</a>\n"
"</p>\n"
"<p><a class=\"plain\" href=\"http://www.scheme.com/\">http://www.scheme.com</"
"a></p>"
msgstr ""

#: intro.html:581
msgid "</body></html>"
msgstr ""
