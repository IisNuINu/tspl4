<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0046)intro.html#./intro:h0 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Введение</title>
<link href="./intro_files/tspl.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g0"></a>
<a name="./intro:h0"></a>

<div>
<img  src="./intro_files/ch1.png">
</div>
<h1>Chapter 1. Введение<a name="CHPTINTRO"></a></h1>

<p>
Scheme это универсальный компьютерный язык программирования. Это язык
высокого уровня, поддерживающий операции со структурированными данными, 
такими как строки, списки и векторы. а также операции над более
традиционными данными, такими как числа и символы.
Хотя Scheme часто ассоциируется с символическими приложениями, его богатый
набор типов данных и гибкие структуры управления делают его действительно
универсальным языком. Scheme был использован для написания текстовых
редакторов, оптимизирующих компиляторов, операционных систем, графических
пакетов, экспертных систем, числовых приложений, пактов финансового
анализа, систем виртуальной реальности, и приктически любого другого вида
приложений, которое можно себе представить. Scheme - довольно простой
язык для изучения, поскольку он основан на нескольких синтаксических формах
и семантических концепциях, и интерактивный характер большинства его реализаций
стимулирует эксперименты. Однако Scheme - сложный язык, чтобы понять его;
развитие способности использовать весь его потенциал требует тщательного
изучения и практики.

</p><p>
Программы Scheme легко переносимы в разных версиях одной и тойже реализации
Scheme на разных машинах, потому что зависимости от машины почти полностью
скрыты от программиста. Они также переносимы в разных реализациях из-за усилий
группы разработчиков языка Scheme, опубликовавших серию отчетов, 
"<a name="./intro:s0"></a>Revised Reports" on Scheme. The most recent, the 
"Revised<sup>6</sup> Report"&nbsp;[<a class="citation" href="bibliography.html#g242">24</a>], 
подчеркивает переносимость через набор стандартных библиотек и стандартный механизм
для определения новых переносимых библиотек и программ верхнего уровня.

</p><p>
Хотя некоторые ранние версии системы Scheme были неэффективными и медленными,
многие новые реализации на основе компилятора бывают быстрыми, а программы
работают наравне с эквивалентными программами, написанными на языках
более низкого уровня.  Относительная неэффективность, которая иногда остается
результатом проверок во время выполнения, которые поддерживают общую арифметику
и помогают программистам обнаруживать и исправлять различные распространенные
ошибки программирования. Эти проверки могут быть отключены во многих реализациях.

</p><p>
</p><p>Scheme поддерживает множество типов значений данных, или
<a name="./intro:s1"></a><i>объектов</i>, включая символьные знаки(char), 
строки, символы(symbols), списки и векторы объектов, и полный набор
числовых типов данных, включая комплексные, вещественные и произвольные
значения рациональных чисел.

</p><p>
Хранилище требуемое для хранения содержимого объекта, 
<a name="./intro:s2"></a>динамически распределяется
по мере необходимости и сохраняется до тех пор, пока оно
больше не понадобиться, а затем автоматически освобождается,
как правило <a name="./intro:s3"></a><i>сборщиком мусора</i> который
переодически востанавливает хранилище, используемое недоступными
объектами. Простые неделимые значения, такие как малые целые числа,
буквы, булевы значения и пустые списки, обычно представляются в виде
непосредственных значений и следовательно, не несут накладных расходов
на распределение и сопровождение.

</p><p>
Независимо от представления, все объекты являюстя 
<a name="./intro:s4"></a><i>первоклассными</i> значениями данных;
поскольку они могу сохраняться на неопределенный срок, они могут
свободно передаваться в качестве аргументов процедуры, возвращаться
как значения из процедур и объединяться для формирования новых 
объектов. Это контрастирует  со многими другими языками, на которых
совокумные значения данных, такие как массивы, либо статически
распределяются, либо никогда не освобождаются от работы, выделяются
при входе в блок кода и безоговорочно освобождаются при выходе из
блока или явно распределяются и освобождаются программистом.

</p><p>
Scheme это язык с вызовом по значению, по крайней мере для изменяемых объектов
(объектов, которые могут быть изменены), значения являются <a name="./intro:s5"></a>
указателями на фактическое хранилище. Однако эти указатели остаются за кулисами
и программисты не должны осознавать их, кроме понимания того, что хранилище объекта
не копируется, когда объект передается или возвращается из процедуры.

</p><p>
<a name="./intro:s6"></a>В основе языка Scheme лежит небольшое ядро
синтаксическх форм, из которых построены все остальные формы.
Эти основные формы, набор расширенных синтаксических форм полученый
из них, и набор <a name="./intro:s7"></a>примитивных процедур составляют
полный язык Scheme.
Интерпретатор<a name="./intro:s8"></a> или <a name="./intro:s9"></a> компилятор для
Scheme могут быть довольно маленькими и потенциально быстрыми и надежными. Расширенные
синтаксические формы и многие примитивные процедуры могут быть определены в самой
Scheme, упрощая реализацию и повышая надежность.

</p><p>
Программы Scheme имеют общее печатное представление со структурами
данных Scheme.
В результате любая программа Scheme имеет естественное и очевидное
внутренне представление как объект Scheme.
Например, <a name="./intro:s10"></a>переменные и синтаксические<a name="./intro:s11"></a> ключевые слова
соответствуют символам, а структурированные синтаксические формы соответствуют спискам.
Это представление является основой для возможностей синтаксического расширения,
предоставляемых Scheme для определения новых синтаксических форм в терминах
существующих синтаксических форм и процедур.
Это также облегчает реализацию интерпретаторов, компиляторов и других инструментов
преобразования программ для Scheme непосредственно на Scheme, а также
инструментов преобразования программ для других языков в Scheme.

</p><p>
</p><p>Переменные и ключевые слова Scheme 
<a name="./intro:s12"></a><i>лексически ограничены</i>, и программы
Scheme
<a name="./intro:s13"></a><i>блочно-структурированы</i>.
Идентификаторы могут быть импортированы в программу или библиотеку или
связаны локально в пределах определенного блока кода, такого как
библиотека, программа или тело процедуры.
Лоакльное <a name="./intro:s14"></a>связывание видно только лексически,
то есть внутри текста программы, который составляет конкретный блок кода.
Вхождение идентификатора с тем же именем вне этого блока относится к другой
привязке; если привязка для идентификатора не существует за пределами блока,
то ссылка не действительна.
Блоки могут быть вложенными, а привязка в одном блоке может 
<a name="./intro:s15"></a><i>затенять</i> привязку для идентификатора с тем 
же именем в окружающем блоке.
<i>Область</i> привязки это блок, в котором видиться связанный идентификатор
минус любые части блока, в котором идентификатор затеняется.
Блочная структура и лексическая область помогают создавать программы, которые 
являются модульными, легко читаемыми, простыми в обслуживании и надежными.
Эффективный код для лексического охвата возможен, потому что компилятор может
определить перед выполнением программы область всех привязок и привязку, к
которой ссылается каждый идентификатор. Это, конечно, не означает, что
компилятор может определить значения всех переменных, так как фактические
значения не вычисляются в большинстве случаев до тех пор, пока программа
не выполниться.

</p><p>
</p><p>В большинстве языков, <a name="./intro:s16"></a>определение процедуры - это
просто ассоциация имени с блоком кода. Некоторые переменные, локальные для
блока кода, являются параметрами процедуры.
В некотрых языках, определение процедуры может появляться в пределах другого блока
или процедуры, такая процедура вызывается только во время выполнения охватывающего
блока.
В других случаях, процедуры могут быть определены только на верхнем уровне. 
В Scheme, определение процедуры может выполняться в любом блоке или процедуре,
и процедура может быть вызвана в любое время после этого, даже если охватывающий
блок завершил выполнение. Для поддержки <a name="./intro:s17"></a> лексического охвата 
процедура хранит лексический контекст(окружение) вместе с кодом.


</p><p>
Кроме того, процедуры Scheme не всегда имеют имя.
Вместо этого процедуры являются объектами данных <a name="./intro:s18"></a>первого
класса! такими как строки или числа, и переменные связываются с процедурами так же,
как они связываются с другими объектами.

</p><p>
Как и в случае процедур в большинстве языков программирования, процедуры Scheme
могут быть рекурсивными.
То есть, любая процедура может вызывать себя прямо или косвенно.
Многие алгоритмы изящно или эффективно определяются рекурсивно.
Специальнй случай <a name="./intro:s19"></a>рекурсии, называемый
<a name="./intro:s20"></a>хвостовой рекурсией, используется для выражения
<a name="./intro:s21"></a>итерации или <a name="./intro:s22"></a>циклов.
<a name="./intro:s23"></a><i>Хвостовой вызов</i> происходит, когда одна процедура
напрямую возвращает результат вызова другой процедуры; <i>хвостовая рекурсия</i> 
возникает когда процедура рекурсивно выполняет хвостовой вызов самой себя
прямо или косвенно.
Реализации Scheme требуют реализации хвостовых вызовов как переходов(gotos),
поэтому издержки хранения(рост стека), обычно связанные с рекурсией устраняются.
Как результат, программистам Scheme необходимо овладеть только простым вызовом
процедур и рекрсией и не нужно обременяться использованием обычного ассортимента
циклических конструкций.

</p><p>
</p><p>Scheme поддерживает определение произвольных структур управления с
<a name="./intro:s24"></a><i>продолжением</i>.
Продолжение это процедура, которая олицетовряет оставшуюся часть программы в 
заданной точке программы.
Продолжение может быть получено в любое время выполнения программы. Как и 
в случае с другими процедурами, продолжение является объектом первого класса
и может быть вызвано в любое время после его создания.
Всякий раз, когда оно вызывается, программа немедленно продолжается с того места,
где было получено продолжение. Продолжения позволяют реализовать сложные механизмы
управления, включая явное обратное отслеживание, многопоточность и сопрограммы.

</p><p>
<a name="./intro:s25"></a>Scheme также позволяет программистам определять новые синтаксические
формы, или <i>синтаксические расширения</i>, записывая процедуры синтаксического преобразования,
которые определяют как новая синтаксическая форма сопоставляется с существующими синтаксическими
формами. Эти процедуры преобразования сами выражаются на Scheme с помощью удобного
высокоуровневого языка шаблонов, который автоматизирует проверку синтаксиса, деконструкцию ввода
и реконструкцию вывода.
По умолчанию, лексический охват поддерживается процессом преобразования, но программист
может осуществлять контроль над охватом всех идентификаторов, появляющихся на выходе преобразователя.
Синтаксические расширения полезны для определения новых языковых конструкций, для эмуляции языковых
конструкций, найденых на других языках, для достижения эффектов расширения встроенного кода и даже
для эмуляции целых языков на Scheme.
Большинство крупных программ Scheme построены из сочетания синтаксических расширений
и определения процедур.

</p><p>
</p><p>Scheme эволюционировала от <a name="./intro:s26"></a>языка Lisp и считается диалектом Lisp.
Scheme унаследовала от Lisp обработку значений как объектов первого класса, несколько очень
важных типов данных, включая символы и списки, а также представления программ как объектов,
среди прочего.
Лексический охват и блочная структура - эти понятия взятые из
<a name="./intro:s27"></a>Algol 60&nbsp;[<a class="citation" href="bibliography.html#g239">21</a>].
Scheme была первым диалектом Lisp, принявшая лексическую область видимости и блочную
структуру, процедуры первого класса, обработку хвостовых вызовов как простых переходов(jump),
продолжений и лексического охвата синтаксических расширений.

</p><p>
<a name="./intro:s28"></a>Common Lisp&nbsp;[<a class="citation" href="bibliography.html#g245">27</a>] и Scheme 
являются двумя современными языками Lisp, и на развитие одного из них влияет другой.
Подобно Scheme, но в отличие от предыдущих языков Lisp, Common Lisp
применяет лексическое окружение и процедуры первого класса, хотя средства
синтаксического расширения Common Lisp не учитывают лексический охват.
Однако правила вычисления Common Lisp для процедур отличаются от правил
вычисления для других объектов, и он поддерживает отдельное пространство имен
для переменных процедур, тем самым препятствуя использованию процедур в качестве
объектов первого класса.
Кроме того, Common Lisp не поддерживает продолжения или требует надлежащего
исправления хвостовых вызовов, но он поддерживает несколько менее общих структур
управления, не найденых в Scheme.
Хотя оба языка похожи, Common Lisp включает в себя более специализированные конструкции,
в то время как Scheme включает в себя более универсальные строительные блоки, из которых
могут быть построены такие(и другие) конструкции.

</p><p>
</p><p>В оставшейся части этой главы описаны синтаксис Scheme и соглашение
об именовании и типографские соглашения используемые в этой книге.

</p><p>

</p><h3><a name="g1"></a><a name="./intro:h1"></a>Section 1.1. Синтаксис Scheme<a name="SECTINTROSYNTAX"></a></h3>

<p>
Программы Scheme состоят из ключевых слов, переменных, <a name="./intro:s29"></a>структурных форм,
постоянных данных (чисел, букв, строк, квотированных векторов, квотированных списков, квотированных символов,
и т.д.), пробелов и коментариев.

</p><p>
Ключевые слова, переменные и символы называются
<a name="./intro:s30"></a>идентификаторами.
Идентификаторы могут быть сформированы из букв, цифр и специальных значков,
включая <tt>?</tt>, <tt>!</tt>, <tt>.</tt>, <tt>+</tt>,
<tt>-</tt>, <tt>*</tt>, <tt>/</tt>, <tt>&lt;</tt>, <tt>=</tt>, <tt>&gt;</tt>,
<tt>:</tt>, <tt>$</tt>, <tt>%</tt>, <tt>^</tt>, <tt>&amp;</tt>, <tt>_</tt>,
<tt>~</tt>, and <tt>@</tt>, а также набора дополнительных знаков Unicode.
Идентификаторы не могут начинаться со знака&nbsp;(&nbsp;<tt>@</tt>&nbsp;) и
обычно не могут начинаться с любого знака который может начинать число, 
то есть цифры, знака плюс&nbsp;(&nbsp;<tt>+</tt>&nbsp;), знака минус&nbsp;(&nbsp;<tt>-</tt>&nbsp;), или
десятичной точки&nbsp;(&nbsp;<tt>.</tt>&nbsp;).
Исключениямии являются &nbsp;<tt>+</tt>,&nbsp;<tt>-</tt>, и&nbsp;<tt>...</tt>, которые являются действительными идентификаторами и любым идентификатором, начинающимся с <tt>-&gt;</tt>.
Например, <tt>hi</tt>, <tt>Hello</tt>, <tt>n</tt>, <tt>x</tt>, <tt>x3</tt>, <tt>x+2</tt>, и <tt>?$&amp;*!!!</tt> 
вся идентификаторы.
Идентификаторы разделяются пробелами, коментариями, круглыми скобками, квадратными скобками, строковыми кавычками
(двойными)&nbsp;(&nbsp;<tt>"</tt>&nbsp;), и хеш-метками(&nbsp;<tt>#</tt>&nbsp;).
Разделитель или любой другой знак Unicode может быть включен в любом месте имени
идентификатора в виде escape-формы <tt>\x<i>sv</i>;</tt>,
где <tt><i>sv</i></tt> это скалярное значение буквы(знака) в шестнадцатеричной системе счисления.

</p><p>
Нет ограничений на длину идентификатора Scheme;
программисты могут использовать столько символов, сколько необходимо.
Однако длинные идентификаторы не заменяют комментарии, и частое
использование длинных идентификаторов может затруднить форматирование
программы и, следовательно, ее трудно прочитать. 
Хорошим правилом является использование коротких идентификаторов, когда охват
идентификатора является небольшим, и более длинных идентификаторов, когда
область действия больше.

</p><p>
Идентификаторы могут быть записаны в любом сочетании букв верхнего и нижнего
регистров, и регистр важен, т.е два идентификатора отличаются друг от друга,
если регстр их букв различен.
Например, <tt>abcde</tt>, <tt>Abcde</tt>, <tt>AbCdE</tt>, и <tt>ABCDE</tt>
относятся к различным идентификаторам.
Это изменение из предыдущей версии Revised Report.

</p><p>
Структурные формы и <a name="./intro:s31"></a>константные списки заключаются в круглы
скобки, например, <tt>(a&nbsp;b&nbsp;c)</tt> or <tt>(*&nbsp;(-&nbsp;x&nbsp;2)&nbsp;y)</tt>.
<a name="./intro:s32"></a>пустой список записывается как <a name="./intro:s33"></a><tt>()</tt>.
<a name="./intro:s34"></a>Сгласованный набор скобок
(&nbsp;<tt>[</tt>&nbsp;<tt>]</tt>&nbsp;) может использоваться вместо круглых скобок и часто
используется для выделения подвыражений определенных стандартных синтаксических форм для
удобочитаемости, как показано в примерах этой книги. Векторы записываются аналогично
спискам, за исключением того, что им предшествует <tt>#(</tt> и завершается <tt>)</tt>, например,
<tt>#(this&nbsp;is&nbsp;a&nbsp;vector&nbsp;of&nbsp;symbols)</tt>.
Байт-вектор записывается как последовательность беззнаковых байтов( целые числа в 
диапазоне от 0 до 255) заключенные в скобки <tt>#vu8(</tt> и
<tt>)</tt>, например, <tt>#vu8(3&nbsp;250&nbsp;45&nbsp;73)</tt>.

</p><p>
Строки заключаются в двойные кавычки, например,
<tt>"I&nbsp;am&nbsp;a&nbsp;string"</tt>.
Буквам предшествует <tt>#\</tt>, например <tt>#\a</tt>.
Регистр важен в буквенных и строковых константах, как и в нутри
идентификаторов.
Числа могут быть записаны в виде целых чисел, например, -123, в виде отношений, пример, 1/2,
с плавающей точкой или научной нотации,
пример, 1.3 или 1e23, или как комплексные числа в прямугольной или полярной нотации
пример, 1.3-2.7i or -1.2@73.
Регистр не важен в синтаксисе чисел.
<a name="./intro:s35"></a>Логические значения представляются <a name="./intro:s36"></a><i>true</i>
и <a name="./intro:s37"></a><i>false</i>
записываются как <a name="./intro:s38"></a><tt>#t</tt> и <a name="./intro:s39"></a><tt>#f</tt>.
Условные выражения Scheme фактически рассматривают <tt>#f</tt> как ложь и все остальные объекты
как истину, поэтому <tt>3</tt>, <tt>0</tt>, <tt>()</tt>, <tt>"false"</tt>, и <tt>nil</tt> все рассматриваются
как истина.

</p><p>
Подробности синтаксиса для каждого типа константных данных приведены в
отдельных разделах Главы&nbsp;<a href="objects.html#g106">6</a> и в формальном синтаксисе
Scheme начиная со страницы&nbsp;<a href="grammar.html#APPENDIXFORMALSYNTAX">455</a>.

</p><p>
Scheme <a name="./intro:s40"></a>выражения могут охватывать несколько строк, и явный
терминатор не требуется.
Так как количество <a name="./intro:s41"></a>пробельных знаков (пробелов и новых строк)
между выражениями не велико, программы Scheme должны иметь отступ, чтобы отображать
структуру кода, таким образом, чтобы делать код как можно больше удобочитаемым.
<a name="./intro:s42"></a>Комментарии могут появляться в любой строке программы Scheme,
между <a name="./intro:s43"></a><a name="./intro:s44"></a>точкой с запятой (&nbsp;<tt>;</tt>&nbsp;)
и концом строки.
Комментарии, объясняющие конкретное выражение схемы, обычно помещаются на том же уровне
отступов, что и выражение, в строке перед выражением.
Комменарии, объясняющие процедуру или группу процедур, обычно помещаются перед
процедурами без отступов.
Несколько знаков комментария часто используются что бы задать окончательный вид
комментария, например, <tt>;;;&nbsp;The&nbsp;following&nbsp;procedures&nbsp;...</tt>.

</p><p>
Поддерживаются две другие формы комментариев: блок комментариев и комментарии данные.
Блок комментариев ограничивается парой <tt>#|</tt> и <tt>|#</tt>, и может быть
вложенным.
Комментарии данных состоит из префикса <tt>#;</tt> и базовой формы данных(datum)(печатаемое представление данных) следующих за ним.
Комментарии данные обычно используется для комментирования отдельных определений и выражений.
Например, <tt>(three&nbsp;#;(not&nbsp;four)&nbsp;element&nbsp;list)</tt> это то что он говорит.
Комментарии данных также могут быть вложенными, хотя <tt>#;#;(a)(b)</tt> имеет несколько
неочевидный эффект комментирования как <tt>(a)</tt> и
<tt>(b)</tt>.

</p><p>
Некоторые значения Scheme, такие как процедуры и порты, не имеют стандартных печатных
представлений и таким образом, никогда не моугт отображаться как константы в 
печатном синтаксисе программы.
В этой книге используется обозначение <tt>#&lt;<i>description</i>&gt;</tt> при отображении
вывода операции, которая возрвращает такое значение, например,
<tt>#&lt;procedure&gt;</tt> or <tt>#&lt;port&gt;</tt>.

</p><p>

</p><h3><a name="g2"></a><a name="./intro:h2"></a>Section 1.2. Соглашение об Именах Scheme<a name="SECTINTRONAMING"></a></h3>

<p>
Соглашениие об именах<a name="./intro:s45"></a> Scheme разработано для обеспечания
высокой степени единообразия.
Ниже приведен список этих соглашений об именах:

</p><p>
</p><ul>
<li>Имена предикатов заканчиваюся
<a name="./intro:s46"></a><a name="./intro:s47"></a>знаком вопроса (&nbsp;<tt>?</tt>&nbsp;).
Предикаты это процедуры, которые возвращают ответ true или false, такой как
<tt>eq?</tt>, <tt>zero?</tt>, и <tt>string=?</tt>.
Общие операции сравнения чисел <tt>=</tt>, <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>&lt;=</tt>,
и <tt>&gt;=</tt> являются исклюением из этого соглашения об именах.

<p>
</p></li><li>Предикаты <a name="./intro:s48"></a>проверки типа, такие как <tt>pair?</tt>, создаются из
имени типа, в данном случае <tt>pair</tt>, и знака вопроса.

<p>
</p></li><li>Имена большинства буквенных, строковых и векторных процедур
начинаются с префиксов <tt>char-</tt>, <tt>string-</tt>, и
<tt>vector-</tt>, например, <tt>string-append</tt>.
(Имена некоторых процедур list тоже начинаются с <tt>list-</tt>, но большинство
нет.)

<p>
</p></li><li>Имена процедур которые преобразуют объект одного типа в
объект другого типа, записываются как
<a name="./intro:s49"></a><tt><i>type<sub>1</sub></i>-&gt;<i>type<sub>2</sub></i></tt>,
например, <tt>vector-&gt;list</tt>.

<p>
</p></li><li>Имена процедур и синтаксических форм, которые
вызывают побочные эффекты, заканчиваются
<a name="./intro:s50"></a><a name="./intro:s51"></a>восклицательным знаком (&nbsp;<tt>!</tt>&nbsp;).
К ним относятся <tt>set!</tt> и <tt>vector-set!</tt>.
Процедуры, которые выполняют ввод и вывод, технически вызывают<a name="./intro:s52"></a> побочные эффеты, но их
имена являются исключениями из этого правила.
</li></ul>
<p>

</p><p>
Программисты должны использовать эти же соглашения в своем собственном коде,
когда это возможно.

</p><p>

</p><h3><a name="g3"></a><a name="./intro:h3"></a>Section 1.3. Типографические и нотационные соглашения<a name="SECTINTRONOTATION"></a></h3>

<p>
A standard procedure or syntactic form whose sole purpose is to perform
some side effect is said to return <a name="./intro:s53"></a><i>unspecified</i>.
This means that an implementation is free to return any number of
values, each of which can be any Scheme object,
as the value of the procedure or syntactic form.
Do not count on these values being the same across implementations, the
same across versions of the same implementation, or even the same across
two uses of the procedure or syntactic form.
Some Scheme systems routinely use a special object to represent
unspecified values.
Printing of this object is often suppressed by interactive Scheme
systems, so that the values of expressions returning unspecified values 
are not printed.

</p><p>
<a name="./intro:s54"></a>While most standard procedures return a single value, the language
supports procedures that return zero, one, more than one, or even a
variable number of values via the mechanisms described in
Section&nbsp;<a href="control.html#g104">5.8</a>.
Some standard expressions can evaluate to multiple values if one of their
subexpressions evaluates to multiple values, e.g., by calling a procedure
that returns multiple values.
When this situation can occur, an expression is said to return "the
values" rather than simply "the value" of its subexpression.
Similarly, a standard procedure that returns the values resulting from a
call to a procedure argument is said to return the values returned by the
procedure argument.

</p><p>
<a name="./intro:s55"></a>This book uses the words "must" and "should" to
describe program requirements, such as the requirement to provide an index
that is less than the length of the vector in a call to
<tt>vector-ref</tt>.
If the word "must" is used, it means that the requirement is enforced
by the implementation, i.e., an exception is raised, usually with
condition type <tt>&amp;assertion</tt>.
If the word "should" is used, an exception may or may not be raised,
and if not, the behavior of the program is undefined.

</p><p>
<a name="./intro:s56"></a>The phrase "syntax violation" is used to
describe a situation in which a program is malformed.
Syntax violations are detected prior to program execution.
When a syntax violation is detected, an exception of type <tt>&amp;syntax</tt>
is raised and the program is not executed.

</p><p>
The typographical conventions used in this book are straightforward.
All Scheme objects are printed in a <tt>typewriter</tt> typeface, just as they
are to be typed at the keyboard.
This includes syntactic keywords, variables, constant
objects, Scheme expressions, and example programs.
An <i>italic</i> typeface is used to set off syntax variables in
the descriptions of syntactic forms and arguments in the descriptions of
procedures.
Italics are also used to set off technical terms the first time they
appear.
In general, names of syntactic forms and procedures are never
capitalized, even at the beginning of a sentence.
The same is true for syntax variables written in italics.

</p><p>
In the description of a syntactic form or procedure, one or more prototype
patterns show the syntactic form or forms or the correct number or numbers
of arguments for an application of the procedure.
The keyword or procedure name is given in typewriter font,
as are parentheses.
The remaining pieces of the syntax or arguments are shown in italics,
using a name that implies the type of expression or argument expected
by the syntactic form or procedure.
Ellipses are used to specify
zero or more occurrences of a subexpression or argument.
For example, <tt>(or&nbsp;<i>expr</i>&nbsp;...)</tt> describes the <tt>or</tt>
syntactic form, which has zero or more subexpressions, and
<tt>(member&nbsp;<i>obj</i>&nbsp;<i>list</i>)</tt> describes the <tt>member</tt>
procedure, which expects two arguments, an object and a list.

</p><p>
A syntax violation occurs if the structure of a syntactic form does
not match its prototype.
Similarly, an exception with condition type <tt>&amp;assertion</tt> is raised
if the number of arguments passed to a standard procedure does not match
what it is specified to receive.
An exception with condition type <tt>&amp;assertion</tt> is also raised if a
standard procedure receives an argument whose type is not the
type implied by its name or does not meet other criteria given in
the description of the procedure.
For example, the prototype for <tt>vector-set!</tt> is

</p><p>

</p><p><tt>(vector-set!&nbsp;<i>vector</i>&nbsp;<i>n</i>&nbsp;<i>obj</i>)</tt>
</p><p>and the description says that
<tt><i>n</i></tt> must be an exact nonnegative integer strictly less than
the length of <tt><i>vector</i></tt>.
Thus, <tt>vector-set!</tt> must receive three arguments, the first
of which must be a vector, the second of which must be an exact nonnegative
integer less than the length of the vector, and the third of which may
be any Scheme value.
Otherwise, an exception with condition type <tt>&amp;assertion</tt> is
raised.

</p><p>
In most cases, the type of argument required is obvious, as with
<tt><i>vector</i></tt>, <tt><i>obj</i></tt>, or <tt><i>binary-input-port</i></tt>.
In others, primarily within the descriptions of numeric routines,
abbreviations are used, such as <tt><i>int</i></tt> for integer, <tt><i>exint</i></tt>
for exact integer, and <tt><i>fx</i></tt> for fixnum.
These abbreviations are explained at the start of the sections
containing the affected entries.

</p><hr class="copyright" align="left">
<p>
R. Kent Dybvig / <it>The Scheme Programming Language, Fourth Edition</it><br>
Copyright © 2009 <a class="plain" href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&amp;tid=11984">The MIT Press</a>.  Electronically reproduced by permission.<br>
Illustrations © 2009 <a class="plain" href="http://hebert.kitp.ucsb.edu/">Jean-Pierre Hébert</a><br>
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93<br>
<a class="plain" href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&amp;tid=11984">to order this book</a> / <a class="plain" href="canned/about.html">about this book</a>
</p>
<p><a class="plain" href="http://www.scheme.com/">http://www.scheme.com</a></p>

</body></html>