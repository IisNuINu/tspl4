#
# NuINu <don't@send.my>, 2018.
#
#. extracted from syntax.html
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-07-24 12:28+0300\n"
"PO-Revision-Date: 2018-10-24 11:29+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: syntax.html:10
msgid ""
"<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://"
"www.w3.org/TR/html4/loose.dtd\">\n"
"<!-- saved from url=(0048)syntax.html#./syntax:h0 -->\n"
"<html><head><meta http-equiv=\"Content-Type\" content=\"text/html; "
"charset=windows-1252\">\n"
"<title>Syntactic Extension</title>\n"
"<link href=\"./syntax_files/tspl.css\" rel=\"stylesheet\" type=\"text/css"
"\">\n"
"</head>\n"
"<body>\n"
"<a name=\"g133\"></a>\n"
"<a name=\"./syntax:h0\"></a>"
msgstr ""
"<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://"
"www.w3.org/TR/html4/loose.dtd\">\n"
"<!-- saved from url=(0048)syntax.html#./syntax:h0 -->\n"
"<html><head><meta http-equiv=\"Content-Type\" content=\"text/html; "
"charset=utf8\">\n"
"<title>Синтаксические Расширения</title>\n"
"<link href=\"./syntax_files/tspl.css\" rel=\"stylesheet\" type=\"text/css"
"\">\n"
"</head>\n"
"<body>\n"
"<a name=\"g133\"></a>\n"
"<a name=\"./syntax:h0\"></a>"

#: syntax.html:15
msgid ""
"<div style=\"font-size: 12px; width: 500px; height: 500px; border: solid thin"
"\">\n"
"<img style=\"padding: 20px 10px 20px 20px\" src=\"./syntax_files/ch8.png"
"\"><img src=\"./syntax_files/jph.png\">\n"
"</div>\n"
"<h1>Chapter 8. Syntactic Extension<a name=\"CHPTSYNTAX\"></a></h1>"
msgstr ""
"<div>\n"
"<img  src=\"./syntax_files/ch8.png\">\n"
"</div>\n"
"<h1>Chapter 8. Синтаксические Расширения<a name=\"CHPTSYNTAX\"></a></h1>"

#: syntax.html:26
msgid ""
"<p>\n"
"<a name=\"./syntax:s0\"></a><a name=\"./syntax:s1\"></a><i>Syntactic "
"extensions</i>,\n"
"or <a name=\"./syntax:s2\"></a><i>macros</i>, are used to simplify and "
"regularize\n"
"repeated patterns in a program, to introduce syntactic forms with\n"
"new evaluation rules, and to perform transformations that help make\n"
"programs more efficient."
msgstr ""
"<p>\n"
"<a name=\"./syntax:s0\"></a><a name=\"./syntax:s1\"></a><i>Синтаксические "
"расширения</i>,\n"
"или <a name=\"./syntax:s2\"></a><i>Макросы</i>, используются для упрощения и "
"регуляризации\n"
"повторяющихся шаблонов в программе, внедряют синтаксические формы с новыми\n"
"правилами вычисления, и выполняющими преобразования, помогающие сделать "
"программы\n"
"более эффективными."

#: syntax.html:36
msgid ""
"</p><p>\n"
"A syntactic extension most often takes the form\n"
"<tt>(<i>keyword</i>&nbsp;<i>subform</i>&nbsp;...)</tt>,\n"
"where <tt><i>keyword</i></tt> is the identifier that names the syntactic\n"
"extension.\n"
"The syntax of each <tt><i>subform</i></tt> varies from one syntactic\n"
"extension to another.\n"
"Syntactic extensions can also take the form of improper lists\n"
"or even singleton identifiers."
msgstr ""
"</p><p>\n"
"Синтаксическое расширение чаще всего принимает форму\n"
"<tt>(<i>keyword</i>&nbsp;<i>subform</i>&nbsp;...)</tt>,\n"
"где ключевое словое- <tt><i>keyword</i></tt> это идентификатор, т.е. имя\n"
"синтаксического расширения.\n"
"Синтаксис каждой подформы <tt><i>subform</i></tt> варьируется(изменяется) "
"от\n"
"одного синтаксического расширения к другому.\n"
"Синтаксические расширения также могут принимать форму неправильных списков "
"или\n"
"даже одноэлементных идентификаторов."

#: syntax.html:61
msgid ""
"</p><p>\n"
"New syntactic extensions are defined by associating keywords with\n"
"transformation procedures, or <i>transformers</i>.\n"
"Syntactic extensions are defined using\n"
"<a name=\"./syntax:s3\"></a><tt>define-syntax</tt> forms or\n"
"using\n"
"<a name=\"./syntax:s4\"></a><tt>let-syntax</tt> or\n"
"<a name=\"./syntax:s5\"></a><tt>letrec-syntax</tt>.\n"
"Transformers may be created using\n"
"<a name=\"./syntax:s6\"></a><tt>syntax-rules</tt>, which\n"
"allows simple pattern-based transformations to be performed.\n"
"They may also be ordinary procedures that accept one argument and\n"
"perform arbitrary computations.\n"
"In this case, <a name=\"./syntax:s7\"></a><tt>syntax-case</tt> is normally "
"used\n"
"to destructure the input and\n"
"<a name=\"./syntax:s8\"></a><tt>syntax</tt> is normally\n"
"used to construct the output.\n"
"The <a name=\"./syntax:s9\"></a><tt>identifier-syntax</tt>\n"
"form and\n"
"<a name=\"./syntax:s10\"></a><tt>make-variable-transformer</tt>\n"
"procedure allow the creation of transformers that match singleton\n"
"identifiers and assignments to those identifiers, the former being\n"
"restricted to simple patterns like <tt>syntax-rules</tt> and the\n"
"latter allowing arbitrary computations to be performed."
msgstr ""
"</p><p>\n"
"Новые синтаксические расширения определяются путем связывания ключевых\n"
"слов с процедурами преобразования, или преобрзователями - <i>transformers</"
"i>.\n"
"Синтаксические расширения определяются с использованием форм\n"
"<a name=\"./syntax:s3\"></a><tt>define-syntax</tt> или\n"
"использованием\n"
"<a name=\"./syntax:s4\"></a><tt>let-syntax</tt> или\n"
"<a name=\"./syntax:s5\"></a><tt>letrec-syntax</tt>.\n"
"Преобразователи(Transformers) могут быть созданы использованием\n"
"<a name=\"./syntax:s6\"></a><tt>syntax-rules</tt>, которые\n"
"позволяют выполнять простые преобразования на основе образцов.\n"
"Они так же могут быть обычными процедурами, которые принимают один \n"
"аргумент и выполняют произвольные вычисления.\n"
"В этом случае, <a name=\"./syntax:s7\"></a><tt>syntax-case</tt> обчно "
"используется\n"
"для разбора ввода, а  <a name=\"./syntax:s8\"></a><tt>syntax</tt> обычно "
"используется\n"
"для формирования вывода.\n"
"Форма <a name=\"./syntax:s9\"></a><tt>identifier-syntax</tt>\n"
"и процедура\n"
"<a name=\"./syntax:s10\"></a><tt>make-variable-transformer</tt>\n"
"позволяют создавать преобразователи, которые соответствуют\n"
"идентификаторам одиночных элементов и присваивать этим идентификаторам,\n"
"причем первый из них ограничивается просытыми шаблонами, такими как\n"
" <tt>syntax-rules</tt>, а второй позволяет выполнять\n"
"произвольные вычисления."

#: syntax.html:73
msgid ""
"</p><p>\n"
"Syntactic extensions are expanded into core forms at the start of\n"
"evaluation (before compilation or interpretation) by a syntax <i>expander</"
"i>.\n"
"If the expander encounters a syntactic extension, it invokes\n"
"the associated transformer to expand the syntactic extension, then\n"
"repeats the expansion process for the form returned by the transformer.\n"
"If the expander encounters a core syntactic form, it recursively\n"
"processes the subforms, if any, and reconstructs the form from the\n"
"expanded subforms.\n"
"Information about identifier bindings is maintained during expansion\n"
"to enforce lexical scoping for variables and keywords."
msgstr ""
"</p><p>\n"
"Синтаксические расширения разворачиваются в основные формы в начале\n"
"вычисления(перед компиляцией и интерпретацией) с помощью "
"расширителя(<i>expander</i>) синтаксиса.\n"
"Если расширитель синтаксиса сталкивается с синтаксическим расширением, он "
"вызывает\n"
"связанный с синтаксическим расширением преобразователь, а затем повторяет "
"процесс\n"
"расширения для формы возвращенной преобразователем.\n"
"Если расширитель синтаксиса сталкивается с базовой синтаксической формой,\n"
"он рекурсивно обрабатывает подформы, если они есть, и "
"пересоздает(реконструерует)\n"
"форму из расширеных подформ.\n"
"Информция о связанных идентификаторах поддерживается во время расширения "
"для\n"
"обеспечения лексического охвата для переменных и ключевых слов."

#: syntax.html:86
msgid ""
"</p><p>\n"
"The syntactic extension mechanisms described in this chapter are part of\n"
"the \"syntax-case\" system.\n"
"A portable implementation of the system that also supports libraries\n"
"and top-level programs is available at\n"
"<a href=\"http://www.cs.indiana.edu/syntax-case/\">http://www.cs.indiana.edu/"
"syntax-case/</a>.\n"
"A description of the motivations behind and implementation of the\n"
"system can be found in the article\n"
"\"Syntactic Abstraction in Scheme\"&nbsp;[<a class=\"citation\" href="
"\"bibliography.html#g230\">12</a>].\n"
"Additional features that have not yet been standardized, including\n"
"<tt>modules</tt>, local <tt>import</tt>, and meta definitions, are\n"
"described in the <i>Chez Scheme User's Guide</i>&nbsp;[<a class=\"citation\" "
"href=\"bibliography.html#g227\">9</a>]."
msgstr ""
"</p><p>\n"
"Механизмы синтаксического расширения, описанные в этой главе, являются\n"
"частью системы \"syntax-case\".\n"
"Переносимая реализация системы, которая также поддерживает\n"
"библиотеки и программы верхнего уровня, доступна по адресу\n"
"<a href=\"http://www.cs.indiana.edu/syntax-case/\">http://www.cs.indiana.edu/"
"syntax-case/</a>.\n"
"Описание причин ее создания и внедрение системы можно найти в статье\n"
"\"Syntactic Abstraction in Scheme\"&nbsp;[<a class=\"citation\" href="
"\"bibliography.html#g230\">12</a>].\n"
"Дополнительные фунции, которые еще не были стандартизированы, включая "
"модули\n"
"<tt>modules</tt>, локльный импорт (local <tt>import</tt>), и мета-"
"определения, \n"
"описаны  в \n"
"<i>Chez Scheme User's Guide</i>&nbsp;[<a class=\"citation\" href="
"\"bibliography.html#g227\">9</a>]."

#: syntax.html:88
msgctxt "syntax.html:88"
msgid "</p><p>"
msgstr ""

#: syntax.html:90
msgid ""
"</p><h3><a name=\"g134\"></a><a name=\"./syntax:h1\"></a>Section 8.1. "
"Keyword Bindings<a name=\"SECTSYNTAXDEFINITIONS\"></a></h3>"
msgstr ""
"</p><h3><a name=\"g134\"></a><a name=\"./syntax:h1\"></a>Section 8.1. "
"Связывание Ключевых Слов<a name=\"SECTSYNTAXDEFINITIONS\"></a></h3>"

#: syntax.html:100
msgid ""
"<p>\n"
"This section describes forms that establish\n"
"bindings between <a name=\"./syntax:s11\"></a>keywords and transformers.\n"
"Keyword bindings may be established within a top-level program\n"
"or library body using <tt>define-syntax</tt> and in any local\n"
"scope using <tt>define-syntax</tt>, <tt>let-syntax</tt>, or\n"
"<tt>letrec-syntax</tt>."
msgstr ""
"<p>\n"
"В этом разделе описываются формы, которые\n"
"устанавливают привязки между <a name=\"./syntax:s11\"></a>ключевыми словаи и "
"преобразователями.\n"
"Связывание ключевых слов может быть установлено на верхнем уровне программы\n"
"или тела библиотеки с использованием  <tt>define-syntax</tt> и в любой\n"
"локальной области использованием <tt>define-syntax</tt>, <tt>let-syntax</"
"tt>, или\n"
"<tt>letrec-syntax</tt>."

#: syntax.html:105
msgid ""
"</p><p>\n"
"<a name=\"./syntax:s12\"></a><span class=\"formdef\"><b>syntax</b>: "
"<tt>(define-syntax&nbsp;<i>keyword</i>&nbsp;<i>expr</i>)</tt></span>\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>"
msgstr ""

#: syntax.html:107
msgid "</p><p><tt><i>expr</i></tt> must evaluate to a transformer."
msgstr "</p><p><tt><i>expr</i></tt> должен вычисляться преобразователем."

#: syntax.html:111
msgid ""
"</p><p>\n"
"The following example defines <tt>let*</tt> as a syntactic extension,\n"
"specifying the transformer with <tt>syntax-rules</tt> (see Section&nbsp;<a "
"href=\"syntax.html#g135\">8.2</a>)."
msgstr ""
"</p><p>\n"
"Следующий пример определяет <tt>let*</tt> как синтаксическое расширение,\n"
"задающее преобразователь с <tt>syntax-rules</tt> (см. Раздел&nbsp;<a href="
"\"syntax.html#g135\">8.2</a>)."

#: syntax.html:113
msgctxt "syntax.html:113"
msgid "</p><p>"
msgstr ""

#: syntax.html:115
msgid "</p><p><tt>(define-syntax&nbsp;let*<br>"
msgstr ""

#: syntax.html:117
msgctxt "syntax.html:117"
msgid "&nbsp;&nbsp;(syntax-rules&nbsp;()<br>"
msgstr ""

#: syntax.html:119
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;()&nbsp;b1&nbsp;b2&nbsp;...)&nbsp;(let&nbsp;"
"()&nbsp;b1&nbsp;b2&nbsp;...)]<br>"
msgstr ""

#: syntax.html:121
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((i1&nbsp;e1)&nbsp;(i2&nbsp;"
"e2)&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)<br>"
msgstr ""

#: syntax.html:123
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([i1&nbsp;e1])<br>"
msgstr ""

#: syntax.html:129
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let*&nbsp;([i2&nbsp;"
"e2]&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...))]))</tt>\n"
"</p><p>All bindings established by a set of internal definitions, whether\n"
"keyword or variable definitions, are visible everywhere within the\n"
"immediately enclosing body, including within the definitions themselves.\n"
"For example, the expression"
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let*&nbsp;([i2&nbsp;"
"e2]&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...))]))</tt>\n"
"</p><p>Все привязки установленные набором внутренних определений, будь то\n"
"определения ключевых слов или переменных, видны повсюду внутри "
"непосредственно\n"
"охватывающего тела, в том числе и внутри самих определений.\n"
"Например, выражение"

#: syntax.html:131
msgctxt "syntax.html:131"
msgid "</p><p>"
msgstr ""

#: syntax.html:133
msgctxt "syntax.html:133"
msgid "</p><p><tt>(let&nbsp;()<br>"
msgstr ""

#: syntax.html:135
msgid "&nbsp;&nbsp;(define&nbsp;even?<br>"
msgstr ""

#: syntax.html:137
msgctxt "syntax.html:137"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:139
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(=&nbsp;x&nbsp;0)&nbsp;(odd?"
"&nbsp;(-&nbsp;x&nbsp;1)))))<br>"
msgstr ""

#: syntax.html:141
msgid "&nbsp;&nbsp;(define-syntax&nbsp;odd?<br>"
msgstr ""

#: syntax.html:143
msgctxt "syntax.html:143"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>"
msgstr ""

#: syntax.html:145
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x)&nbsp;(not&nbsp;(even?&nbsp;"
"x))]))<br>"
msgstr ""

#: syntax.html:148
msgid ""
"&nbsp;&nbsp;(even?&nbsp;10))</tt>\n"
"</p><p>is valid and should evaluate to <tt>#t</tt>."
msgstr ""
"&nbsp;&nbsp;(even?&nbsp;10))</tt>\n"
"</p><p>действительное и должно вычисляться в <tt>#t</tt>."

#: syntax.html:162
msgid ""
"</p><p>\n"
"<a name=\"body-expansion\"></a>The expander processes the initial forms in a "
"<tt>library</tt>, <tt>lambda</tt>, or other\n"
"body from left to right.\n"
"If it encounters a variable definition, it records the fact that the\n"
"defined identifier is a variable but defers expansion of the\n"
"right-hand-side expression until after all of the definitions have\n"
"been processed.\n"
"If it encounters a keyword definition, it expands and evaluates the\n"
"right-hand-side expression and binds the keyword to the resulting\n"
"transformer.\n"
"If it encounters an expression, it fully expands all deferred\n"
"right-hand-side expressions along with the current and remaining\n"
"body expressions."
msgstr ""
"</p><p>\n"
"<a name=\"body-expansion\"></a>Расширитель обрабатывает начальные формы в "
"библиотеке(<tt>library</tt>),\n"
"<tt>lambda</tt>, или другом теле слева на право.\n"
"Если он встречает определение переменной, он записывает тот факт, что\n"
"определенный идентификатор является переменной, но отменяет расширение "
"выражения справа, \n"
"пока не будут обработаны все определения.\n"
"Если он встречает определение ключевого слова, он расширяет и вычисляет "
"правостороннее\n"
"выражение и связывает ключевое слово с полученным преобразователем.\n"
"Если он встречает выражение, он полностью расширяет все отложенные правые "
"выражения\n"
"вместе с текущими и оставшимися выражениями тела."

#: syntax.html:168
msgid ""
"</p><p>\n"
"An implication of the left-to-right processing order is that one\n"
"internal definition can affect whether a subsequent form is also a\n"
"definition.\n"
"For example, the expression"
msgstr ""
"</p><p>\n"
"Примером обработки слева на право является то, что одно внутреннее\n"
"определение может повлиять на то, является ли последующая форма\n"
"также определением. Например, выражение"

#: syntax.html:170
msgctxt "syntax.html:170"
msgid "</p><p>"
msgstr ""

#: syntax.html:172
msgctxt "syntax.html:172"
msgid "</p><p><tt>(let&nbsp;()<br>"
msgstr ""

#: syntax.html:174
msgid "&nbsp;&nbsp;(define-syntax&nbsp;bind-to-zero<br>"
msgstr ""

#: syntax.html:176
msgctxt "syntax.html:176"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>"
msgstr ""

#: syntax.html:178
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;id)&nbsp;(define&nbsp;"
"id&nbsp;0)]))<br>"
msgstr ""

#: syntax.html:180
msgid "&nbsp;&nbsp;(bind-to-zero&nbsp;x)<br>"
msgstr ""

#: syntax.html:185
msgid ""
"&nbsp;&nbsp;x)</tt>\n"
"</p><p>evaluates to <tt>0</tt>, regardless of any binding for\n"
"<tt>bind-to-zero</tt> that might appear outside of the <tt>let</tt>\n"
"expression."
msgstr ""
"&nbsp;&nbsp;x)</tt>\n"
"</p><p>вычисляется до <tt>0</tt>, независимо от привязки для\n"
"<tt>bind-to-zero</tt>, которое может появляться вне выражения <tt>let</tt>\n"
"expression."

#: syntax.html:195
msgid ""
"</p><p>\n"
"<a name=\"./syntax:s13\"></a><span class=\"formdef\"><b>syntax</b>: <tt>(let-"
"syntax&nbsp;((<i>keyword</i>&nbsp;<i>expr</i>)&nbsp;...)&nbsp;<i>form<sub>1</"
"sub></i>&nbsp;<i>form<sub>2</sub></i>&nbsp;...)</tt></span>\n"
"<br>\n"
"<span class=\"formdef\"><b>syntax</b>: <tt>(letrec-syntax&nbsp;((<i>keyword</"
"i>&nbsp;<i>expr</i>)&nbsp;...)&nbsp;<i>form<sub>1</sub></i>&nbsp;"
"<i>form<sub>2</sub></i>&nbsp;...)</tt></span>\n"
"<br>\n"
"<b>returns: </b>see below\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>"
msgstr ""

#: syntax.html:201
msgid ""
"</p><p>Each <tt><i>expr</i></tt> must evaluate to a transformer.\n"
"For <tt>let-syntax</tt> and <tt>letrec-syntax</tt> both, each "
"<tt><i>keyword</i></tt>\n"
"is bound within the\n"
"forms <tt><i>form<sub>1</sub></i>&nbsp;<i>form<sub>2</sub></i>&nbsp;...</"
"tt>.\n"
"For <tt>letrec-syntax</tt> the binding scope also includes each <tt><i>expr</"
"i></tt>."
msgstr ""
"</p><p>Каждое выражение <tt><i>expr</i></tt> должно вычисляться "
"преобразователем.\n"
"Для <tt>let-syntax</tt> и <tt>letrec-syntax</tt>, каждое ключевое слово "
"<tt><i>keyword</i></tt>\n"
"привязывается к формам <tt><i>form<sub>1</sub></i>&nbsp;<i>form<sub>2</sub></"
"i>&nbsp;...</tt>.\n"
"Для <tt>letrec-syntax</tt> область связывания также включает в себя каждое "
"выражение <tt><i>expr</i></tt>."

#: syntax.html:210
msgid ""
"</p><p>\n"
"<a name=\"letsyntaximplicitbegin\"></a>A <tt>let-syntax</tt> or <tt>letrec-"
"syntax</tt> form may expand into one or more\n"
"expressions anywhere expressions are permitted, in which case the\n"
"resulting expressions are treated as if enclosed in a <tt>begin</tt>\n"
"expression.\n"
"It may also expand into zero or more definitions anywhere definitions are "
"permitted,\n"
"in which case the definitions are treated as if they appeared in place\n"
"of the <tt>let-syntax</tt> or <tt>letrec-syntax</tt> form."
msgstr ""
"</p><p>\n"
"<a name=\"letsyntaximplicitbegin\"></a>Форма <tt>let-syntax</tt> или "
"<tt>letrec-syntax</tt> \n"
"может расширяться в одно или несколько выражений, и в этом случае\n"
"полученные выражения обрабатываются так, как если бы они были заключены\n"
"в выражение <tt>begin</tt>.\n"
"Оно может расширяться до нуля или более определений, где допускаются "
"определения,\n"
"и в этом случае определения обрабатываются так, как если бы они\n"
"появились вместо формы <tt>let-syntax</tt> или <tt>letrec-syntax</tt>."

#: syntax.html:214
msgid ""
"</p><p>\n"
"The following example highlights how <tt>let-syntax</tt>\n"
"and <tt>letrec-syntax</tt> differ."
msgstr ""
"</p><p>\n"
"В следующем примере показано, чем отличаются <tt>let-syntax</tt>\n"
"и <tt>letrec-syntax</tt>."

#: syntax.html:216
msgctxt "syntax.html:216"
msgid "</p><p>"
msgstr ""

#: syntax.html:218
msgid ""
"</p><p><tt>(let&nbsp;([f&nbsp;(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;1))])<br>"
msgstr ""

#: syntax.html:220
msgid "&nbsp;&nbsp;(let-syntax&nbsp;([f&nbsp;(syntax-rules&nbsp;()<br>"
msgstr ""

#: syntax.html:222
msgctxt "syntax.html:222"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;"
"x)&nbsp;x])]<br>"
msgstr ""

#: syntax.html:224
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;[g&nbsp;(syntax-rules&nbsp;()<br>"
msgstr ""

#: syntax.html:226
msgctxt "syntax.html:226"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;"
"x)&nbsp;(f&nbsp;x)])])<br>"
msgstr ""

#: syntax.html:231
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;(f&nbsp;1)&nbsp;(g&nbsp;1))))&nbsp;<img "
"src=\"./syntax_files/0.gif\" alt=\"&lt;graphic&gt;\">&nbsp;(1&nbsp;2)\n"
"<br>\n"
"<br>\n"
"(let&nbsp;([f&nbsp;(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;1))])<br>"
msgstr ""

#: syntax.html:233
msgid "&nbsp;&nbsp;(letrec-syntax&nbsp;([f&nbsp;(syntax-rules&nbsp;()<br>"
msgstr ""

#: syntax.html:235
msgctxt "syntax.html:235"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;"
"x)&nbsp;x])]<br>"
msgstr ""

#: syntax.html:237
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[g&nbsp;(syntax-rules&nbsp;()<br>"
msgstr ""

#: syntax.html:239
msgctxt "syntax.html:239"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;"
"x)&nbsp;(f&nbsp;x)])])<br>"
msgstr ""

#: syntax.html:247
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;(f&nbsp;1)&nbsp;(g&nbsp;1))))&nbsp;<img "
"src=\"./syntax_files/0.gif\" alt=\"&lt;graphic&gt;\">&nbsp;(1&nbsp;1)</tt>\n"
"</p><p>The two expressions are identical except that the <tt>let-syntax</tt> "
"form\n"
"in the first expression is a <tt>letrec-syntax</tt> form in the second.\n"
"In the first expression, the <tt>f</tt> occurring in <tt>g</tt> refers to\n"
"the <tt>let</tt>-bound variable <tt>f</tt>, whereas in the second it refers\n"
"to the keyword <tt>f</tt> whose binding is established by the\n"
"<tt>letrec-syntax</tt> form."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;(f&nbsp;1)&nbsp;(g&nbsp;1))))&nbsp;<img "
"src=\"./syntax_files/0.gif\" alt=\"&lt;graphic&gt;\">&nbsp;(1&nbsp;1)</tt>\n"
"</p><p>Два выражения идентичны, за исключением того, что форма <tt>let-"
"syntax</tt>\n"
"в первом выражении, является формой <tt>letrec-syntax</tt> во вотором.\n"
"В первом выражении <tt>f</tt> встречающееся в <tt>g</tt> относиться к\n"
"привязанной  <tt>let</tt> переменной <tt>f</tt>, тогда как во втором оно\n"
"относиться к ключевому слову <tt>f</tt> привязка которого определяется\n"
"формой <tt>letrec-syntax</tt>."

#: syntax.html:250
msgctxt "syntax.html:250"
msgid "</p><p>"
msgstr ""

#: syntax.html:252
msgid ""
"</p><h3><a name=\"g135\"></a><a name=\"./syntax:h2\"></a>Section 8.2. Syntax-"
"Rules Transformers<a name=\"SECTSYNTAXRULES\"></a></h3>"
msgstr ""
"</p><h3><a name=\"g135\"></a><a name=\"./syntax:h2\"></a>Section 8.2. Syntax-"
"Rules Преобразователь<a name=\"SECTSYNTAXRULES\"></a></h3>"

#: syntax.html:264
msgid ""
"<p>\n"
"The <tt>syntax-rules</tt> form described in this\n"
"section permits simple transformers to be specified in a\n"
"convenient manner.\n"
"These transformers may be bound to keywords using the mechanisms\n"
"described in Section&nbsp;<a href=\"syntax.html#g134\">8.1</a>.\n"
"While it is much less expressive than the mechanism described in\n"
"Section&nbsp;<a href=\"syntax.html#g136\">8.3</a>, it is sufficient for "
"defining many common\n"
"syntactic extensions."
msgstr ""
"<p>\n"
"Форма <tt>syntax-rules</tt>, описанная в этом разделе,\n"
"позволяет указать простые преобразователи удобным образом.\n"
"Эти преобразователи могут быть привязаны к ключевым словам,\n"
"используя механизм, описанный в Разделе &nbsp;<a href=\"syntax."
"html#g134\">8.1</a>.\n"
"Хотя он гораздо менее выразителен, чем механизм описанный в Разделе\n"
"&nbsp;<a href=\"syntax.html#g136\">8.3</a>, он достаточен для определения\n"
"множества распространенных синтаксических расширений."

#: syntax.html:271
msgid ""
"</p><p>\n"
"<a name=\"./syntax:s14\"></a><span class=\"formdef\"><b>syntax</b>: "
"<tt>(syntax-rules&nbsp;(<i>literal</i>&nbsp;...)&nbsp;<i>clause</"
"i>&nbsp;...)</tt></span>\n"
"<br>\n"
"<b>returns: </b>a transformer\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>"
msgstr ""
"</p><p>\n"
"<a name=\"./syntax:s14\"></a><span class=\"formdef\"><b>syntax</b>: "
"<tt>(syntax-rules&nbsp;(<i>literal</i>&nbsp;...)&nbsp;<i>clause</"
"i>&nbsp;...)</tt></span>\n"
"<br>\n"
"<b>returns: </b>преобразователь\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>"

#: syntax.html:275
msgid ""
"</p><p>Each <a name=\"./syntax:s15\"></a><tt><i>literal</i></tt> must be an "
"identifier other than\n"
"an underscore (&nbsp;<tt>_</tt>&nbsp;) or ellipsis (&nbsp;<tt>...</"
"tt>&nbsp;).\n"
"Each clause must take the form below."
msgstr ""
"</p><p>Каждый <a name=\"./syntax:s15\"></a><tt><i>literal</i></tt> должен "
"быть идентификатором,\n"
"отличным от символа подчеркивания (&nbsp;<tt>_</tt>&nbsp;) или многоточия "
"(&nbsp;<tt>...</tt>&nbsp;).\n"
"Каждое предложение должно иметь указанную ниже форму."

#: syntax.html:277
msgctxt "syntax.html:277"
msgid "</p><p>"
msgstr ""

#: syntax.html:282
msgid ""
"</p><p><tt>(<i>pattern</i>&nbsp;<i>template</i>)</tt>\n"
"</p><p>Each <tt><i>pattern</i></tt> specifies one possible syntax that the "
"input\n"
"form might take, and the corresponding <tt><i>template</i></tt> specifies\n"
"how the output should appear."
msgstr ""
"</p><p><tt>(<i>pattern</i>&nbsp;<i>template</i>)</tt>\n"
"</p><p>Каждый образец <tt><i>pattern</i></tt> определяет один из возможных "
"синтаксисов,\n"
"который может принимать входная форма, и каждый  соответствующий шаблон "
"<tt><i>template</i></tt>\n"
"определяет, как должен выглядеть вывод."

#: syntax.html:306
msgid ""
"</p><p>\n"
"<a name=\"./syntax:s16\"></a>Patterns consist of list structure, vector "
"structure,\n"
"identifiers, and\n"
"constants.\n"
"Each identifier within a pattern is either a <tt><i>literal</i></tt>,\n"
"a <a name=\"./syntax:s17\"></a><i>pattern variable</i>,\n"
"an <a name=\"./syntax:s18\"></a><a name=\"./syntax:s19\"></a><i>underscore</"
"i>,\n"
"or an\n"
"<a name=\"./syntax:s20\"></a><a name=\"./syntax:s21\"></a><i>ellipsis</i>.\n"
"The identifier <tt>_</tt> is an underscore, and\n"
"the identifier <tt>...</tt> is an ellipsis.\n"
"Any identifier other than <tt>_</tt> or <tt>...</tt> is a literal if it "
"appears\n"
"in the list of literals\n"
"<tt>(<i>literal</i>&nbsp;...)</tt>;\n"
"otherwise, it is a pattern variable.\n"
"Literals serve as <a name=\"./syntax:s22\"></a>auxiliary keywords, such as "
"<tt>else</tt> in\n"
"<tt>case</tt> and <tt>cond</tt> expressions.\n"
"List and vector structure within a pattern specifies the basic structure\n"
"required of the input, the underscore and pattern variables specify "
"arbitrary\n"
"substructure, and literals and constants specify atomic pieces\n"
"that must match exactly.\n"
"Ellipses specify repeated occurrences of the subpatterns they\n"
"follow."
msgstr ""
"</p><p>\n"
"<a name=\"./syntax:s16\"></a>Образцы состоят из списочной структуры, "
"векторной структуры,\n"
"идентификаторов и констант.\n"
"Каждый идентификатор внутри образца является либо литералом(<tt><i>literal</"
"i></tt>),\n"
"либо переменной образца(<a name=\"./syntax:s17\"></a><i>pattern variable</"
"i>),\n"
"либо <a name=\"./syntax:s18\"></a><a name=\"./syntax:s19\"></a><i> "
"подчеркиванием</i>),\n"
"или <a name=\"./syntax:s20\"></a><a name=\"./syntax:s21\"></"
"a><i>многоточием</i>.\n"
"Идентификтор подчеркивания это знак <tt>_</tt>, а идентификатор\n"
"многоточие это знаки 3 точек <tt>...</tt>.\n"
"Любой идентификатор, отличный от <tt>_</tt> или <tt>...</tt> является "
"литералом, если\n"
"он присутствует в списке литералов <tt>(<i>literal</i>&nbsp;...)</tt>;\n"
"в противном случае, это переменная шаблона(pattern variable).\n"
"Литералы служат <a name=\"./syntax:s22\"></a>вспомогательными ключевыми "
"словами, такими как <tt>else</tt> \n"
"в выражениях <tt>case</tt> и <tt>cond</tt>.\n"
"Список или векторная структура внутри образца задают базовую структуру "
"требуемую от\n"
"входного выражения, знаки подчеркивания и переменные образца(pattern "
"variables) определяют\n"
"произвольную подструктуру, и литералы и константы определяют атомарные "
"кусочки,\n"
"которые должны точно соответствовать(во входной форме образцу).\n"
"Многоточия определяют повторяющиеся вхождения подобразцов, за которыми\n"
"они следуют."

#: syntax.html:309
msgid ""
"</p><p>\n"
"<a name=\"patterns\"></a>An input form <tt><i>F</i></tt> matches a pattern "
"<tt><i>P</i></tt> if and only if"
msgstr ""
"</p><p>\n"
"<a name=\"patterns\"></a>Входная Форма <tt><i>F</i></tt> соответствует "
"образцу <tt><i>P</i></tt> тогда и только\n"
"тогда, когда"

#: syntax.html:313
msgid ""
"</p><p>\n"
"</p><ul>\n"
"<li><tt><i>P</i></tt> is an underscore or pattern variable,"
msgstr ""
"</p><p>\n"
"</p><ul>\n"
"<li><tt><i>P</i></tt> является символом подчеркивания или переменной образца,"

#: syntax.html:320
msgid ""
"<p>\n"
"</p></li><li><tt><i>P</i></tt> is a literal identifier\n"
"and <tt><i>F</i></tt> is an identifier with\n"
"the same binding as determined by the predicate\n"
"<tt>free-identifier=?</tt>\n"
"(Section&nbsp;<a href=\"syntax.html#g136\">8.3</a>),"
msgstr ""
"<p>\n"
"</p></li><li><tt><i>P</i></tt> является литеральным идентификатором,\n"
"а <tt><i>F</i></tt> является идентификатором с тем же связыванием,\n"
"которое определяется предикатом\n"
"<tt>free-identifier=?</tt>\n"
"(Раздел&nbsp;<a href=\"syntax.html#g136\">8.3</a>),"

#: syntax.html:326
msgid ""
"<p>\n"
"</p></li><li><tt><i>P</i></tt> is of the form\n"
"<tt>(<i>P<sub>1</sub></i>&nbsp;...&nbsp;<i>P<sub>n</sub></i>)</tt>\n"
"and <tt><i>F</i></tt> is a list of <i>n</i> elements that match "
"<tt><i>P<sub>1</sub></i></tt> through\n"
"<tt><i>P<sub>n</sub></i></tt>,"
msgstr ""
"<p>\n"
"</p></li><li><tt><i>P</i></tt> имеет вид\n"
"<tt>(<i>P<sub>1</sub></i>&nbsp;...&nbsp;<i>P<sub>n</sub></i>)</tt>,\n"
"а <tt><i>F</i></tt> представляет собой список из  <i>n</i> элементов, "
"которые соответствуют\n"
"<tt><i>P<sub>1</sub></i></tt> до\n"
"<tt><i>P<sub>n</sub></i></tt>,"

#: syntax.html:334
msgid ""
"<p>\n"
"</p></li><li><tt><i>P</i></tt> is of the form\n"
"<tt>(<i>P<sub>1</sub></i>&nbsp;...&nbsp;<i>P<sub>n</sub></i>&nbsp;.&nbsp;"
"<i>P<sub>x</sub></i>)</tt>\n"
"and <tt><i>F</i></tt> is a list or improper list of <i>n</i> or more "
"elements\n"
"whose first <i>n</i> elements match <tt><i>P<sub>1</sub></i></tt> through "
"<tt><i>P<sub>n</sub></i></tt>\n"
"and\n"
"whose <i>n</i>th cdr matches <tt><i>P<sub>x</sub></i></tt>,"
msgstr ""
"<p>\n"
"</p></li><li><tt><i>P</i></tt> имеет вид\n"
"<tt>(<i>P<sub>1</sub></i>&nbsp;...&nbsp;<i>P<sub>n</sub></i>&nbsp;.&nbsp;"
"<i>P<sub>x</sub></i>)</tt>\n"
"и <tt><i>F</i></tt> является списком или неправильным списком <i>n</i> или "
"более элементов\n"
"чьи  первые <i>n</i> элементов соответствуют от <tt><i>P<sub>1</sub></i></"
"tt> до <tt><i>P<sub>n</sub></i></tt>\n"
"и чей <i>n</i>-й cdr соответствует <tt><i>P<sub>x</sub></i></tt>,"

#: syntax.html:344
msgid ""
"<p>\n"
"</p></li><li><tt><i>P</i></tt> is of the form\n"
"<tt>(<i>P<sub>1</sub></i>&nbsp;...&nbsp;<i>P<sub>k</sub></i>&nbsp;"
"<i>P<sub>e</sub></i>&nbsp;<i>ellipsis</i>&nbsp;<i>P<sub><i>m</i>+1</sub></"
"i>&nbsp;...&nbsp;<i>P<sub>n</sub></i>)</tt>,\n"
"where <tt><i>ellipsis</i></tt> is the identifier <tt>...</tt>\n"
"and <tt><i>F</i></tt> is a proper list of <i>n</i>\n"
"elements whose first <i>k</i> elements match <tt><i>P<sub>1</sub></i></tt> "
"through <tt><i>P<sub>k</sub></i></tt>,\n"
"whose next <i>m</i> - <i>k</i> elements each match <tt><i>P<sub>e</sub></i></"
"tt>,\n"
"and\n"
"whose remaining <i>n</i> - <i>m</i> elements match <tt><i>P<sub><i>m</i>+1</"
"sub></i></tt> through <tt><i>P<sub>n</sub></i></tt>,"
msgstr ""
"<p>\n"
"</p></li><li><tt><i>P</i></tt> имеет вид\n"
"<tt>(<i>P<sub>1</sub></i>&nbsp;...&nbsp;<i>P<sub>k</sub></i>&nbsp;"
"<i>P<sub>e</sub></i>&nbsp;<i>ellipsis</i>&nbsp;<i>P<sub><i>m</i>+1</sub></"
"i>&nbsp;...&nbsp;<i>P<sub>n</sub></i>)</tt>,\n"
"где <tt><i>ellipsis</i></tt> является идентификатором <tt>...</tt>\n"
"и <tt><i>F</i></tt> является правильным списком <i>n</i> элментов,\n"
"чьи первые  <i>k</i> элементов соответствуют от <tt><i>P<sub>1</sub></i></"
"tt> до <tt><i>P<sub>k</sub></i></tt>,\n"
"следующие <i>m</i> - <i>k</i> элементов, каждый из которых соответствует "
"<tt><i>P<sub>e</sub></i></tt>,\n"
"а оставшиеся <i>n</i> - <i>m</i> элментов соответствуют от "
"<tt><i>P<sub><i>m</i>+1</sub></i></tt> до <tt><i>P<sub>n</sub></i></tt>,"

#: syntax.html:355
msgid ""
"<p>\n"
"</p></li><li><tt><i>P</i></tt> is of the form\n"
"<tt>(<i>P<sub>1</sub></i>&nbsp;...&nbsp;<i>P<sub>k</sub></i>&nbsp;"
"<i>P<sub>e</sub></i>&nbsp;<i>ellipsis</i>&nbsp;<i>P<sub><i>m</i>+1</sub></"
"i>&nbsp;...&nbsp;<i>P<sub>n</sub></i>&nbsp;.&nbsp;<i>P<sub>x</sub></i>)</"
"tt>,\n"
"where <tt><i>ellipsis</i></tt> is the identifier <tt>...</tt>\n"
"and <tt><i>F</i></tt> is a list or improper list of <i>n</i>\n"
"elements whose first <i>k</i> elements match <tt><i>P<sub>1</sub></i></tt> "
"through <tt><i>P<sub>k</sub></i></tt>,\n"
"whose next <i>m</i> - <i>k</i> elements each match <tt><i>P<sub>e</sub></i></"
"tt>,\n"
"whose next <i>n</i> - <i>m</i> elements match <tt><i>P<sub><i>m</i>+1</sub></"
"i></tt> through <tt><i>P<sub>n</sub></i></tt>,\n"
"and \n"
"whose <i>n</i>th and final cdr matches <tt><i>P<sub>x</sub></i></tt>,"
msgstr ""
"<p>\n"
"</p></li><li><tt><i>P</i></tt> имеет вид\n"
"<tt>(<i>P<sub>1</sub></i>&nbsp;...&nbsp;<i>P<sub>k</sub></i>&nbsp;"
"<i>P<sub>e</sub></i>&nbsp;<i>ellipsis</i>&nbsp;<i>P<sub><i>m</i>+1</sub></"
"i>&nbsp;...&nbsp;<i>P<sub>n</sub></i>&nbsp;.&nbsp;<i>P<sub>x</sub></i>)</"
"tt>,\n"
"где <tt><i>ellipsis</i></tt> является идентификатором <tt>...</tt>\n"
"и <tt><i>F</i></tt> является списком или неправильным списком <i>n</i>\n"
"элементов, чьи первые <i>k</i> элементов соответстувуют от <tt><i>P<sub>1</"
"sub></i></tt> до <tt><i>P<sub>k</sub></i></tt>,\n"
"чьи последующие <i>m</i> - <i>k</i> элементов, каждый совпадает с "
"<tt><i>P<sub>e</sub></i></tt>,\n"
"чьи последующие <i>n</i> - <i>m</i> элементов, совпадают от "
"<tt><i>P<sub><i>m</i>+1</sub></i></tt> до <tt><i>P<sub>n</sub></i></tt>,\n"
"и чей <i>n</i>-й и конечный cdr совпадает с <tt><i>P<sub>x</sub></i></tt>,"

#: syntax.html:361
msgid ""
"<p>\n"
"</p></li><li><tt><i>P</i></tt> is of the form\n"
"<tt>#(<i>P<sub>1</sub></i>&nbsp;...&nbsp;<i>P<sub>n</sub></i>)</tt>\n"
"and <tt><i>F</i></tt> is a vector of <i>n</i> elements that match "
"<tt><i>P<sub>1</sub></i></tt> through\n"
"<tt><i>P<sub>n</sub></i></tt>,"
msgstr ""
"<p>\n"
"</p></li><li><tt><i>P</i></tt> имеет вид\n"
"<tt>#(<i>P<sub>1</sub></i>&nbsp;...&nbsp;<i>P<sub>n</sub></i>)</tt>\n"
"и <tt><i>F</i></tt> является вектором из <i>n</i> элементов которые "
"соответствуют  <tt><i>P<sub>1</sub></i></tt> - <tt><i>P<sub>n</sub></i></tt>,"

#: syntax.html:372
msgid ""
"<p>\n"
"</p></li><li><tt><i>P</i></tt> is of the form\n"
"<tt>#(<i>P<sub>1</sub></i>&nbsp;...&nbsp;<i>P<sub>k</sub></i>&nbsp;"
"<i>P<sub>e</sub></i>&nbsp;<i>ellipsis</i>&nbsp;<i>P<sub><i>m</i>+1</sub></"
"i>&nbsp;...&nbsp;<i>P<sub>n</sub></i>)</tt>,\n"
"where <tt><i>ellipsis</i></tt> is the identifier <tt>...</tt>\n"
"and <tt><i>F</i></tt> is a vector of <i>n</i> or more elements\n"
"whose first <i>k</i> elements match <tt><i>P<sub>1</sub></i></tt> through "
"<tt><i>P<sub>k</sub></i></tt>,\n"
"whose next <i>m</i> - <i>k</i> elements each match <tt><i>P<sub>e</sub></i></"
"tt>,\n"
"and\n"
"whose remaining <i>n</i> - <i>m</i> elements match <tt><i>P<sub><i>m</i>+1</"
"sub></i></tt> through <tt><i>P<sub>n</sub></i></tt>,\n"
"or"
msgstr ""
"<p>\n"
"</p></li><li><tt><i>P</i></tt> имеет вид\n"
"<tt>#(<i>P<sub>1</sub></i>&nbsp;...&nbsp;<i>P<sub>k</sub></i>&nbsp;"
"<i>P<sub>e</sub></i>&nbsp;<i>ellipsis</i>&nbsp;<i>P<sub><i>m</i>+1</sub></"
"i>&nbsp;...&nbsp;<i>P<sub>n</sub></i>)</tt>,\n"
"где <tt><i>ellipsis</i></tt> является идентификатором <tt>...</tt>\n"
"и <tt><i>F</i></tt> является вектором <i>n</i> или более элементов,\n"
"чьи первые <i>k</i> элементов соответствуют <tt><i>P<sub>1</sub></i></tt> - "
"<tt><i>P<sub>k</sub></i></tt>,\n"
"чьи последующие <i>m</i> - <i>k</i> элементов, каждый, соответствуют "
"<tt><i>P<sub>e</sub></i></tt>,\n"
"и чьи оставшиеся <i>n</i> - <i>m</i> элементов совпадают с "
"<tt><i>P<sub><i>m</i>+1</sub></i></tt> - <tt><i>P<sub>n</sub></i></tt>,\n"
"или"

#: syntax.html:379
msgid ""
"<p>\n"
"</p></li><li><tt><i>P</i></tt> is a pattern datum (any nonlist, nonvector, "
"nonsymbol\n"
"object) and <tt><i>F</i></tt> is equal to <tt><i>P</i></tt> in the sense of "
"the\n"
"<tt>equal?</tt> procedure.\n"
"</li></ul>\n"
"<p>"
msgstr ""
"<p>\n"
"</p></li><li><tt><i>P</i></tt> это образец данных (любой не "
"списочный(nonlist), не векторный(nonvector), \n"
"не символьный(nonsymbol) объект) и <tt><i>F</i></tt> равен <tt><i>P</i></tt> "
"в смысле истинности процедуры\n"
"<tt>equal?</tt>.\n"
"</li></ul>\n"
"<p>"

#: syntax.html:389
msgid ""
"</p><p>\n"
"The outermost structure of a <tt>syntax-rules</tt> <tt><i>pattern</i></tt>\n"
"must actually be in one of the list-structured forms above, although\n"
"subpatterns of the pattern may be in any of the above forms.\n"
"Furthermore, the first element of the outermost pattern is ignored,\n"
"since it is always assumed to be the keyword naming the\n"
"syntactic form.\n"
"(These statements do not apply to <tt>syntax-case</tt>; see\n"
"Section&nbsp;<a href=\"syntax.html#g136\">8.3</a>.)"
msgstr ""
"</p><p>\n"
"Самая внешняя структура образца(<tt><i>pattern</i></tt>) в <tt>syntax-rules</"
"tt>\n"
"должна фактически находиться в одной из выше перечисленных списковых-"
"структурных форм,\n"
"хотя подобразцы образца могут быть в любой из вышеперечисленных форм.\n"
"Кроме того, первый элемент самого внешнего образца\n"
"игнорируется, поскольку он вседа считается ключевым словом, именующим\n"
"синтаксическую форму.\n"
"(Эти утверждения не применимы к  <tt>syntax-case</tt>; см.\n"
"Раздел&nbsp;<a href=\"syntax.html#g136\">8.3</a>.)"

#: syntax.html:401
msgid ""
"</p><p>\n"
"If an input form passed to a <tt>syntax-rules</tt> transformer\n"
"matches the pattern for a given clause, the clause\n"
"is accepted and the form is transformed as specified by the\n"
"associated template.\n"
"As this transformation takes place,\n"
"pattern variables appearing in the pattern\n"
"are bound to the corresponding input subforms.\n"
"Pattern variables appearing within a subpattern followed by\n"
"one or more ellipses may be bound to a sequence or sequences of zero or "
"more\n"
"input subforms."
msgstr ""
"</p><p>\n"
"Если введенная форма, переданная преобразователю <tt>syntax-rules</tt> \n"
"соответствует образцу  для данного предложения, предложение\n"
"принимается и форма преобразуется в соответсвии с соответствующим\n"
"шаблоном.\n"
"По мере того, как это преобразование происходит, переменные образца,\n"
"появляющиеся в образце привязываются к соответствующим входным подформам.\n"
"Переменные образца, входящие в подобразец, сопровождаемые одним или\n"
"несколькими многоточиями, могут быть связаны с последовательностью или \n"
"последовательностями нулевой или большей длины входных подформ."

#: syntax.html:412
msgid ""
"</p><p>\n"
"<a name=\"./syntax:s23\"></a>A template is a pattern variable, an identifier "
"that\n"
"is not a pattern\n"
"variable, a pattern datum, a list of subtemplates\n"
"<tt>(<i>S<sub>1</sub></i>&nbsp;...&nbsp;<i>S<sub>n</sub></i>)</tt>, an "
"improper list of subtemplates\n"
"<tt>(<i>S<sub>1</sub></i>&nbsp;<i>S<sub>2</sub></i>&nbsp;...&nbsp;"
"<i>S<sub>n</sub></i>&nbsp;.&nbsp;<i>T</i>)</tt>, or a\n"
"vector of subtemplates <tt>#(<i>S<sub>1</sub></i>&nbsp;...&nbsp;<i>S<sub>n</"
"sub></i>)</tt>.\n"
"Each subtemplate <tt><i>S<sub>i</sub></i></tt> is a template\n"
"followed by zero or more ellipses.\n"
"The final element <tt><i>T</i></tt> of an improper subtemplate list is a "
"template."
msgstr ""
"</p><p>\n"
"<a name=\"./syntax:s23\"></a>Шаблон это переменная образца, идентификатор "
"который\n"
"не является переменной образца, данными образца, списоком подшаблонов\n"
"<tt>(<i>S<sub>1</sub></i>&nbsp;...&nbsp;<i>S<sub>n</sub></i>)</tt>, "
"неправильным списоком подшаблонов\n"
"<tt>(<i>S<sub>1</sub></i>&nbsp;<i>S<sub>2</sub></i>&nbsp;...&nbsp;"
"<i>S<sub>n</sub></i>&nbsp;.&nbsp;<i>T</i>)</tt>, или\n"
"вектором подшаблонов <tt>#(<i>S<sub>1</sub></i>&nbsp;...&nbsp;<i>S<sub>n</"
"sub></i>)</tt>.\n"
"Каждый подшаблон <tt><i>S<sub>i</sub></i></tt> представляет собой шаблон, за "
"которым\n"
"следует ноль или более многоточий.\n"
"Последний элемент <tt><i>T</i></tt> неправильного списка подшаблонов это "
"тоже шаблон."

# Notes:
# Add Note
#: syntax.html:435
msgid ""
"</p><p>\n"
"Pattern variables appearing within a template are replaced in\n"
"the output by the input subforms to which they are bound.\n"
"Pattern data and identifiers that are not pattern variables\n"
"are inserted directly into the output.\n"
"List and vector structure within the template remains list and vector\n"
"structure in the output.\n"
"A subtemplate followed by an ellipsis expands\n"
"into zero or more occurrences of the subtemplate.\n"
"The subtemplate\n"
"must contain at least one pattern variable from a subpattern\n"
"followed by an ellipsis.\n"
"(Otherwise, the expander could not determine how many times the subform\n"
"should be repeated in the output.)\n"
"Pattern variables that occur in subpatterns followed by one or more\n"
"ellipses may occur only in subtemplates that are\n"
"followed by (at least) as many ellipses.\n"
"These pattern variables are replaced in the output by the input\n"
"subforms to which  they are bound, distributed as specified.\n"
"If a pattern variable is followed by more ellipses in the template\n"
"than in the associated pattern, the input form is replicated as\n"
"necessary."
msgstr ""
"</p><p>\n"
"Переменные образца(Pattern variables), входящие в шалон(template), "
"заменяются\n"
"на выходе входными подформами, с которыми они связаны.\n"
"Данные образца и идентификаторы, которые не являются переменными образца\n"
"вставляются непосредственно в выходную форму.\n"
"Список и векторная структура внутри шаблона остаются списком и векторной "
"структурой\n"
"в выходной форме.\n"
"Подшаблон, за которым следует многоточие, расширяется до нуля или более\n"
"подшаблонов.\n"
"Подшаблон должен содержать по крайней мере одну переменную образца из "
"подобразца, за\n"
"которой следует многоточие.\n"
"(В противном случае расширетель не смог бы определить, сколько раз надпись\n"
"должна быть повторена на выходе.)\n"
"Переменные образца которые встречаются в подобразцах, за которыми следует "
"одно\n"
"или более многоточий могут присутствовать только в подшаблонах, за которыми\n"
"следуют(по крайней мере) столько же многоточий.\n"
"Эти переменные образца заменяются в выходной форме входными подформами с "
"которыми\n"
"они связаны, распределяясь как указано.\n"
"Если за переменной образца следует большее количество многоточий, чем в \n"
"соответствующем шаблоне, форма ввода повторяется по мере необходимости.\n"

#: syntax.html:447
msgid ""
"</p><p>\n"
"A template of the form\n"
"<tt>(...&nbsp;<i>template</i>)</tt> is identical to <tt><i>template</i></"
"tt>, except that\n"
"ellipses within the template have no special meaning.\n"
"That is, any ellipses contained within <tt><i>template</i></tt> are\n"
"treated as ordinary identifiers.\n"
"In particular, the template <tt>(...&nbsp;...)</tt> produces a single\n"
"ellipsis, <tt>...</tt>.\n"
"This allows syntactic extensions to expand into forms containing\n"
"ellipses, including <tt>syntax-rules</tt> or <tt>syntax-case</tt>\n"
"patterns and templates."
msgstr ""
"</p><p>\n"
"Форма шаблона\n"
"<tt>(...&nbsp;<i>template</i>)</tt> идентична <tt><i>template</i></tt>, за "
"исключением\n"
"того, что многоточия внутри шаблона не имеют особого значения.\n"
"То есть, многоточия содержащиеся в шаблоне <tt><i>template</i></tt>,\n"
"рассматриваются как обычные идентификаторы.\n"
"В частности, шаблон <tt>(...&nbsp;...)</tt> создает одиночное\n"
"многоточие, <tt>...</tt>.\n"
"Это позволяет синтаксическим расширениям разворачиваться в формы,\n"
"содержащие многоточия, включая образцы и шаблоны в \n"
"<tt>syntax-rules</tt> или <tt>syntax-case</tt>."

#: syntax.html:451
msgid ""
"</p><p>\n"
"</p><p>The definition of <tt>or</tt> below demonstrates the use of\n"
"<tt>syntax-rules</tt>."
msgstr ""
"</p><p>\n"
"</p><p>Определение ниже <tt>or</tt> демонстрирует использование\n"
"<tt>syntax-rules</tt>."

#: syntax.html:453
msgctxt "syntax.html:453"
msgid "</p><p>"
msgstr ""

#: syntax.html:455
msgctxt "syntax.html:455"
msgid "</p><p><tt>(define-syntax&nbsp;or<br>"
msgstr ""

#: syntax.html:457
msgctxt "syntax.html:457"
msgid "&nbsp;&nbsp;(syntax-rules&nbsp;()<br>"
msgstr ""

#: syntax.html:459
msgid "&nbsp;&nbsp;&nbsp;&nbsp;[(_)&nbsp;#f]<br>"
msgstr ""

#: syntax.html:461
msgid "&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e)&nbsp;e]<br>"
msgstr ""

#: syntax.html:463
msgid "&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e1&nbsp;e2&nbsp;e3&nbsp;...)<br>"
msgstr ""

#: syntax.html:480
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([t&nbsp;e1])&nbsp;(if&nbsp;t&nbsp;"
"t&nbsp;(or&nbsp;e2&nbsp;e3&nbsp;...)))]))</tt>\n"
"</p><p>The input patterns specify that the input must consist of the\n"
"keyword and zero or more subexpressions.\n"
"An <a name=\"./syntax:s24\"></a><a name=\"./syntax:s25\"></a>underscore "
"(&nbsp;<tt>_</tt>&nbsp;),\n"
"which is a special pattern symbol that matches any input,\n"
"is often used for the keyword position to remind the programmer\n"
"and anyone reading the definition that the keyword\n"
"position never fails to contain the expected keyword and need not be\n"
"matched.\n"
"(In fact, as mentioned above, <tt>syntax-rules</tt> ignores what appears\n"
"in the keyword position.)\n"
"If more than one subexpression is present (third clause), the\n"
"expanded code both tests the value of the first subexpression\n"
"and returns the value if it is not false.\n"
"To avoid evaluating the expression twice, the transformer\n"
"introduces a binding for the temporary variable&nbsp;<tt>t</tt>."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([t&nbsp;e1])&nbsp;(if&nbsp;t&nbsp;"
"t&nbsp;(or&nbsp;e2&nbsp;e3&nbsp;...)))]))</tt>\n"
"</p><p>Образцы ввода указывают, что ввод должен состоять из ключевого\n"
"слова и нуля или более подвыражений.\n"
"Знак <a name=\"./syntax:s24\"></a><a name=\"./syntax:s25\"></a>подчеркивания "
"(&nbsp;<tt>_</tt>&nbsp;),\n"
"является специальным знаком образца, который соответствует любому входу,\n"
"часто используется для позиции ключевого слова, чтобы напомнить "
"программисту\n"
"и любому, кто читает определение, что позиция ключевого слова никогда\n"
"не перестает содержать ожидаемое ключевое слово и не нуждается в "
"соответствии.\n"
"(Фактически, как указано выше, <tt>syntax-rules</tt> игнорируют то, что\n"
"появляется в  позиции ключевого слова.)\n"
"Если присутствует более одного подвыражения (третье предложение), \n"
"расширенный код проверяет значение первого подвыражения и\n"
"возвращает значение, если оно не является ложным.\n"
"Чтобы избежать повторного вычисления выражения, преобразователь\n"
"вводит привязку для временной переменной &nbsp;<tt>t</tt>."

#: syntax.html:489
msgid ""
"</p><p>\n"
"The expansion algorithm maintains lexical scoping automatically\n"
"by renaming local identifiers as necessary.\n"
"Thus, the binding for <tt>t</tt> introduced by the transformer is visible\n"
"only within code introduced by the transformer and not within\n"
"subforms of the input.\n"
"Similarly, the references to the identifiers <tt>let</tt> and <tt>if</tt> "
"are\n"
"unaffected by any bindings present in the context of the input."
msgstr ""
"</p><p>\n"
"Алгоритм расширения автоматически поддерживает лексический охват(область),\n"
"переименовывая локальные идентификаторы по мере необходимости.\n"
"Таким образом, привязка для <tt>t</tt> введенная преобразователем, видна\n"
"только внутри кода, введенного трансформатором, а не внутри подформ\n"
"ввода.\n"
"Аналогично, ссылки на идентификаторы <tt>let</tt> и <tt>if</tt> не\n"
"затрагиваются никакими привязками, присутствующими во входном контексте."

#: syntax.html:491
msgctxt "syntax.html:491"
msgid "</p><p>"
msgstr ""

#: syntax.html:493
msgid "</p><p><tt>(let&nbsp;([if&nbsp;#f])<br>"
msgstr ""

#: syntax.html:495
msgid "&nbsp;&nbsp;(let&nbsp;([t&nbsp;'okay])<br>"
msgstr ""

#: syntax.html:499
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;if&nbsp;t)))&nbsp;<img src=\"./"
"syntax_files/0.gif\" alt=\"&lt;graphic&gt;\">&nbsp;okay</tt>\n"
"</p><p>This expression is transformed during expansion to the equivalent of\n"
"the expression below."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;if&nbsp;t)))&nbsp;<img src=\"./"
"syntax_files/0.gif\" alt=\"&lt;graphic&gt;\">&nbsp;okay</tt>\n"
"</p><p>Это выражение преобразуется при расширении в эквивалент выражения "
"ниже."

#: syntax.html:501
msgctxt "syntax.html:501"
msgid "</p><p>"
msgstr ""

#: syntax.html:503
msgid "</p><p><tt>((lambda&nbsp;(if1)<br>"
msgstr ""

#: syntax.html:505
msgid "&nbsp;&nbsp;&nbsp;((lambda&nbsp;(t1)<br>"
msgstr ""

#: syntax.html:507
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((lambda&nbsp;(t2)<br>"
msgstr ""

#: syntax.html:509
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;t2&nbsp;"
"t2&nbsp;t1))<br>"
msgstr ""

#: syntax.html:511
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if1))<br>"
msgstr ""

#: syntax.html:513
msgid "&nbsp;&nbsp;&nbsp;&nbsp;'okay))<br>"
msgstr ""

#: syntax.html:519
msgid ""
"&nbsp;#f)&nbsp;<img src=\"./syntax_files/0.gif\" alt=\"&lt;graphic&gt;"
"\">&nbsp;okay</tt>\n"
"</p><p>In this sample expansion, <tt>if1</tt>, <tt>t1</tt>, and <tt>t2</tt>\n"
"represent identifiers to which <tt>if</tt> and <tt>t</tt> in the\n"
"original expression and <tt>t</tt> in the expansion of <tt>or</tt> have\n"
"been renamed."
msgstr ""
"&nbsp;#f)&nbsp;<img src=\"./syntax_files/0.gif\" alt=\"&lt;graphic&gt;"
"\">&nbsp;okay</tt>\n"
"</p><p>В этом примере расширения <tt>if1</tt>, <tt>t1</tt> и <tt>t2</tt>\n"
"представляют собой идентификаторы, в которые переименовываются <tt>if</tt> и "
"<tt>t</tt>\n"
"из исходного выражения при расширении <tt>or</tt>."

#: syntax.html:528
msgid ""
"</p><p>\n"
"The definition of a simplified version of <tt>cond</tt> below\n"
"(simplified because it requires\n"
"at least one output expression per clause and \n"
"does not support the auxiliary keyword <tt>=&gt;</tt>)\n"
"demonstrates how auxiliary keywords such as <tt>else</tt> are recognized\n"
"in the input to a transformer, via inclusion in the list of\n"
"literals."
msgstr ""
"</p><p>\n"
"Определение упрощенной версии <tt>cond</tt> ниже\n"
"(упрощенное, потому что требует по крайней мере одного\n"
"выходного выражения на предложение и не поддерживает\n"
"вспомогательное ключевое слово <tt>=&gt;</tt>)\n"
"демонстрирует, как вспомогательные ключевые слова, такие как <tt>else</tt> "
"распознаются\n"
"во входном выражении преобразователем, посредством включения в список "
"литералов."

#: syntax.html:530
msgctxt "syntax.html:530"
msgid "</p><p>"
msgstr ""

#: syntax.html:532
msgctxt "syntax.html:532"
msgid "</p><p><tt>(define-syntax&nbsp;cond<br>"
msgstr ""

#: syntax.html:534
msgid "&nbsp;&nbsp;(syntax-rules&nbsp;(else)<br>"
msgstr ""

#: syntax.html:536
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(else&nbsp;e1&nbsp;e2&nbsp;...))&nbsp;"
"(begin&nbsp;e1&nbsp;e2&nbsp;...)]<br>"
msgstr ""

#: syntax.html:538
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(e0&nbsp;e1&nbsp;e2&nbsp;...))&nbsp;"
"(if&nbsp;e0&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...))]<br>"
msgstr ""

#: syntax.html:540
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(e0&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;c1&nbsp;"
"c2&nbsp;...)<br>"
msgstr ""

#: syntax.html:547
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;e0&nbsp;(begin&nbsp;e1&nbsp;"
"e2&nbsp;...)&nbsp;(cond&nbsp;c1&nbsp;c2&nbsp;...))]))</tt>\n"
"</p><p><a name=\"./syntax:s26\"></a><span class=\"formdef\"><b>syntax</b>: "
"<tt>_</tt></span>\n"
"<br>\n"
"<span class=\"formdef\"><b>syntax</b>: <tt>...</tt></span>\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs&nbsp;syntax-case)</"
"tt>, <tt>(rnrs)</tt>"
msgstr ""

#: syntax.html:554
msgid ""
"</p><p>These identifiers are auxiliary keywords for <tt>syntax-rules</tt>,\n"
"<tt>identifier-syntax</tt>, and <tt>syntax-case</tt>.\n"
"The second (&nbsp;<tt>...</tt>&nbsp;) is also an auxiliary keyword for\n"
"<tt>syntax</tt> and <tt>quasisyntax</tt>.\n"
"It is a syntax violation to reference these identifiers except in\n"
"contexts where they are recognized as auxiliary keywords."
msgstr ""
"</p><p>Эти идентификаторы являются вспомогательными ключевыми словами\n"
"для <tt>syntax-rules</tt>, <tt>identifier-syntax</tt>, и <tt>syntax-case</"
"tt>.\n"
"Второй (&nbsp;<tt>...</tt>&nbsp;) также является вспомогательным ключевым "
"словом\n"
"для  <tt>syntax</tt> и <tt>quasisyntax</tt>.\n"
"Будет нарушением синтаксиса ссылаться на данные идентификаторы, за "
"исключением\n"
"контекстов, где они распознаются как вспомогательные ключевые слова."

#: syntax.html:564
msgid ""
"</p><p>\n"
"<a name=\"./syntax:s27\"></a><span class=\"formdef\"><b>syntax</b>: "
"<tt>(identifier-syntax&nbsp;<i>tmpl</i>)</tt></span>\n"
"<br>\n"
"<span class=\"formdef\"><b>syntax</b>: <tt>(identifier-syntax&nbsp;"
"(<i>id<sub>1</sub></i>&nbsp;<i>tmpl<sub>1</sub></i>)&nbsp;((set!&nbsp;"
"<i>id<sub>2</sub></i>&nbsp;<i>e<sub>2</sub></i>)&nbsp;<i>tmpl<sub>2</sub></"
"i>))</tt></span>\n"
"<br>\n"
"<b>returns: </b>a transformer\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>"
msgstr ""
"</p><p>\n"
"<a name=\"./syntax:s27\"></a><span class=\"formdef\"><b>syntax</b>: "
"<tt>(identifier-syntax&nbsp;<i>tmpl</i>)</tt></span>\n"
"<br>\n"
"<span class=\"formdef\"><b>syntax</b>: <tt>(identifier-syntax&nbsp;"
"(<i>id<sub>1</sub></i>&nbsp;<i>tmpl<sub>1</sub></i>)&nbsp;((set!&nbsp;"
"<i>id<sub>2</sub></i>&nbsp;<i>e<sub>2</sub></i>)&nbsp;<i>tmpl<sub>2</sub></"
"i>))</tt></span>\n"
"<br>\n"
"<b>returns: </b>преобразователь\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>"

#: syntax.html:568
msgid ""
"</p><p>When a keyword is bound to a transformer produced by the first form "
"of\n"
"<tt>identifier-syntax</tt>, references to the keyword within the scope\n"
"of the binding are replaced by <tt><i>tmpl</i></tt>."
msgstr ""
"</p><p>Когда ключевое слово связывается с преобразователем созданному "
"первой\n"
"формой <tt>identifier-syntax</tt>, ссылки на ключевое слово в пределах\n"
"области связывания заменяется на <tt><i>tmpl</i></tt>."

#: syntax.html:570
msgctxt "syntax.html:570"
msgid "</p><p>"
msgstr ""

#: syntax.html:572
msgctxt "syntax.html:572"
msgid "</p><p><tt>(let&nbsp;()<br>"
msgstr ""

#: syntax.html:574
msgid ""
"&nbsp;&nbsp;(define-syntax&nbsp;a&nbsp;(identifier-syntax&nbsp;car))<br>"
msgstr ""

#: syntax.html:580
msgid ""
"&nbsp;&nbsp;(list&nbsp;(a&nbsp;'(1&nbsp;2&nbsp;3))&nbsp;a))&nbsp;<img src="
"\"./syntax_files/0.gif\" alt=\"&lt;graphic&gt;\">&nbsp;(1&nbsp;#&lt;"
"procedure&gt;)</tt>\n"
"</p><p>With the first form of <tt>identifier-syntax</tt>, an apparent "
"assignment\n"
"of the associated keyword with <tt>set!</tt> is a syntax violation.\n"
"The second, more general, form of <tt>identifier-syntax</tt> permits\n"
"the transformer to specify what happens when <tt>set!</tt> is used."
msgstr ""
"&nbsp;&nbsp;(list&nbsp;(a&nbsp;'(1&nbsp;2&nbsp;3))&nbsp;a))&nbsp;<img src="
"\"./syntax_files/0.gif\" alt=\"&lt;graphic&gt;\">&nbsp;(1&nbsp;#&lt;"
"procedure&gt;)</tt>\n"
"</p><p>Использовать только первую форму  <tt>identifier-syntax</tt> нельзя, "
"т.к. явное присваивание\n"
"связанное с ключевым словом <tt>set!</tt> может вызвать нарушение "
"синтаксиса.\n"
"Вторая, более общаяя форма <tt>identifier-syntax</tt> позволяет\n"
"преобразователю определить, что происходит при использовании <tt>set!</tt>."

#: syntax.html:582
msgctxt "syntax.html:582"
msgid "</p><p>"
msgstr ""

#: syntax.html:584
msgctxt "syntax.html:584"
msgid "</p><p><tt>(let&nbsp;([ls&nbsp;(list&nbsp;0)])<br>"
msgstr ""

#: syntax.html:586
msgctxt "syntax.html:586"
msgid "&nbsp;&nbsp;(define-syntax&nbsp;a<br>"
msgstr ""

#: syntax.html:588
msgctxt "syntax.html:588"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(identifier-syntax<br>"
msgstr ""

#: syntax.html:590
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[id&nbsp;(car&nbsp;ls)]<br>"
msgstr ""

#: syntax.html:592
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(set!&nbsp;id&nbsp;e)&nbsp;(set-car!"
"&nbsp;ls&nbsp;e)]))<br>"
msgstr ""

#: syntax.html:594
msgctxt "syntax.html:594"
msgid "&nbsp;&nbsp;(let&nbsp;([before&nbsp;a])<br>"
msgstr ""

#: syntax.html:596
msgctxt "syntax.html:596"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;a&nbsp;1)<br>"
msgstr ""

#: syntax.html:601
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;before&nbsp;a&nbsp;ls)))&nbsp;<img src="
"\"./syntax_files/0.gif\" alt=\"&lt;graphic&gt;\">&nbsp;(0&nbsp;1&nbsp;(1))</"
"tt>\n"
"</p><p><a name=\"./syntax:s28\"></a>A definition of <tt>identifier-syntax</"
"tt> in terms of\n"
"<tt>make-variable-transformer</tt> is shown on\n"
"page&nbsp;<a href=\"syntax.html#defn:identifier-syntax\">307</a>."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;before&nbsp;a&nbsp;ls)))&nbsp;<img src="
"\"./syntax_files/0.gif\" alt=\"&lt;graphic&gt;\">&nbsp;(0&nbsp;1&nbsp;(1))</"
"tt>\n"
"</p><p><a name=\"./syntax:s28\"></a>Определение <tt>identifier-syntax</tt> в "
"терминах\n"
"<tt>make-variable-transformer</tt> показано на странице\n"
"&nbsp;<a href=\"syntax.html#defn:identifier-syntax\">307</a>."

#: syntax.html:603
msgctxt "syntax.html:603"
msgid "</p><p>"
msgstr ""

#: syntax.html:605
msgid ""
"</p><h3><a name=\"g136\"></a><a name=\"./syntax:h3\"></a>Section 8.3. Syntax-"
"Case Transformers<a name=\"SECTSYNTAXCASE\"></a></h3>"
msgstr ""
"</p><h3><a name=\"g136\"></a><a name=\"./syntax:h3\"></a>Section 8.3. "
"Преобразователь Syntax-Case<a name=\"SECTSYNTAXCASE\"></a></h3>"

#: syntax.html:622
msgid ""
"<p>\n"
"This section describes a more expressive mechanism for creating\n"
"transformers, based on <tt>syntax-case</tt>, a generalized version of\n"
"<tt>syntax-rules</tt>.\n"
"This mechanism permits arbitrarily complex transformations to be specified,\n"
"including transformations that \"bend\" lexical scoping in a\n"
"controlled manner, allowing a much broader class of syntactic\n"
"extensions to be defined.\n"
"Any transformer that may be defined using <tt>syntax-rules</tt> may be\n"
"rewritten easily to use <tt>syntax-case</tt> instead;\n"
"in fact, <tt>syntax-rules</tt>\n"
"itself may be defined as a syntactic extension in terms of\n"
"<tt>syntax-case</tt>, as demonstrated within the description of\n"
"<tt>syntax</tt> below."
msgstr ""
"<p>\n"
"В этом разделе описывается более выразительный механизм создания\n"
"преобразователей, основывающийся на <tt>syntax-case</tt>, обобщенной\n"
"версии <tt>syntax-rules</tt>.\n"
"Этот механизм позволяет задавать произвольно сложные преобразования,\n"
"включая преобразоания которые  \"изгибают\"(\"bend\") лексический охват\n"
"контролируемым образом, позволяя определить борее широкий класс\n"
"синтаксических расширений.\n"
"Любой преобразователь, который может быть определен с использованием\n"
"<tt>syntax-rules</tt> может быть легко переписан с использованием\n"
"<tt>syntax-case</tt>;\n"
"На самом деле, сам <tt>syntax-rules</tt>\n"
"можно легко определить как синтаксическое расширение в терминах\n"
"<tt>syntax-case</tt>, как показано в описании\n"
"<tt>syntax</tt> ниже."

#: syntax.html:629
msgid ""
"</p><p>\n"
"<a name=\"./syntax:s29\"></a>With this mechanism, transformers are "
"procedures of one argument.\n"
"The argument is a <i>syntax object</i> representing the form to be\n"
"processed.\n"
"The return value is a syntax object representing the output form.\n"
"A syntax object may be any of the following."
msgstr ""
"</p><p>\n"
"<a name=\"./syntax:s29\"></a>В этом механизме, преобразователи являются "
"процедурами\n"
"одного аргумента.\n"
"Аргумент этот синтаксический объект(<i>syntax object</i>) представляющий "
"форму подлежащую\n"
"обработке.\n"
"Возвращаемое значение представляет собой выходную форму синтаксического "
"объекта.\n"
"Синтаксичекский объект может быть любым из следующих:"

#: syntax.html:638
msgid ""
"</p><p>\n"
"</p><ul>\n"
"<li>a nonpair, nonvector, nonsymbol value,\n"
"</li><li>a pair of syntax objects,\n"
"</li><li>a vector of syntax objects, or\n"
"</li><li>a wrapped object.\n"
"</li></ul>\n"
"<p>"
msgstr ""
"</p><p>\n"
"</p><ul>\n"
"<li>не парное, не векторное, не символьное значение,\n"
"</li><li>пара синтаксических объектов,\n"
"</li><li>вектор синтаксических объектов, или\n"
"</li><li>обернутый объект.\n"
"</li></ul>\n"
"<p>"

#: syntax.html:647
msgid ""
"</p><p>\n"
"The <i>wrap</i> on a wrapped syntax object contains contextual information\n"
"about a form in addition to its structure.\n"
"This contextual information is used by the expander to maintain\n"
"lexical scoping.\n"
"The wrap may also contain information used by the implementation to\n"
"correlate source and object code, e.g., track file, line, and character \n"
"information through the expansion and compilation process."
msgstr ""
"</p><p>\n"
"Обертка <i>wrap</i> на обернутом синтаксическом объекта содержит "
"контекстную\n"
"информацию о форме в дополнении к ее структуре.\n"
"Этак контекстная информация используется расширителем для поддержки\n"
"лексического охвата.\n"
"Обертка также может содержать информацию, используемую реализацией, для \n"
"корреляции исходного кода и объектного кода, например трассы файла,\n"
"линий и символьной информациии посредством процесса расширяния и\n"
"компиляции."

#: syntax.html:656
msgid ""
"</p><p>\n"
"The contextual information must be present for all identifiers,\n"
"which is why the definition of syntax object above does not allow\n"
"symbols unless they are wrapped.\n"
"A syntax object representing an identifier is itself referred to as\n"
"an identifier; thus, the term <i>identifier</i> may refer either to\n"
"the syntactic entity (symbol, variable, or keyword) or to the\n"
"concrete representation of the syntactic entity as a syntax object."
msgstr ""
"</p><p>\n"
"Контекстная информация должна присутствовать для всех идентификаторов,\n"
"поэтому определение синтаксического объекта, описанного выше,\n"
"не допускает символов без обертки.\n"
"Синтаксический объект, представляющий идентификатор, сам по себе\n"
"называется идентификатором; таким образом, термин  <i>identifier</i>\n"
"может относиться либо к синтаксической сущности (символ, переменная или\n"
"ключевое слово) или к конкретному представлению синтаксической сущности\n"
"как синтаксического объекта."

#: syntax.html:664
msgid ""
"</p><p>\n"
"Transformers normally destructure their input with <tt>syntax-case</tt> and "
"rebuild\n"
"their output with <tt>syntax</tt>.\n"
"These two forms alone are sufficient for defining many syntactic "
"extensions,\n"
"including any that can be defined using <tt>syntax-rules</tt>.\n"
"They are described below along with a set of additional forms and\n"
"procedures that provide added functionality."
msgstr ""
"</p><p>\n"
"Преобразователи обычно разбирают свой ввод используя <tt>syntax-case</tt> и\n"
"перестраивают свой вывод с помощью <tt>syntax</tt>.\n"
"Этих двух форм достаточно для определения многих синтаксичеких расширений,\n"
"включая любые, которые могут быть определены с использованием <tt>syntax-"
"rules</tt>.\n"
"Они описаны ниже, вместе с набором дополнительных форм и процедур, которые "
"обеспечивают\n"
"дополнительную функциональность."

#: syntax.html:671
msgid ""
"</p><p>\n"
"<a name=\"./syntax:s30\"></a><span class=\"formdef\"><b>syntax</b>: "
"<tt>(syntax-case&nbsp;<i>expr</i>&nbsp;(<i>literal</i>&nbsp;...)&nbsp;"
"<i>clause</i>&nbsp;...)</tt></span>\n"
"<br>\n"
"<b>returns: </b>see below\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>"
msgstr ""
"</p><p>\n"
"<a name=\"./syntax:s30\"></a><span class=\"formdef\"><b>syntax</b>: "
"<tt>(syntax-case&nbsp;<i>expr</i>&nbsp;(<i>literal</i>&nbsp;...)&nbsp;"
"<i>clause</i>&nbsp;...)</tt></span>\n"
"<br>\n"
"<b>returns: </b>смотри ниже\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>"

#: syntax.html:674
msgid ""
"</p><p>Each <tt><i>literal</i></tt> must be an identifier.\n"
"Each <tt><i>clause</i></tt> must take one of the following two forms."
msgstr ""
"</p><p>Каждый литерал(<tt><i>literal</i></tt>) должен быть идентификатором.\n"
"Каждое предложение(<tt><i>clause</i></tt>) должно принимать одну из "
"следующих\n"
"двух форм."

#: syntax.html:676
msgctxt "syntax.html:676"
msgid "</p><p>"
msgstr ""

#: syntax.html:678
msgid "</p><p><tt>(<i>pattern</i>&nbsp;<i>output-expression</i>)<br>"
msgstr ""

#: syntax.html:682
msgid ""
"(<i>pattern</i>&nbsp;<i>fender</i>&nbsp;<i>output-expression</i>)</tt>\n"
"</p><p><tt>syntax-case</tt> patterns may be in any of the forms described\n"
"in Section&nbsp;<a href=\"syntax.html#g135\">8.2</a>."
msgstr ""
"(<i>pattern</i>&nbsp;<i>fender</i>&nbsp;<i>output-expression</i>)</tt>\n"
"</p><p><tt>syntax-case</tt> образец(patterns) может быть в любой форме, "
"описанной\n"
"в разделе&nbsp;<a href=\"syntax.html#g135\">8.2</a>."

#: syntax.html:695
msgid ""
"</p><p>\n"
"<tt>syntax-case</tt> first evaluates <tt><i>expr</i></tt>, then attempts\n"
"to match the resulting value against the pattern from the first\n"
"<tt><i>clause</i></tt>.\n"
"This value may be any Scheme object.\n"
"If the value matches the pattern and no\n"
"<a name=\"./syntax:s31\"></a><tt><i>fender</i></tt> is present,\n"
"<tt><i>output-expression</i></tt> is evaluated and its values returned as "
"the\n"
"values of the <tt>syntax-case</tt> expression.\n"
"If the value does not match the pattern, the value is compared against\n"
"the next clause, and so on.\n"
"It is a syntax violation if the value does not match any of the patterns."
msgstr ""
"</p><p>\n"
"<tt>syntax-case</tt> сначала вычисляет <tt><i>expr</i></tt>, затем пытается\n"
"сопоставить полученное значение с образцом из первого предложения\n"
"(<tt><i>clause</i></tt>).\n"
"Это значение может быть любым объектом Scheme.\n"
"Если значение соответствует образцу и нет флага\n"
"<a name=\"./syntax:s31\"></a><tt><i>fender</i></tt>,\n"
"вычисляется значение выражения <tt><i>output-expression</i></tt> и его\n"
"значение возвращается как значение выражения  <tt>syntax-case</tt>.\n"
"Если значение не соответствует образцу, значение сравнивается со\n"
"следующим предложением и т.д.\n"
"Если значение не соответствует ни одному из образцов это будет\n"
"нарушением синтаксиса."

#: syntax.html:707
msgid ""
"</p><p>\n"
"If the optional <tt><i>fender</i></tt> is present, it serves as an "
"additional\n"
"constraint on acceptance of a clause.\n"
"If the value of the <tt>syntax-case</tt> <tt><i>expr</i></tt> matches the "
"pattern for a given\n"
"clause, the corresponding <tt><i>fender</i></tt> is evaluated.\n"
"If <tt><i>fender</i></tt> evaluates to a true value, the clause is "
"accepted;\n"
"otherwise, the clause is rejected as if the input had failed to match\n"
"the pattern.\n"
"Fenders are logically a part of the matching process, i.e., they\n"
"specify additional matching constraints beyond the basic structure of\n"
"an expression."
msgstr ""
"</p><p>\n"
"Если присутствует необязательный параметр <tt><i>fender</i></tt>, он служит "
"дополнительным\n"
"ограничением при принятии предложения.\n"
"Если значение выражения  <tt><i>expr</i></tt> в <tt>syntax-case</tt>  "
"соответствует образцу\n"
"для данного предложения, вычисляется соответствующее выражение "
"<tt><i>fender</i></tt>.\n"
"Если вычисление <tt><i>fender</i></tt> дает истинное значение, предложение "
"принимается;\n"
"В противном случае, предложение отклоняется, как если бы ввод не "
"соответствовал образцу.\n"
"Fender логически является частью процесса сопоставления, то есть оно задает "
"дополнительные\n"
"ограничения на соответствие вне базовой структуры выражения."

#: syntax.html:719
msgid ""
"</p><p>\n"
"<a name=\"./syntax:s32\"></a>Pattern variables contained within a clause's\n"
"<tt><i>pattern</i></tt> are bound to the corresponding pieces of the input\n"
"value within the clause's <tt><i>fender</i></tt> (if present) and\n"
"<tt><i>output-expression</i></tt>.\n"
"Pattern variables occupy the same namespace as program variables and\n"
"keywords; pattern variable bindings created by <tt>syntax-case</tt>\n"
"can shadow (and be shadowed by) program variable and keyword bindings as\n"
"well as other pattern variable bindings.\n"
"Pattern variables, however, can be referenced only within <tt>syntax</tt>\n"
"expressions."
msgstr ""
"</p><p>\n"
"<a name=\"./syntax:s32\"></a>Переменные образца содержащиеся в предложении\n"
"<tt><i>pattern</i></tt> связываются с соответствующими частями входного\n"
"значения в предложении <tt><i>fender</i></tt> (если оно есть) и\n"
"<tt><i>output-expression</i></tt>.\n"
"Переменные образца занимают одно и тоже пространство имен, что и переменные\n"
"программы и ключевые слова; привязки переменных образца созданные <tt>syntax-"
"case</tt>\n"
"могут скрывать(и могут быть скрыты) привязки переменных программы и ключевых "
"слов, а\n"
"так же другие привязки переменных образца.\n"
"Однако на переменные образца можно ссылаться только в выражении <tt>syntax</"
"tt>."

#: syntax.html:722
msgid ""
"</p><p>\n"
"See the examples following the description of <tt>syntax</tt>."
msgstr ""
"</p><p>\n"
"См примеры следующипе за описанием <tt>syntax</tt>."

#: syntax.html:731
msgid ""
"</p><p>\n"
"<a name=\"./syntax:s33\"></a><span class=\"formdef\"><b>syntax</b>: "
"<tt>(syntax&nbsp;<i>template</i>)</tt></span>\n"
"<br>\n"
"<span class=\"formdef\"><b>syntax</b>: <tt>#'<i>template</i></tt></span>\n"
"<br>\n"
"<b>returns: </b>see below\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>"
msgstr ""
"</p><p>\n"
"<a name=\"./syntax:s33\"></a><span class=\"formdef\"><b>syntax</b>: "
"<tt>(syntax&nbsp;<i>template</i>)</tt></span>\n"
"<br>\n"
"<span class=\"formdef\"><b>syntax</b>: <tt>#'<i>template</i></tt></span>\n"
"<br>\n"
"<b>returns: </b>см. ниже\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>"

#: syntax.html:735
msgid ""
"</p><p><tt>#'<i>template</i></tt> is equivalent to <tt>(syntax&nbsp;"
"<i>template</i>)</tt>.\n"
"The abbreviated form is converted into the longer form when a program\n"
"is read, prior to macro expansion."
msgstr ""
"</p><p><tt>#'<i>template</i></tt> эквививалентно <tt>(syntax&nbsp;"
"<i>template</i>)</tt>.\n"
"Сокращенная форма преобразуется в более длинную форму при чтении программы, "
"до расширения\n"
"макроса."

#: syntax.html:744
msgid ""
"</p><p>\n"
"A <tt>syntax</tt> expression is like a <tt>quote</tt> expression except that "
"the\n"
"values of pattern variables appearing within <tt><i>template</i></tt> are\n"
"inserted into <tt><i>template</i></tt>, and\n"
"contextual information associated both with the input and with the template "
"is\n"
"retained in the output to support lexical scoping.\n"
"A <tt>syntax</tt> <tt><i>template</i></tt> is identical to a <tt>syntax-"
"rules</tt>\n"
"<tt><i>template</i></tt> and is treated similarly."
msgstr ""
"</p><p>\n"
"Выражение <tt>syntax</tt> похоже на выражение <tt>quote</tt>, за исключением "
"того,\n"
"что значения переменных образца, входящих в <tt><i>template</i></tt> "
"вставляются\n"
"в шаблон(<tt><i>template</i></tt>), а контекстная информация, связанная как "
"с\n"
"вводом, так и с шаблоном(template), сохраняется в выводе для поддержки\n"
"лексического охвата(области действия).\n"
"Выражение <tt><i>template</i></tt> в <tt>syntax</tt>  идентично выражению "
"<tt><i>template</i></tt> \n"
"в <tt>syntax-rules</tt> и обрабатывается аналогично."

#: syntax.html:754
msgid ""
"</p><p>\n"
"List and vector structures within the template become true lists or\n"
"vectors (suitable for direct application of list or vector operations,\n"
"like <tt>map</tt> or <tt>vector-ref</tt>) to the extent that the\n"
"list or vector structures must be copied to insert the values of\n"
"pattern variables, and empty lists are never wrapped.\n"
"For example, <tt>#'(x&nbsp;...)</tt>, <tt>#'(a&nbsp;b&nbsp;c)</tt>, "
"<tt>#'()</tt> are\n"
"all lists if <tt>x</tt>, <tt>a</tt>, <tt>b</tt>, and <tt>c</tt> are\n"
"pattern variables."
msgstr ""
"</p><p>\n"
"Списковые и векторные структуры внутри шаблона становятся настоящими "
"списками\n"
"и векторами (подходящими для непосредственного применения списковыми и\n"
"вектроными операцияи, такими как <tt>map</tt> или <tt>vector-ref</tt>) в "
"той\n"
"мере, в какой списковые и векторные структуры должны быть скопированы для \n"
"вставки значений переменных образца, а пустые списки никогда не будут "
"обернуты.\n"
"Например, <tt>#'(x&nbsp;...)</tt>, <tt>#'(a&nbsp;b&nbsp;c)</tt>, <tt>#'()</"
"tt> все\n"
"списки, если  <tt>x</tt>, <tt>a</tt>, <tt>b</tt>, и <tt>c</tt> являются\n"
"переменными образца."

#: syntax.html:759
msgid ""
"</p><p>\n"
"The definition of <tt>or</tt> below is equivalent to the one given in\n"
"Section&nbsp;<a href=\"syntax.html#g135\">8.2</a> except that it employs "
"<tt>syntax-case</tt> and\n"
"<tt>syntax</tt> in place of <tt>syntax-rules</tt>."
msgstr ""
"</p><p>\n"
"Определение <tt>or</tt> ниже эквивалентно определению приведенному в \n"
"разделе &nbsp;<a href=\"syntax.html#g135\">8.2</a>, за исключением того, что "
"используется\n"
"<tt>syntax-case</tt> и\n"
"<tt>syntax</tt> вместо <tt>syntax-rules</tt>."

#: syntax.html:761
msgctxt "syntax.html:761"
msgid "</p><p>"
msgstr ""

#: syntax.html:763
msgctxt "syntax.html:763"
msgid "</p><p><tt>(define-syntax&nbsp;or<br>"
msgstr ""

#: syntax.html:765
msgctxt "syntax.html:765"
msgid "&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:767
msgctxt "syntax.html:767"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:769
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_)&nbsp;#'#f]<br>"
msgstr ""

#: syntax.html:771
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e)&nbsp;#'e]<br>"
msgstr ""

#: syntax.html:773
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e1&nbsp;e2&nbsp;e3&nbsp;...)<br>"
msgstr ""

#: syntax.html:784
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(let&nbsp;([t&nbsp;e1])&nbsp;"
"(if&nbsp;t&nbsp;t&nbsp;(or&nbsp;e2&nbsp;e3&nbsp;...)))])))</tt>\n"
"</p><p>In this version, the <tt>lambda</tt> expression that produces the\n"
"transformer is explicit, as are the <tt>syntax</tt> forms in the output\n"
"part of each clause.\n"
"Any <tt>syntax-rules</tt> form can be expressed with\n"
"<tt>syntax-case</tt> by making the <tt>lambda</tt> expression and\n"
"<tt>syntax</tt> expressions explicit.\n"
"This observation leads to the following definition of\n"
"<a name=\"./syntax:s34\"></a><tt>syntax-rules</tt> in terms of\n"
"<tt>syntax-case</tt>."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(let&nbsp;([t&nbsp;e1])&nbsp;"
"(if&nbsp;t&nbsp;t&nbsp;(or&nbsp;e2&nbsp;e3&nbsp;...)))])))</tt>\n"
"</p><p>В этой версии выражение <tt>lambda</tt>, которое производит "
"преобразователь,\n"
"является явным, как и формы <tt>syntax</tt> в выходной части каждого "
"предложения.\n"
"Любая форма <tt>syntax-rules</tt> может быть выражена с помощью\n"
"<tt>syntax-case</tt> созданием явного <tt>lambda</tt> выражения и явного\n"
"<tt>syntax</tt> выражения.\n"
"Это наблюдение приводит к следующему определению\n"
"<a name=\"./syntax:s34\"></a><tt>syntax-rules</tt> в терминах\n"
"<tt>syntax-case</tt>."

#: syntax.html:786
msgctxt "syntax.html:786"
msgid "</p><p>"
msgstr ""

#: syntax.html:788
msgid "</p><p><tt>(define-syntax&nbsp;syntax-rules<br>"
msgstr ""

#: syntax.html:790
msgctxt "syntax.html:790"
msgid "&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:792
msgctxt "syntax.html:792"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:794
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(i&nbsp;...)&nbsp;"
"((keyword&nbsp;.&nbsp;pattern)&nbsp;template)&nbsp;...)<br>"
msgstr ""

#: syntax.html:796
msgctxt "syntax.html:796"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:798
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-"
"case&nbsp;x&nbsp;(i&nbsp;...)<br>"
msgstr ""

#: syntax.html:803
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;[(_&nbsp;.&nbsp;pattern)&nbsp;#'template]&nbsp;...))])))</tt>\n"
"</p><p>An underscore is used in place of\n"
"each <tt>keyword</tt> since the first position\n"
"of each <tt>syntax-rules</tt> pattern is always ignored."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;[(_&nbsp;.&nbsp;pattern)&nbsp;#'template]&nbsp;...))])))</tt>\n"
"</p><p>Знак символа подчеркивания используется вместо\n"
"каждого ключевого слова(<tt>keyword</tt>), так как первая позиция\n"
"в каждом синтаксическом правиле(<tt>syntax-rules</tt>) образца всегда "
"игнорируется."

#: syntax.html:813
msgid ""
"</p><p>\n"
"Since the <tt>lambda</tt> and <tt>syntax</tt> expressions are\n"
"implicit in a <tt>syntax-rules</tt> form, definitions expressed with\n"
"<tt>syntax-rules</tt> are often shorter than the equivalent definitions\n"
"expressed with <tt>syntax-case</tt>.\n"
"The choice of which to use when either suffices is a matter of\n"
"taste, but many transformers that can be written easily with\n"
"<tt>syntax-case</tt> cannot be written easily or at all with <tt>syntax-"
"rules</tt>\n"
"(see Section&nbsp;<a href=\"syntax.html#g137\">8.4</a>)."
msgstr ""
"</p><p>\n"
"Поскольку выражения <tt>lambda</tt> и <tt>syntax</tt> неявные в\n"
"форме <tt>syntax-rules</tt>, определения выраженные с помощью\n"
"<tt>syntax-rules</tt> часто короче эквивалентных определений,\n"
"выраженных с помощью <tt>syntax-case</tt>.\n"
"Выбор того что использовать является делом вкуса, но многие\n"
"преобразователи, которые могут быть легко  написаны с помощью\n"
"<tt>syntax-case</tt> нельзя написать легко или даже невозможно\n"
"с помощью <tt>syntax-rules</tt>\n"
"(см. Раздел &nbsp;<a href=\"syntax.html#g137\">8.4</a>)."

#: syntax.html:820
msgid ""
"</p><p>\n"
"<a name=\"./syntax:s35\"></a><span class=\"formdef\"><b>procedure</b>: "
"<tt>(identifier?&nbsp;<i>obj</i>)</tt></span>\n"
"<br>\n"
"<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is an identifier, <tt>#f</"
"tt> otherwise\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>"
msgstr ""
"</p><p>\n"
"<a name=\"./syntax:s35\"></a><span class=\"formdef\"><b>procedure</b>: "
"<tt>(identifier?&nbsp;<i>obj</i>)</tt></span>\n"
"<br>\n"
"<b>returns: </b><tt>#t</tt> если <tt><i>obj</i></tt> является "
"идентификатором, <tt>#f</tt> в противном случае\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>"

#: syntax.html:824
msgid ""
"</p><p><tt>identifier?</tt> is often used within <a name=\"./syntax:s36\"></"
"a>fenders to verify\n"
"that certain subforms of an input form are identifiers, as in the\n"
"definition of unnamed <tt>let</tt> below."
msgstr ""
"</p><p><tt>identifier?</tt> часто используется с <a name=\"./syntax:s36\"></"
"a>fenders для проверки\n"
"того, что определенные подформы входной формы являются идентификаторами,\n"
"как в определении неименованного <tt>let</tt> ниже."

#: syntax.html:826
msgctxt "syntax.html:826"
msgid "</p><p>"
msgstr ""

#: syntax.html:828
msgctxt "syntax.html:828"
msgid "</p><p><tt>(define-syntax&nbsp;let<br>"
msgstr ""

#: syntax.html:830
msgctxt "syntax.html:830"
msgid "&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:832
msgctxt "syntax.html:832"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;ids?<br>"
msgstr ""

#: syntax.html:834
msgctxt "syntax.html:834"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ls)<br>"
msgstr ""

#: syntax.html:836
msgctxt "syntax.html:836"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(null?&nbsp;ls)<br>"
msgstr ""

#: syntax.html:838
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"(and&nbsp;(identifier?&nbsp;(car&nbsp;ls))<br>"
msgstr ""

#: syntax.html:840
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ids?&nbsp;(cdr&nbsp;ls))))))<br>"
msgstr ""

#: syntax.html:842
msgctxt "syntax.html:842"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:844
msgctxt "syntax.html:844"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((i&nbsp;e)&nbsp;...)&nbsp;"
"b1&nbsp;b2&nbsp;...)<br>"
msgstr ""

#: syntax.html:846
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ids?&nbsp;#'(i&nbsp;...))<br>"
msgstr ""

#: syntax.html:856
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'((lambda&nbsp;(i&nbsp;...)&nbsp;"
"b1&nbsp;b2&nbsp;...)&nbsp;e&nbsp;...)])))</tt>\n"
"</p><p>Syntactic extensions ordinarily take the form\n"
"<tt>(<i>keyword</i>&nbsp;<i>subform</i>&nbsp;...)</tt>, but the\n"
"<tt>syntax-case</tt> system permits them to take the form of singleton\n"
"identifiers as well.\n"
"For example, the keyword <tt>pcar</tt> in the expression below may be used\n"
"both as an identifier (in which case it expands into a call to <tt>car</"
"tt>)\n"
"or as a structured form (in which case it expands\n"
"into a call to <tt>set-car!</tt>)."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'((lambda&nbsp;(i&nbsp;...)&nbsp;"
"b1&nbsp;b2&nbsp;...)&nbsp;e&nbsp;...)])))</tt>\n"
"</p><p>Синтаксические расширения обычно принимают форму\n"
"<tt>(<i>keyword</i>&nbsp;<i>subform</i>&nbsp;...)</tt>, но система\n"
"<tt>syntax-case</tt> позволяет им также принимать форму одиночных\n"
"идентификаторов.\n"
"Например, ключевое слово <tt>pcar</tt> в приведенном ниже выражении может \n"
"использоваться как идентификатор (в этом случае он расширяется\n"
"в вызов <tt>car</tt>)\n"
"или как структрная форма (в этом случае он расширяется в вызов\n"
" <tt>set-car!</tt>)."

#: syntax.html:858
msgctxt "syntax.html:858"
msgid "</p><p>"
msgstr ""

#: syntax.html:860
msgid "</p><p><tt>(let&nbsp;([p&nbsp;(cons&nbsp;0&nbsp;#f)])<br>"
msgstr ""

#: syntax.html:862
msgid "&nbsp;&nbsp;(define-syntax&nbsp;pcar<br>"
msgstr ""

#: syntax.html:864
msgctxt "syntax.html:864"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:866
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:868
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[_&nbsp;(identifier?&nbsp;"
"x)&nbsp;#'(car&nbsp;p)]<br>"
msgstr ""

#: syntax.html:870
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e)&nbsp;#'(set-car!"
"&nbsp;p&nbsp;e)])))<br>"
msgstr ""

#: syntax.html:872
msgid "&nbsp;&nbsp;(let&nbsp;([a&nbsp;pcar])<br>"
msgstr ""

#: syntax.html:874
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(pcar&nbsp;1)<br>"
msgstr ""

#: syntax.html:878
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;a&nbsp;pcar)))&nbsp;<img src=\"./"
"syntax_files/0.gif\" alt=\"&lt;graphic&gt;\">&nbsp;(0&nbsp;1)</tt>\n"
"</p><p>The fender <tt>(identifier?&nbsp;x)</tt> is used to recognize the "
"singleton\n"
"identifier case."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;a&nbsp;pcar)))&nbsp;<img src=\"./"
"syntax_files/0.gif\" alt=\"&lt;graphic&gt;\">&nbsp;(0&nbsp;1)</tt>\n"
"</p><p>Выражение <tt>(identifier?&nbsp;x)</tt> является дополнительным "
"условием(fender) для поиска по образцу используемое\n"
"для распознавания случая одиночного идентификатора."

#: syntax.html:888
msgid ""
"</p><p>\n"
"<a name=\"./syntax:s37\"></a><span class=\"formdef\"><b>procedure</b>: "
"<tt>(free-identifier=?&nbsp;<i>identifier<sub>1</sub></i>&nbsp;"
"<i>identifier<sub>2</sub></i>)</tt></span>\n"
"<br>\n"
"<span class=\"formdef\"><b>procedure</b>: <tt>(bound-identifier=?&nbsp;"
"<i>identifier<sub>1</sub></i>&nbsp;<i>identifier<sub>2</sub></i>)</tt></"
"span>\n"
"<br>\n"
"<b>returns: </b>see below\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>"
msgstr ""
"</p><p>\n"
"<a name=\"./syntax:s37\"></a><span class=\"formdef\"><b>procedure</b>: "
"<tt>(free-identifier=?&nbsp;<i>identifier<sub>1</sub></i>&nbsp;"
"<i>identifier<sub>2</sub></i>)</tt></span>\n"
"<br>\n"
"<span class=\"formdef\"><b>procedure</b>: <tt>(bound-identifier=?&nbsp;"
"<i>identifier<sub>1</sub></i>&nbsp;<i>identifier<sub>2</sub></i>)</tt></"
"span>\n"
"<br>\n"
"<b>returns: </b>см ниже\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>"

#: syntax.html:894
msgid ""
"</p><p>Symbolic names alone do not distinguish identifiers unless the\n"
"identifiers are to be used only as symbolic data.\n"
"The predicates <tt>free-identifier=?</tt> and <tt>bound-identifier=?</tt>\n"
"are used to compare identifiers according to their <i>intended use</i>\n"
"as free references or bound identifiers in a given context."
msgstr ""
"</p><p>Только символические имена неотличимы от идентификаторов,\n"
"если идентификаторы не должны использоваться только как\n"
"символические данные.\n"
"Предикаты <tt>free-identifier=?</tt> и <tt>bound-identifier=?</tt>\n"
"используются для сравнения идентификаторов в соответствии с их\n"
"предполагаемым использованием(<i>intended use</i>) в данном контексте\n"
"в качестве свободных ссылок или связанных идентификаторов.\n"

#: syntax.html:909
msgid ""
"</p><p>\n"
"<tt>free-identifier=?</tt> is used to determine whether two\n"
"identifiers would be equivalent if they were to appear as free identifiers\n"
"in the output of a transformer.\n"
"Because identifier references are lexically scoped, this means\n"
"<tt>(free-identifier=?&nbsp;<i>id<sub>1</sub></i>&nbsp;<i>id<sub>2</sub></"
"i>)</tt> is true if and only if the\n"
"identifiers <tt><i>id<sub>1</sub></i></tt> and <tt><i>id<sub>2</sub></i></"
"tt> refer to the same\n"
"binding.\n"
"(For this comparison, two like-named identifiers are assumed to have the\n"
"same binding if neither is bound.)\n"
"Literal identifiers (auxiliary keywords) appearing in\n"
"<tt>syntax-case</tt> patterns (such as <tt>else</tt> in <tt>case</tt>\n"
"and <tt>cond</tt>)\n"
"are matched with <tt>free-identifier=?</tt>."
msgstr ""
"</p><p>\n"
"<tt>free-identifier=?</tt> используется для определения того, будут ли\n"
"два идентификатора эквивалентными, если они будут отображаться как "
"свободные\n"
"идентификаторы на выходе преобразователя.\n"
"Поскольку ссылки идентификаторов лексически ограничены, это означает, что\n"
"<tt>(free-identifier=?&nbsp;<i>id<sub>1</sub></i>&nbsp;<i>id<sub>2</sub></"
"i>)</tt> является истинным\n"
"тогда и только тогда, когда идентификаторы\n"
"<tt><i>id<sub>1</sub></i></tt> и <tt><i>id<sub>2</sub></i></tt> относятся к "
"одной и той же\n"
"привязке.\n"
"(Для этого сравнения предполагается, что два одинаково названных "
"идентификатора имеют одинаковую\n"
"привязку, если они не связаны)\n"
"Литеральные идентификаторы (вспомогательные ключевые слова), появляющиеся в "
"образце\n"
"<tt>syntax-case</tt> (такие как <tt>else</tt> в <tt>case</tt>\n"
"и <tt>cond</tt>)\n"
"сопоставляются с <tt>free-identifier=?</tt>."

#: syntax.html:925
msgid ""
"</p><p>\n"
"Similarly, <tt>bound-identifier=?</tt> is used to\n"
"determine whether two identifiers would be equivalent if they were to appear "
"as\n"
"bound identifiers in the output of a transformer.\n"
"In other words, if <tt>bound-identifier=?</tt> returns true for two\n"
"identifiers, a binding for one will capture references to the\n"
"other within its scope.\n"
"In general, two identifiers are <tt>bound-identifier=?</tt> only if\n"
"both are present in the original program or both are introduced by the\n"
"same transformer application\n"
"(perhaps implicitly---see <tt>datum-&gt;syntax</tt>).\n"
"<tt>bound-identifier=?</tt> can be used for detecting\n"
"duplicate identifiers in a binding construct or for other\n"
"preprocessing of a binding construct that requires detecting instances\n"
"of the bound identifiers."
msgstr ""
"</p><p>\n"
"Аналогично, <tt>bound-identifier=?</tt> используется для определения того, "
"будут ли\n"
"два идентификатора эквивалентными, если они будут отображаться как\n"
"связанные иденификаторы на выходе преобразователя.\n"
"Другими словами, если <tt>bound-identifier=?</tt> возвращает истину для "
"двух\n"
"идентификаторов, привязка для одного будет захватывать сслыки на другой в "
"пределах\n"
"своей области.\n"
"В общем, два идентификатора являются <tt>bound-identifier=?</tt> только "
"если\n"
"оба присутствуют в исходной программе, или оба они вводятся одним и тем же\n"
"применением преобразователя\n"
"(возможно неявно---см <tt>datum-&gt;syntax</tt>).\n"
"<tt>bound-identifier=?</tt> может использоваться для обнаружения "
"повторяющихся\n"
"идентификаторов в конструкции связывания или для другой предварительной\n"
"обработки конструкции связывания, которая требует обнаружения экзепляров\n"
"связанных идентификаторов."

#: syntax.html:931
msgid ""
"</p><p>\n"
"The definition below is equivalent to the earlier definition\n"
"of a simplified version of <tt>cond</tt> with <tt>syntax-rules</tt>, except "
"that\n"
"<tt>else</tt> is recognized via an explicit call to <tt>free-identifier?</"
"tt> within\n"
"a fender rather than via inclusion in the literals list."
msgstr ""
"</p><p>\n"
"Ниже приведенное определение эквивалентно более раннему определению\n"
"упрощенной версии <tt>cond</tt> с <tt>syntax-rules</tt>, за исключением\n"
"того, что <tt>else</tt> распознается через явный вызов <tt>free-identifier?</"
"tt> с\n"
"дополнительным условием(fender), а не через включение в список литералов."

#: syntax.html:933
msgctxt "syntax.html:933"
msgid "</p><p>"
msgstr ""

#: syntax.html:935
msgctxt "syntax.html:935"
msgid "</p><p><tt>(define-syntax&nbsp;cond<br>"
msgstr ""

#: syntax.html:937
msgctxt "syntax.html:937"
msgid "&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:939
msgctxt "syntax.html:939"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:941
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(e0&nbsp;e1&nbsp;"
"e2&nbsp;...))<br>"
msgstr ""

#: syntax.html:943
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(identifier?&nbsp;"
"#'e0)&nbsp;(free-identifier=?&nbsp;#'e0&nbsp;#'else))<br>"
msgstr ""

#: syntax.html:945
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(begin&nbsp;e1&nbsp;"
"e2&nbsp;...)]<br>"
msgstr ""

#: syntax.html:947
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(e0&nbsp;e1&nbsp;"
"e2&nbsp;...))&nbsp;#'(if&nbsp;e0&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...))]<br>"
msgstr ""

#: syntax.html:949
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(e0&nbsp;e1&nbsp;"
"e2&nbsp;...)&nbsp;c1&nbsp;c2&nbsp;...)<br>"
msgstr ""

#: syntax.html:955
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(if&nbsp;e0&nbsp;(begin&nbsp;"
"e1&nbsp;e2&nbsp;...)&nbsp;(cond&nbsp;c1&nbsp;c2&nbsp;...))])))</tt>\n"
"</p><p>With either definition of <tt>cond</tt>, <tt>else</tt> is not\n"
"recognized as an auxiliary\n"
"keyword if an enclosing lexical binding for <tt>else</tt> exists.\n"
"For example,"
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(if&nbsp;e0&nbsp;(begin&nbsp;"
"e1&nbsp;e2&nbsp;...)&nbsp;(cond&nbsp;c1&nbsp;c2&nbsp;...))])))</tt>\n"
"</p><p>С этим определением  <tt>cond</tt>, <tt>else</tt> не распознается\n"
"как вспомогательное ключевое слово, если существует окружающая лексическая\n"
"привязка <tt>else</tt>.\n"
"Например,"

#: syntax.html:957
msgctxt "syntax.html:957"
msgid "</p><p>"
msgstr ""

#: syntax.html:959
msgid "</p><p><tt>(let&nbsp;([else&nbsp;#f])<br>"
msgstr ""

#: syntax.html:965
msgid ""
"&nbsp;&nbsp;(cond&nbsp;[else&nbsp;(write&nbsp;\"oops\")]))</tt>\n"
"</p><p>does <i>not</i> write <tt>\"oops\"</tt>, since <tt>else</tt> is "
"bound\n"
"lexically and is\n"
"therefore not the same <tt>else</tt> that appears in the definition of\n"
"<tt>cond</tt>."
msgstr ""
"&nbsp;&nbsp;(cond&nbsp;[else&nbsp;(write&nbsp;\"oops\")]))</tt>\n"
"</p><p> <i>НЕ</i> пишет <tt>\"oops\"</tt>, поскольку <tt>else</tt> связан\n"
"лексически и, следовательно, не является тем же <tt>else</tt> что и\n"
"в определении <tt>cond</tt>."

#: syntax.html:969
msgid ""
"</p><p>\n"
"The following definition of unnamed <tt>let</tt>\n"
"uses <tt>bound-identifier=?</tt> to detect duplicate identifiers."
msgstr ""
"</p><p>\n"
"Следующее определение неименованного <tt>let</tt>\n"
"использует <tt>bound-identifier=?</tt> для обнаружения повторяющихся "
"идентификаторов."

#: syntax.html:971
msgctxt "syntax.html:971"
msgid "</p><p>"
msgstr ""

#: syntax.html:973
msgctxt "syntax.html:973"
msgid "</p><p><tt>(define-syntax&nbsp;let<br>"
msgstr ""

#: syntax.html:975
msgctxt "syntax.html:975"
msgid "&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:977
msgctxt "syntax.html:977"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;ids?<br>"
msgstr ""

#: syntax.html:979
msgctxt "syntax.html:979"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ls)<br>"
msgstr ""

#: syntax.html:981
msgctxt "syntax.html:981"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(null?&nbsp;ls)<br>"
msgstr ""

#: syntax.html:983
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"(and&nbsp;(identifier?&nbsp;(car&nbsp;ls))&nbsp;(ids?&nbsp;(cdr&nbsp;"
"ls))))))<br>"
msgstr ""

#: syntax.html:985
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;unique-ids?<br>"
msgstr ""

#: syntax.html:987
msgctxt "syntax.html:987"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ls)<br>"
msgstr ""

#: syntax.html:989
msgctxt "syntax.html:989"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(null?&nbsp;ls)<br>"
msgstr ""

#: syntax.html:991
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"(and&nbsp;(not&nbsp;(memp<br>"
msgstr ""

#: syntax.html:993
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"(lambda&nbsp;(x)&nbsp;(bound-identifier=?&nbsp;x&nbsp;(car&nbsp;ls)))<br>"
msgstr ""

#: syntax.html:995
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"(cdr&nbsp;ls)))<br>"
msgstr ""

#: syntax.html:997
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unique-ids?&nbsp;(cdr&nbsp;ls))))))<br>"
msgstr ""

#: syntax.html:999
msgctxt "syntax.html:999"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:1001
msgctxt "syntax.html:1001"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((i&nbsp;e)&nbsp;...)&nbsp;"
"b1&nbsp;b2&nbsp;...)<br>"
msgstr ""

#: syntax.html:1003
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(ids?&nbsp;"
"#'(i&nbsp;...))&nbsp;(unique-ids?&nbsp;#'(i&nbsp;...)))<br>"
msgstr ""

#: syntax.html:1006
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'((lambda&nbsp;(i&nbsp;...)&nbsp;"
"b1&nbsp;b2&nbsp;...)&nbsp;e&nbsp;...)])))</tt>\n"
"</p><p>With the definition of <tt>let</tt> above, the expression"
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'((lambda&nbsp;(i&nbsp;...)&nbsp;"
"b1&nbsp;b2&nbsp;...)&nbsp;e&nbsp;...)])))</tt>\n"
"</p><p>С определением <tt>let</tt> выше, выражение"

#: syntax.html:1008
msgctxt "syntax.html:1008"
msgid "</p><p>"
msgstr ""

#: syntax.html:1011
msgid ""
"</p><p><tt>(let&nbsp;([a&nbsp;3]&nbsp;[a&nbsp;4])&nbsp;(+&nbsp;a&nbsp;a))</"
"tt>\n"
"</p><p>is a syntax violation, whereas"
msgstr ""
"</p><p><tt>(let&nbsp;([a&nbsp;3]&nbsp;[a&nbsp;4])&nbsp;(+&nbsp;a&nbsp;a))</"
"tt>\n"
"</p><p>является нарушением, синтаксиса"

#: syntax.html:1013
msgctxt "syntax.html:1013"
msgid "</p><p>"
msgstr ""

#: syntax.html:1015
msgid "</p><p><tt>(let&nbsp;([a&nbsp;0])<br>"
msgstr ""

#: syntax.html:1017
msgid "&nbsp;&nbsp;(let-syntax&nbsp;([dolet&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:1019
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"(syntax-case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:1021
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;[(_&nbsp;b)<br>"
msgstr ""

#: syntax.html:1023
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;#'(let&nbsp;([a&nbsp;3]&nbsp;[b&nbsp;4])&nbsp;(+&nbsp;"
"a&nbsp;b))]))])<br>"
msgstr ""

#: syntax.html:1031
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;(dolet&nbsp;a)))</tt>\n"
"</p><p>evaluates to <tt>7</tt> since the identifier <tt>a</tt> introduced by "
"<tt>dolet</tt>\n"
"and the identifier <tt>a</tt> extracted from the input form are not\n"
"<tt>bound-identifier=?</tt>.\n"
"Since both occurrences of <tt>a</tt>, however, if left as free references,\n"
"would refer to the same binding for <tt>a</tt>, <tt>free-identifier=?</tt>\n"
"would not distinguish them."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;(dolet&nbsp;a)))</tt>\n"
"</p><p>вычисляется до <tt>7</tt> поскольку идентификатор <tt>a</tt> "
"введенный в <tt>dolet</tt>\n"
"и идентификатор <tt>a</tt> извлеченный из входной формы, не являются\n"
"<tt>bound-identifier=?</tt>(связаными).\n"
"Так как оба вхождения <tt>a</tt>, однако, если они оставлены как свободные "
"ссылки,\n"
"будут ссылаться на одну и туже привязку для <tt>a</tt>, <tt>free-identifier=?"
"</tt>\n"
"не будет их различать."

#: syntax.html:1041
msgid ""
"</p><p>\n"
"Two identifiers that are <tt>free-identifier=?</tt> may not be\n"
"<tt>bound-identifier=?</tt>.\n"
"An identifier introduced by a transformer may refer to the same\n"
"enclosing binding as an identifier not introduced by the transformer,\n"
"but an introduced binding for one will not capture references to the other.\n"
"On the other hand, identifiers that are <tt>bound-identifier=?</tt> are\n"
"<tt>free-identifier=?</tt>, as long as the identifiers have valid\n"
"bindings in the context where they are compared."
msgstr ""
"</p><p>\n"
"Два идентификатора, которые являются <tt>free-identifier=?</tt> могут не "
"быть\n"
"<tt>bound-identifier=?</tt>.\n"
"Идентификатор введенный преобразователем, может ссылаться на туже "
"охватывающую\n"
"привяку, что и идентификатор, не вводимый преобразователем,\n"
"но введенная привязка для одного не будет захватывать ссылки на другой.\n"
"С другой стороны, идентификаторы, которые являются <tt>bound-identifier=?</"
"tt>\n"
"являются <tt>free-identifier=?</tt>, пока идентификаторы имеют "
"действительные\n"
"привязки в контексте, в котором они сравниваются."

#: syntax.html:1049
msgid ""
"</p><p>\n"
"<a name=\"./syntax:s38\"></a><span class=\"formdef\"><b>syntax</b>: "
"<tt>(with-syntax&nbsp;((<i>pattern</i>&nbsp;<i>expr</i>)&nbsp;...)&nbsp;"
"<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt></span>\n"
"<br>\n"
"<b>returns: </b>the values of the final body expression\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>"
msgstr ""
"</p><p>\n"
"<a name=\"./syntax:s38\"></a><span class=\"formdef\"><b>syntax</b>: "
"<tt>(with-syntax&nbsp;((<i>pattern</i>&nbsp;<i>expr</i>)&nbsp;...)&nbsp;"
"<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt></span>\n"
"<br>\n"
"<b>returns: </b>значение последнего выражения body\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>"

#: syntax.html:1054
msgid ""
"</p><p>It is sometimes useful to construct a transformer's output in "
"separate\n"
"pieces, then put the pieces together.\n"
"<tt>with-syntax</tt> facilitates this by allowing the creation of local\n"
"pattern bindings."
msgstr ""
"</p><p>Иногда полезно построить выход преобразователя в отдельные части,\n"
"а затем собрать куски вместе.\n"
"<tt>with-syntax</tt> облегчает это, позволяя создавать локальные \n"
"привязки образцов."

#: syntax.html:1062
msgid ""
"</p><p>\n"
"<tt><i>pattern</i></tt> is identical in form to a <tt>syntax-case</tt> "
"pattern.\n"
"The value of each <tt><i>expr</i></tt> is computed and destructured "
"according\n"
"to the corresponding <tt><i>pattern</i></tt>, and pattern variables within\n"
"the <tt><i>pattern</i></tt> are bound as with <tt>syntax-case</tt> to "
"appropriate\n"
"portions of the value within the body <tt><i>body<sub>1</sub></i>&nbsp;"
"<i>body<sub>2</sub></i>&nbsp;...</tt>,\n"
"which is processed and evaluated like a <tt>lambda</tt> body."
msgstr ""
"</p><p>\n"
"<tt><i>pattern</i></tt> идентичен по форме образцу(patten) в <tt>syntax-"
"case</tt>.\n"
"Значение каждого выражения <tt><i>expr</i></tt> вычисляется и разбирается в "
"соответствии\n"
"с соответствующим образцом(<tt><i>pattern</i></tt>), а переменные образца в "
"образце\n"
"(<tt><i>pattern</i></tt>) связываются также как в <tt>syntax-case</tt> с "
"соответствующими\n"
"частями значенийя внутри тела <tt><i>body<sub>1</sub></i>&nbsp;"
"<i>body<sub>2</sub></i>&nbsp;...</tt>,\n"
"которые обрабатываются и вычисляются как тело <tt>lambda</tt>."

#: syntax.html:1066
msgid ""
"</p><p>\n"
"<tt>with-syntax</tt> may be defined as a syntactic extension in terms of\n"
"<tt>syntax-case</tt>."
msgstr ""
"</p><p>\n"
"<tt>with-syntax</tt> может быть определено как синтаксическое расширени в\n"
"терминах <tt>syntax-case</tt>."

#: syntax.html:1068
msgctxt "syntax.html:1068"
msgid "</p><p>"
msgstr ""

#: syntax.html:1070
msgid "</p><p><tt>(define-syntax&nbsp;with-syntax<br>"
msgstr ""

#: syntax.html:1072
msgctxt "syntax.html:1072"
msgid "&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:1074
msgctxt "syntax.html:1074"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:1076
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((p&nbsp;e)&nbsp;...)&nbsp;"
"b1&nbsp;b2&nbsp;...)<br>"
msgstr ""

#: syntax.html:1078
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(syntax-case&nbsp;(list&nbsp;"
"e&nbsp;...)&nbsp;()<br>"
msgstr ""

#: syntax.html:1083
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"[(p&nbsp;...)&nbsp;(let&nbsp;()&nbsp;b1&nbsp;b2&nbsp;...)])])))</tt>\n"
"</p><p>The following definition of full <a name=\"./syntax:s39\"></"
"a><tt>cond</tt>\n"
"demonstrates the use of <tt>with-syntax</tt> to support transformers\n"
"that employ recursion internally to construct their output."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"[(p&nbsp;...)&nbsp;(let&nbsp;()&nbsp;b1&nbsp;b2&nbsp;...)])])))</tt>\n"
"</p><p>Следующее определение полного <a name=\"./syntax:s39\"></a><tt>cond</"
"tt>\n"
"демонстрирует использование <tt>with-syntax</tt> для поддержки "
"преобразователей,\n"
"которые используют внутреннюю рекурсию для построения своего вывода."

#: syntax.html:1085
msgctxt "syntax.html:1085"
msgid "</p><p>"
msgstr ""

#: syntax.html:1087
msgid "</p><p><tt>(define-syntax&nbsp;cond<a name=\"defn:cond\"></a><br>"
msgstr ""

#: syntax.html:1089
msgctxt "syntax.html:1089"
msgid "&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:1091
msgctxt "syntax.html:1091"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:1093
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;c1&nbsp;c2&nbsp;...)<br>"
msgstr ""

#: syntax.html:1095
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([c1&nbsp;"
"#'c1]&nbsp;[cmore&nbsp;#'(c2&nbsp;...)])<br>"
msgstr ""

#: syntax.html:1097
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;"
"cmore)<br>"
msgstr ""

#: syntax.html:1099
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;(syntax-case&nbsp;c1&nbsp;(else&nbsp;=&gt;)<br>"
msgstr ""

#: syntax.html:1101
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;[(else&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;#'(begin&nbsp;"
"e1&nbsp;e2&nbsp;...)]<br>"
msgstr ""

#: syntax.html:1103
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;[(e0)&nbsp;#'(let&nbsp;([t&nbsp;e0])&nbsp;(if&nbsp;t&nbsp;"
"t))]<br>"
msgstr ""

#: syntax.html:1105
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;[(e0&nbsp;=&gt;&nbsp;e1)&nbsp;#'(let&nbsp;([t&nbsp;"
"e0])&nbsp;(if&nbsp;t&nbsp;(e1&nbsp;t)))]<br>"
msgstr ""

#: syntax.html:1107
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;[(e0&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;#'(if&nbsp;e0&nbsp;"
"(begin&nbsp;e1&nbsp;e2&nbsp;...))])<br>"
msgstr ""

#: syntax.html:1109
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;(with-syntax&nbsp;([rest&nbsp;(f&nbsp;(car&nbsp;cmore)&nbsp;(cdr&nbsp;"
"cmore))])<br>"
msgstr ""

#: syntax.html:1111
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;c1&nbsp;(=&gt;)<br>"
msgstr ""

#: syntax.html:1113
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(e0)&nbsp;#'(let&nbsp;([t&nbsp;e0])&nbsp;"
"(if&nbsp;t&nbsp;t&nbsp;rest))]<br>"
msgstr ""

#: syntax.html:1115
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(e0&nbsp;=&gt;&nbsp;e1)&nbsp;#'(let&nbsp;"
"([t&nbsp;e0])&nbsp;(if&nbsp;t&nbsp;(e1&nbsp;t)&nbsp;rest))]<br>"
msgstr ""

#: syntax.html:1117
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(e0&nbsp;e1&nbsp;e2&nbsp;...)<br>"
msgstr ""

#: syntax.html:1134
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(if&nbsp;e0&nbsp;(begin&nbsp;e1&nbsp;"
"e2&nbsp;...)&nbsp;rest)]))))])))</tt>\n"
"</p><p><a name=\"./syntax:s40\"></a><span class=\"formdef\"><b>syntax</b>: "
"<tt>(quasisyntax&nbsp;<i>template</i>&nbsp;...)</tt></span>\n"
"<br>\n"
"<span class=\"formdef\"><b>syntax</b>: <tt>#`<i>template</i></tt></span>\n"
"<br>\n"
"<span class=\"formdef\"><b>syntax</b>: <tt>(unsyntax&nbsp;<i>template</"
"i>&nbsp;...)</tt></span>\n"
"<br>\n"
"<span class=\"formdef\"><b>syntax</b>: <tt>#,<i>template</i></tt></span>\n"
"<br>\n"
"<span class=\"formdef\"><b>syntax</b>: <tt>(unsyntax-splicing&nbsp;"
"<i>template</i>&nbsp;...)</tt></span>\n"
"<br>\n"
"<span class=\"formdef\"><b>syntax</b>: <tt>#,@<i>template</i></tt></span>\n"
"<br>\n"
"<b>returns: </b>see below\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>"
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(if&nbsp;e0&nbsp;(begin&nbsp;e1&nbsp;"
"e2&nbsp;...)&nbsp;rest)]))))])))</tt>\n"
"</p><p><a name=\"./syntax:s40\"></a><span class=\"formdef\"><b>syntax</b>: "
"<tt>(quasisyntax&nbsp;<i>template</i>&nbsp;...)</tt></span>\n"
"<br>\n"
"<span class=\"formdef\"><b>syntax</b>: <tt>#`<i>template</i></tt></span>\n"
"<br>\n"
"<span class=\"formdef\"><b>syntax</b>: <tt>(unsyntax&nbsp;<i>template</"
"i>&nbsp;...)</tt></span>\n"
"<br>\n"
"<span class=\"formdef\"><b>syntax</b>: <tt>#,<i>template</i></tt></span>\n"
"<br>\n"
"<span class=\"formdef\"><b>syntax</b>: <tt>(unsyntax-splicing&nbsp;"
"<i>template</i>&nbsp;...)</tt></span>\n"
"<br>\n"
"<span class=\"formdef\"><b>syntax</b>: <tt>#,@<i>template</i></tt></span>\n"
"<br>\n"
"<b>returns: </b>смотри ниже\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>"

#: syntax.html:1141
msgid ""
"</p><p><tt>#`<i>template</i></tt> is equivalent to <tt>(quasisyntax&nbsp;"
"<i>template</i>)</tt>,\n"
"while\n"
"<tt>#,<i>template</i></tt> is equivalent to <tt>(unsyntax&nbsp;<i>template</"
"i>)</tt>, and\n"
"<tt>#,@<i>template</i></tt> to <tt>(unsyntax-splicing&nbsp;<i>template</i>)</"
"tt>.\n"
"The abbreviated forms are converted into the longer forms when the program\n"
"is read, prior to macro expansion."
msgstr ""
"</p><p><tt>#`<i>template</i></tt> эквивалентен <tt>(quasisyntax&nbsp;"
"<i>template</i>)</tt>,\n"
"в то время как\n"
"<tt>#,<i>template</i></tt> эквивалентен <tt>(unsyntax&nbsp;<i>template</i>)</"
"tt>, и\n"
"<tt>#,@<i>template</i></tt> эквивалентен <tt>(unsyntax-splicing&nbsp;"
"<i>template</i>)</tt>.\n"
"Сокращенные формы перобразуются в более длинные формы, когда программа "
"считывается,\n"
"до расширения макроса."

#: syntax.html:1146
msgid ""
"</p><p>\n"
"<tt>quasisyntax</tt> is similar to <tt>syntax</tt>, but it allows parts\n"
"of the quoted text to be evaluated, in a manner similar to\n"
"<tt>quasiquote</tt> (Section&nbsp;<a href=\"objects.html#g107\">6.1</a>)."
msgstr ""
"</p><p>\n"
"<tt>quasisyntax</tt> аналогичен <tt>syntax</tt>, но позволяет вычислять\n"
"части цитируемого текса способом, подобным\n"
"<tt>quasiquote</tt> (Раздел&nbsp;<a href=\"objects.html#g107\">6.1</a>)."

#: syntax.html:1158
msgid ""
"</p><p>\n"
"Within a <tt>quasisyntax</tt> <tt><i>template</i></tt>, subforms of\n"
"<tt>unsyntax</tt> and <tt>unsyntax-splicing</tt> forms are evaluated,\n"
"and everything else is treated as ordinary template material, as\n"
"with <tt>syntax</tt>.\n"
"The value of each <tt>unsyntax</tt> subform is inserted into the output\n"
"in place of the <tt>unsyntax</tt> form, while the value of each\n"
"<tt>unsyntax-splicing</tt> subform is spliced into the surrounding list\n"
"or vector structure.\n"
"<tt>unsyntax</tt> and <tt>unsyntax-splicing</tt> are valid only within\n"
"<tt>quasisyntax</tt> expressions."
msgstr ""
"</p><p>\n"
"В рамках шаблона <tt><i>template</i></tt> в <tt>quasisyntax</tt> , подформы\n"
"форм <tt>unsyntax</tt> и <tt>unsyntax-splicing</tt> вычисляются,\n"
"а все остальное рассматривается как обычный материал шаблона, как \n"
" <tt>syntax</tt>.\n"
"Значение каждой подформы <tt>unsyntax</tt> вставляется в выход\n"
"вместо формы <tt>unsyntax</tt>, тогда как значение каждой подформы\n"
"<tt>unsyntax-splicing</tt> разделяется в окружающий список или векторную\n"
"структуру.\n"
"<tt>unsyntax</tt> и <tt>unsyntax-splicing</tt> действительны только в\n"
"выражениях <tt>quasisyntax</tt>."

#: syntax.html:1166
msgid ""
"</p><p>\n"
"<tt>quasisyntax</tt> expressions may be nested, with each <tt>quasisyntax</"
"tt>\n"
"introducing a new level of syntax quotation and each <tt>unsyntax</tt> or\n"
"<tt>unsyntax-splicing</tt> taking away a level of quotation.\n"
"An expression nested within <i>n</i> <tt>quasisyntax</tt> expressions must\n"
"be within <i>n</i> <tt>unsyntax</tt> or <tt>unsyntax-splicing</tt> "
"expressions to\n"
"be evaluated."
msgstr ""
"</p><p>\n"
"Выражения <tt>quasisyntax</tt> могут быть вложенными, причем кадый "
"<tt>quasisyntax</tt>\n"
"вводит новый уровень синтаксического цитирования и каждый <tt>unsyntax</tt> "
"и\n"
"<tt>unsyntax-splicing</tt> убирают один уровень цитирования.\n"
"Выражение вложенное в <i>n</i> выражений <tt>quasisyntax</tt> должно быть в "
"пределах\n"
" <i>n</i> выражений <tt>unsyntax</tt> или <tt>unsyntax-splicing</tt> для "
"вычисления."

#: syntax.html:1175
msgid ""
"</p><p>\n"
"<tt>quasisyntax</tt> can be used in place of <tt>with-syntax</tt> in many\n"
"cases.\n"
"For example, the following definition of\n"
"<a name=\"./syntax:s41\"></a><tt>case</tt> employs <tt>quasisyntax</tt> to\n"
"construct its output, using internal recursion in a manner similar to the\n"
"definition of <tt>cond</tt> given under the description of\n"
"<tt>with-syntax</tt> above."
msgstr ""
"</p><p>\n"
"<tt>quasisyntax</tt> можно использовать вместо <tt>with-syntax</tt> во\n"
"многих случаях.\n"
"Например, в следующем определении\n"
"<a name=\"./syntax:s41\"></a><tt>case</tt> используется <tt>quasisyntax</tt> "
"для\n"
"построения выхода, с использованием внутренней рекурсии, способом "
"аналогичным\n"
"определению <tt>cond</tt> приведенному в описании\n"
"<tt>with-syntax</tt> выше."

#: syntax.html:1177
msgctxt "syntax.html:1177"
msgid "</p><p>"
msgstr ""

#: syntax.html:1179
msgid "</p><p><tt>(define-syntax&nbsp;case<a name=\"defn:case\"></a><br>"
msgstr ""

#: syntax.html:1181
msgctxt "syntax.html:1181"
msgid "&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:1183
msgctxt "syntax.html:1183"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:1185
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e&nbsp;c1&nbsp;c2&nbsp;...)<br>"
msgstr ""

#: syntax.html:1187
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#`(let&nbsp;([t&nbsp;e])<br>"
msgstr ""

#: syntax.html:1189
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#,"
"(let&nbsp;f&nbsp;([c1&nbsp;#'c1]&nbsp;[cmore&nbsp;#'(c2&nbsp;...)])<br>"
msgstr ""

#: syntax.html:1191
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;cmore)<br>"
msgstr ""

#: syntax.html:1193
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;c1&nbsp;"
"(else)<br>"
msgstr ""

#: syntax.html:1195
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(else&nbsp;e1&nbsp;"
"e2&nbsp;...)&nbsp;#'(begin&nbsp;e1&nbsp;e2&nbsp;...)]<br>"
msgstr ""

#: syntax.html:1197
msgctxt "syntax.html:1197"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[((k&nbsp;...)&nbsp;"
"e1&nbsp;e2&nbsp;...)<br>"
msgstr ""

#: syntax.html:1199
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(if&nbsp;"
"(memv&nbsp;t&nbsp;'(k&nbsp;...))&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...))])<br>"
msgstr ""

#: syntax.html:1201
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;c1&nbsp;()<br>"
msgstr ""

#: syntax.html:1203
msgctxt "syntax.html:1203"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[((k&nbsp;...)&nbsp;"
"e1&nbsp;e2&nbsp;...)<br>"
msgstr ""

#: syntax.html:1205
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#`(if&nbsp;"
"(memv&nbsp;t&nbsp;'(k&nbsp;...))<br>"
msgstr ""

#: syntax.html:1207
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...)<br>"
msgstr ""

#: syntax.html:1223
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;#,(f&nbsp;(car&nbsp;cmore)&nbsp;(cdr&nbsp;"
"cmore)))]))))])))</tt>\n"
"</p><p><tt>unsyntax</tt> and <tt>unsyntax-splicing</tt> forms that contain\n"
"zero or more than\n"
"one subform are valid only in splicing (list or vector) contexts.\n"
"<tt>(unsyntax&nbsp;<i>template</i>&nbsp;...)</tt> is equivalent to\n"
"<tt>(unsyntax&nbsp;<i>template</i>)&nbsp;...</tt>, and\n"
"<tt>(unsyntax-splicing&nbsp;<i>template</i>&nbsp;...)</tt> is equivalent to\n"
"<tt>(unsyntax-splicing&nbsp;<i>template</i>)&nbsp;...</tt>.\n"
"These forms are primarily useful as intermediate forms in the output\n"
"of the <tt>quasisyntax</tt> expander.\n"
"They support certain useful nested quasiquotation (<tt>quasisyntax</tt>)\n"
"idioms&nbsp;[<a class=\"citation\" href=\"bibliography.html#g221\">3</a>], "
"such as <tt>#,@#,@</tt>, which has the\n"
"effect of a doubly indirect splicing when used within a doubly nested\n"
"and doubly evaluated <tt>quasisyntax</tt> expression, as with the\n"
"nested <tt>quasiquote</tt> examples shown in Section&nbsp;<a href=\"objects."
"html#g107\">6.1</a>."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;#,(f&nbsp;(car&nbsp;cmore)&nbsp;(cdr&nbsp;"
"cmore)))]))))])))</tt>\n"
"Формы </p><p><tt>unsyntax</tt> и <tt>unsyntax-splicing</tt> которые "
"содержат\n"
"ноль или больше чем одну подформу, действительны только\n"
"в соединяемом контексте (список или вектор).\n"
"<tt>(unsyntax&nbsp;<i>template</i>&nbsp;...)</tt> эквивалентен\n"
"<tt>(unsyntax&nbsp;<i>template</i>)&nbsp;...</tt>, и\n"
"<tt>(unsyntax-splicing&nbsp;<i>template</i>&nbsp;...)</tt> является "
"эквивалентным\n"
"<tt>(unsyntax-splicing&nbsp;<i>template</i>)&nbsp;...</tt>.\n"
"Эти формы в первую очередь полезны в качестве промежуточных форм \n"
"в выходе расширителя <tt>quasisyntax</tt>.\n"
"Они поддерживают вложенные идиомы квазицитирование(quasiquotation "
"(<tt>quasisyntax</tt>))\n"
"&nbsp;[<a class=\"citation\" href=\"bibliography.html#g221\">3</a>], такие "
"как <tt>#,@#,@</tt>, \n"
"что приводит к двойному непрямому соединению, при использовании двойного\n"
"вложения и двойного вычисления выражения <tt>quasisyntax</tt>, как и с\n"
"вложением <tt>quasiquote</tt> в примерах показанных в Разделе\n"
"&nbsp;<a href=\"objects.html#g107\">6.1</a>."

#: syntax.html:1229
msgid ""
"</p><p>\n"
"<tt>unsyntax</tt> and <tt>unsyntax-splicing</tt> are auxiliary keywords for\n"
"<tt>quasisyntax</tt>.\n"
"It is a syntax violation to reference these identifiers except in contexts\n"
"where they are recognized as auxiliary keywords."
msgstr ""
"</p><p>\n"
"<tt>unsyntax</tt> и <tt>unsyntax-splicing</tt> являются вспомогательными\n"
"ключевыми словами для <tt>quasisyntax</tt>.\n"
"Будет нарушением синтаксиса ссылаться на эти идентификаторы, за \n"
"исключением случаев, где они распознаются как вспомогательные ключевые слова."

#: syntax.html:1237
msgid ""
"</p><p>\n"
"<a name=\"./syntax:s42\"></a><a name=\"desc:make-variable-transformer\"></"
"a>\n"
"<span class=\"formdef\"><b>procedure</b>: <tt>(make-variable-"
"transformer&nbsp;<i>procedure</i>)</tt></span>\n"
"<br>\n"
"<b>returns: </b>a variable transformer\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>"
msgstr ""
"</p><p>\n"
"<a name=\"./syntax:s42\"></a><a name=\"desc:make-variable-transformer\"></"
"a>\n"
"<span class=\"formdef\"><b>procedure</b>: <tt>(make-variable-"
"transformer&nbsp;<i>procedure</i>)</tt></span>\n"
"<br>\n"
"<b>returns: </b>преобразователь переменной\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>"

#: syntax.html:1252
msgid ""
"</p><p>As described in the lead-in to this section, transformers may simply "
"be\n"
"procedures that accept one argument,\n"
"a syntax object representing the input form, and return a new syntax object\n"
"representing the output form.\n"
"The form passed to a transformer usually represents a parenthesized form "
"whose\n"
"first subform is the keyword bound to the transformer or just the keyword\n"
"itself.\n"
"<tt>make-variable-transformer</tt> may be used to convert a procedure into\n"
"a special kind of transformer to which the expander also passes <tt>set!</"
"tt>\n"
"forms in which the keyword appears just after the <tt>set!</tt> keyword, as\n"
"if it were a variable to be assigned.\n"
"This allows the programmer to control what happens when the keyword appears\n"
"in such contexts.\n"
"The argument, <tt><i>procedure</i></tt>, should accept one argument."
msgstr ""
"</p><p>Как описано в начале этого раздела, преобразователи могут просто "
"быть\n"
"процедурами, которые принимают один аргумент,\n"
"синтаксический объект представляющий собой входную форму, и возвращают\n"
"новый синтаксический объект, представляющий выходную форму.\n"
"Форма, передаваемая преобразователю, обычно представляет собой\n"
"форму в скобках, первая подформа которой является ключевым словом,\n"
"связанным с преобразователем или просто ключевым словом.\n"
"<tt>make-variable-transformer</tt> может использоваться для преобразования "
"процедуры\n"
"в специальный вид преобразователя, к которому расширитель также добавляет\n"
"ключевое слово <tt>set!</tt>, в котором ключевое слово появляется сразу "
"после\n"
"<tt>set!</tt>, как если бы это было присваивание переменной.\n"
"Это позволяет программисту контролировать, что происходит, когда ключевое "
"слово\n"
"появляется в таких контекстах.\n"
"Аргумент, <tt><i>procedure</i></tt>, должен принимать один аргумент."

#: syntax.html:1254
msgctxt "syntax.html:1254"
msgid "</p><p>"
msgstr ""

#: syntax.html:1256
msgctxt "syntax.html:1256"
msgid "</p><p><tt>(let&nbsp;([ls&nbsp;(list&nbsp;0)])<br>"
msgstr ""

#: syntax.html:1258
msgctxt "syntax.html:1258"
msgid "&nbsp;&nbsp;(define-syntax&nbsp;a<br>"
msgstr ""

#: syntax.html:1260
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(make-variable-transformer<br>"
msgstr ""

#: syntax.html:1262
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:1264
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;"
"()<br>"
msgstr ""

#: syntax.html:1266
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[id&nbsp;"
"(identifier?&nbsp;#'id)&nbsp;#'(car&nbsp;ls)]<br>"
msgstr ""

#: syntax.html:1268
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(set!&nbsp;"
"_&nbsp;e)&nbsp;#'(set-car!&nbsp;ls&nbsp;e)]<br>"
msgstr ""

#: syntax.html:1270
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;"
"e&nbsp;...)&nbsp;#'((car&nbsp;ls)&nbsp;e&nbsp;...)]))))<br>"
msgstr ""

#: syntax.html:1272
msgctxt "syntax.html:1272"
msgid "&nbsp;&nbsp;(let&nbsp;([before&nbsp;a])<br>"
msgstr ""

#: syntax.html:1274
msgctxt "syntax.html:1274"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;a&nbsp;1)<br>"
msgstr ""

#: syntax.html:1284
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;before&nbsp;a&nbsp;ls)))&nbsp;<img src="
"\"./syntax_files/0.gif\" alt=\"&lt;graphic&gt;\">&nbsp;(0&nbsp;1&nbsp;(1))</"
"tt>\n"
"</p><p><a name=\"./syntax:s43\"></a>This syntactic abstraction can be "
"defined more succinctly using\n"
"<tt>identifier-syntax</tt>, as shown in Section&nbsp;<a href=\"syntax."
"html#g135\">8.2</a>,\n"
"but <tt>make-variable-transformer</tt> can be used to create\n"
"transformers that perform arbitrary computations, while\n"
"<tt>identifier-syntax</tt> is limited to simple term rewriting,\n"
"like <tt>syntax-rules</tt>.\n"
"<tt>identifier-syntax</tt> can be defined\n"
"in terms of <tt>make-variable-transformer</tt>, as shown below."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;before&nbsp;a&nbsp;ls)))&nbsp;<img src="
"\"./syntax_files/0.gif\" alt=\"&lt;graphic&gt;\">&nbsp;(0&nbsp;1&nbsp;(1))</"
"tt>\n"
"</p><p><a name=\"./syntax:s43\"></a>Эта синтаксическая абстракция может быть "
"определена более\n"
"кратко с использованием <tt>identifier-syntax</tt>, \n"
"как показано в разделе&nbsp;<a href=\"syntax.html#g135\">8.2</a>,\n"
"но <tt>make-variable-transformer</tt> может использоваться для создания\n"
"преобразователей, которые выполняют произвольные вычисления, тогда \n"
"как <tt>identifier-syntax</tt> ограничивается простым переписыванием\n"
"терминов, подобно  <tt>syntax-rules</tt>.\n"
"<tt>identifier-syntax</tt> может быть определен в терминах\n"
" <tt>make-variable-transformer</tt>, как показано ниже."

#: syntax.html:1286
msgctxt "syntax.html:1286"
msgid "</p><p>"
msgstr ""

#: syntax.html:1288
msgid ""
"</p><p><tt>(define-syntax&nbsp;identifier-syntax<a name=\"defn:identifier-"
"syntax\"></a><br>"
msgstr ""

#: syntax.html:1290
msgctxt "syntax.html:1290"
msgid "&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:1292
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;(set!)<br>"
msgstr ""

#: syntax.html:1294
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e)<br>"
msgstr ""

#: syntax.html:1296
msgctxt "syntax.html:1296"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:1298
msgctxt "syntax.html:1298"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-"
"case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:1300
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;[id&nbsp;(identifier?&nbsp;#'id)&nbsp;#'e]<br>"
msgstr ""

#: syntax.html:1302
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;[(_&nbsp;x&nbsp;(...&nbsp;...))&nbsp;#'(e&nbsp;x&nbsp;(..."
"&nbsp;...))]))]<br>"
msgstr ""

#: syntax.html:1304
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(id&nbsp;exp1)&nbsp;((set!&nbsp;"
"var&nbsp;val)&nbsp;exp2))<br>"
msgstr ""

#: syntax.html:1306
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(identifier?&nbsp;"
"#'id)&nbsp;(identifier?&nbsp;#'var))<br>"
msgstr ""

#: syntax.html:1308
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(make-variable-transformer<br>"
msgstr ""

#: syntax.html:1310
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:1312
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;(syntax-case&nbsp;x&nbsp;(set!)<br>"
msgstr ""

#: syntax.html:1314
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;[(set!&nbsp;var&nbsp;val)&nbsp;#'exp2]<br>"
msgstr ""

#: syntax.html:1316
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;[(id&nbsp;x&nbsp;(...&nbsp;...))&nbsp;#'(exp1&nbsp;x&nbsp;"
"(...&nbsp;...))]<br>"
msgstr ""

#: syntax.html:1323
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;[id&nbsp;(identifier?&nbsp;#'id)&nbsp;#'exp1])))])))</tt>\n"
"</p><p><a name=\"./syntax:s44\"></a><span class=\"formdef\"><b>procedure</"
"b>: <tt>(syntax-&gt;datum&nbsp;<i>obj</i>)</tt></span>\n"
"<br>\n"
"<b>returns: </b><tt><i>obj</i></tt> stripped of syntactic information\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>"
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;[id&nbsp;(identifier?&nbsp;#'id)&nbsp;#'exp1])))])))</tt>\n"
"</p><p><a name=\"./syntax:s44\"></a><span class=\"formdef\"><b>procedure</"
"b>: <tt>(syntax-&gt;datum&nbsp;<i>obj</i>)</tt></span>\n"
"<br>\n"
"<b>returns: </b><tt><i>obj</i></tt> лишенный синтаксической информации\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>"

#: syntax.html:1330
msgid ""
"</p><p>The procedure <tt>syntax-&gt;datum</tt>\n"
"strips all syntactic information from a syntax\n"
"object and returns the corresponding Scheme \"datum.\"\n"
"Identifiers stripped in this manner are converted to their symbolic\n"
"names, which can then be compared with <tt>eq?</tt>.\n"
"Thus, a predicate <tt>symbolic-identifier=?</tt> might be defined as follows."
msgstr ""
"</p><p>Процедура <tt>syntax-&gt;datum</tt>\n"
"удаляет всю синтаксическую информацию из синтаксического объекта\n"
"и возвращает соответствующий объект(\"datum\") Scheme. \n"
"Идентификаторы, разделенные таким образом, преобразуются в их\n"
"символические имена, которые затем можно сравнивать  используя <tt>eq?</"
"tt>.\n"
"Таким образом, предикат <tt>symbolic-identifier=?</tt> может быть определен\n"
"следующим образом."

#: syntax.html:1332
msgctxt "syntax.html:1332"
msgid "</p><p>"
msgstr ""

#: syntax.html:1334
msgid "</p><p><tt>(define&nbsp;symbolic-identifier=?<br>"
msgstr ""

#: syntax.html:1336
msgid "&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)<br>"
msgstr ""

#: syntax.html:1338
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(eq?&nbsp;(syntax-&gt;datum&nbsp;x)<br>"
msgstr ""

#: syntax.html:1346
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-&gt;datum&nbsp;"
"y))))</tt>\n"
"</p><p>Two identifiers that are <tt>free-identifier=?</tt> need not be\n"
"<tt>symbolic-identifier=?</tt>: two identifiers that refer to the\n"
"same binding usually have the same name, but the <tt>rename</tt> and\n"
"<tt>prefix</tt> subforms of the library's <tt>import</tt> form\n"
"(page&nbsp;<a href=\"libraries.html#desc:import\">345</a>) may\n"
"result in two identifiers with different names but the same binding."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-&gt;datum&nbsp;"
"y))))</tt>\n"
"</p><p>Двум идентификаторам, которые являются <tt>free-identifier=?</tt> "
"необязательно\n"
"быть <tt>symbolic-identifier=?</tt>: два идентификатора которые ссылаются на "
"одну\n"
"и туже привязку, обычно имеют одно и тоже имя, но субформы <tt>rename</tt> "
"и\n"
"<tt>prefix</tt> библиотечной формы <tt>import</tt>\n"
"(страница&nbsp;<a href=\"libraries.html#desc:import\">345</a>) могут\n"
"приводить к двум идентификаторам с разными именами."

#: syntax.html:1353
msgid ""
"</p><p>\n"
"<a name=\"./syntax:s45\"></a><span class=\"formdef\"><b>procedure</b>: "
"<tt>(datum-&gt;syntax&nbsp;<i>template-identifier</i>&nbsp;<i>obj</i>)</tt></"
"span>\n"
"<br>\n"
"<b>returns: </b>a syntax object\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>"
msgstr ""
"</p><p>\n"
"<a name=\"./syntax:s45\"></a><span class=\"formdef\"><b>procedure</b>: "
"<tt>(datum-&gt;syntax&nbsp;<i>template-identifier</i>&nbsp;<i>obj</i>)</tt></"
"span>\n"
"<br>\n"
"<b>returns: </b>синтаксический объект\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>"

#: syntax.html:1363
msgid ""
"</p><p><tt>datum-&gt;syntax</tt> constructs a syntax object from <tt><i>obj</"
"i></tt> that\n"
"contains the same contextual information as\n"
"<tt><i>template-identifier</i></tt>, with the effect that the\n"
"syntax object behaves\n"
"as if it were introduced into the code when\n"
"<tt><i>template-identifier</i></tt> was introduced.\n"
"The template identifier is often the keyword of an input form,\n"
"extracted from the form, and the object is often a symbol naming an\n"
"identifier to be constructed."
msgstr ""
"</p><p><tt>datum-&gt;syntax</tt> создает синтаксический объект из "
"<tt><i>obj</i></tt>,\n"
"который содержит ту же контекстную информацию, что и\n"
"<tt><i>template-identifier</i></tt>, с тем эффектом что\n"
"синтаксический объект ведет себя так, как если бы он был введен\n"
"в код при вводе\n"
"<tt><i>template-identifier</i></tt>.\n"
"Идентификатор шаблона(template identifier) часто является ключевым словом\n"
"входной формы, извлекаемый из формы, и объект часто является символом,\n"
"именующиий(обозначающий) идентификатор, который должен быть сконструирован."

#: syntax.html:1374
msgid ""
"</p><p>\n"
"<tt>datum-&gt;syntax</tt> allows a transformer to \"bend\" lexical\n"
"scoping rules by creating <i>implicit identifiers</i>\n"
"that behave as if they were present in the input form,\n"
"thus permitting the definition of syntactic\n"
"extensions that introduce visible bindings for or references to\n"
"identifiers that do not appear explicitly in the input form.\n"
"For example, we can define a <a name=\"./syntax:s46\"></a><tt>loop</tt> "
"expression that\n"
"binds the variable <a name=\"./syntax:s47\"></a><tt>break</tt> to an escape "
"procedure\n"
"within the loop body."
msgstr ""
"</p><p>\n"
"<tt>datum-&gt;syntax</tt> позволяет преобразователю \"изгибать\"(\"bend\") \n"
"лексический охват правил, создавая  неявные идентификаторы(<i>implicit "
"identifiers</i>),\n"
"которые ведут себя так, как если бы они присутствовали во входной форме,\n"
"что позволяет определять синтаксические расширения, которые\n"
"вносят видимые привязки или ссылки на идентификаторы,\n"
"которые не появляются явно в входной форме.\n"
"Например, мы можем определить выражение<a name=\"./syntax:s46\"></"
"a><tt>loop</tt> которое\n"
"связывает переменную <a name=\"./syntax:s47\"></a><tt>break</tt> с "
"процедурой побега(escape)\n"
"из тела цикла."

#: syntax.html:1376
msgctxt "syntax.html:1376"
msgid "</p><p>"
msgstr ""

#: syntax.html:1378
msgctxt "syntax.html:1378"
msgid "</p><p><tt>(define-syntax&nbsp;loop<br>"
msgstr ""

#: syntax.html:1380
msgctxt "syntax.html:1380"
msgid "&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:1382
msgctxt "syntax.html:1382"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:1384
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(k&nbsp;e&nbsp;...)<br>"
msgstr ""

#: syntax.html:1386
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;([break&nbsp;"
"(datum-&gt;syntax&nbsp;#'k&nbsp;'break)])<br>"
msgstr ""

#: syntax.html:1388
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(call/cc<br>"
msgstr ""

#: syntax.html:1390
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;(lambda&nbsp;(break)<br>"
msgstr ""

#: syntax.html:1395
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;()&nbsp;e&nbsp;...&nbsp;(f)))))])))\n"
"<br>\n"
"<br>\n"
"(let&nbsp;([n&nbsp;3]&nbsp;[ls&nbsp;'()])<br>"
msgstr ""

#: syntax.html:1397
msgid "&nbsp;&nbsp;(loop<br>"
msgstr ""

#: syntax.html:1399
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)&nbsp;(break&nbsp;ls))<br>"
msgstr ""

#: syntax.html:1401
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;ls&nbsp;(cons&nbsp;'a&nbsp;ls))<br>"
msgstr ""

#: syntax.html:1404
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;n&nbsp;(-&nbsp;n&nbsp;1))))&nbsp;<img src="
"\"./syntax_files/0.gif\" alt=\"&lt;graphic&gt;\">&nbsp;(a&nbsp;a&nbsp;a)</"
"tt>\n"
"</p><p>Were we to define <tt>loop</tt> as"
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;n&nbsp;(-&nbsp;n&nbsp;1))))&nbsp;<img src="
"\"./syntax_files/0.gif\" alt=\"&lt;graphic&gt;\">&nbsp;(a&nbsp;a&nbsp;a)</"
"tt>\n"
"</p><p>Где мы определяем  <tt>loop</tt> как"

#: syntax.html:1406
msgctxt "syntax.html:1406"
msgid "</p><p>"
msgstr ""

#: syntax.html:1408
msgctxt "syntax.html:1408"
msgid "</p><p><tt>(define-syntax&nbsp;loop<br>"
msgstr ""

#: syntax.html:1410
msgctxt "syntax.html:1410"
msgid "&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:1412
msgctxt "syntax.html:1412"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:1414
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e&nbsp;...)<br>"
msgstr ""

#: syntax.html:1416
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(call/cc<br>"
msgstr ""

#: syntax.html:1418
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"(lambda&nbsp;(break)<br>"
msgstr ""

#: syntax.html:1421
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;(let&nbsp;f&nbsp;()&nbsp;e&nbsp;...&nbsp;(f))))])))</tt>\n"
"</p><p>the variable <tt>break</tt> would not be visible in <tt>e&nbsp;...</"
"tt>."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;(let&nbsp;f&nbsp;()&nbsp;e&nbsp;...&nbsp;(f))))])))</tt>\n"
"</p><p>переменная  <tt>break</tt> не будет видна в <tt>e&nbsp;...</tt>."

#: syntax.html:1426
msgid ""
"</p><p>\n"
"It is also useful for <tt><i>obj</i></tt> to represent an arbitrary\n"
"Scheme form, as demonstrated by the following definition of\n"
"<a name=\"./syntax:s48\"></a><tt>include</tt>."
msgstr ""
"</p><p>\n"
"Так же полезно, чтобы <tt><i>obj</i></tt> представлял произвольную\n"
"форму Scheme, как показано в следующем определении\n"
"<a name=\"./syntax:s48\"></a><tt>include</tt>."

#: syntax.html:1428
msgctxt "syntax.html:1428"
msgid "</p><p>"
msgstr ""

#: syntax.html:1430
msgid "</p><p><tt>(define-syntax&nbsp;include<br>"
msgstr ""

#: syntax.html:1432
msgctxt "syntax.html:1432"
msgid "&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:1434
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;read-file<br>"
msgstr ""

#: syntax.html:1436
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(fn&nbsp;k)<br>"
msgstr ""

#: syntax.html:1438
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([p&nbsp;(open-"
"input-file&nbsp;fn)])<br>"
msgstr ""

#: syntax.html:1440
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;"
"([x&nbsp;(read&nbsp;p)])<br>"
msgstr ""

#: syntax.html:1442
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"(if&nbsp;(eof-object?&nbsp;x)<br>"
msgstr ""

#: syntax.html:1444
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(close-port&nbsp;p)&nbsp;'())<br>"
msgstr ""

#: syntax.html:1446
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(datum-&gt;syntax&nbsp;k&nbsp;x)&nbsp;"
"(f&nbsp;(read&nbsp;p))))))))<br>"
msgstr ""

#: syntax.html:1448
msgctxt "syntax.html:1448"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:1450
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(k&nbsp;filename)<br>"
msgstr ""

#: syntax.html:1452
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([fn&nbsp;(syntax-&gt;"
"datum&nbsp;#'filename)])<br>"
msgstr ""

#: syntax.html:1454
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;"
"([(expr&nbsp;...)&nbsp;(read-file&nbsp;fn&nbsp;#'k)])<br>"
msgstr ""

#: syntax.html:1461
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"#'(begin&nbsp;expr&nbsp;...)))])))</tt>\n"
"</p><p><tt>(include&nbsp;\"filename\")</tt> expands into a <tt>begin</tt> "
"expression\n"
"containing the forms found in the file named by\n"
"<tt>\"filename\"</tt>.\n"
"For example, if the file <tt>f-def.ss</tt> contains the expression\n"
"<tt>(define&nbsp;f&nbsp;(lambda&nbsp;()&nbsp;x))</tt>, the expression"
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"#'(begin&nbsp;expr&nbsp;...)))])))</tt>\n"
"</p><p><tt>(include&nbsp;\"filename\")</tt> расширяется в выражение "
"<tt>begin</tt>\n"
"содержащее формы найденые в файле с именем\n"
"<tt>\"filename\"</tt>.\n"
"Например, если файл <tt>f-def.ss</tt> содержит выражение\n"
"<tt>(define&nbsp;f&nbsp;(lambda&nbsp;()&nbsp;x))</tt>, выражение"

#: syntax.html:1463
msgctxt "syntax.html:1463"
msgid "</p><p>"
msgstr ""

#: syntax.html:1465
msgid "</p><p><tt>(let&nbsp;([x&nbsp;\"okay\"])<br>"
msgstr ""

#: syntax.html:1467
msgid "&nbsp;&nbsp;(include&nbsp;\"f-def.ss\")<br>"
msgstr ""

#: syntax.html:1470
msgid ""
"&nbsp;&nbsp;(f))</tt>\n"
"</p><p>evaluates to <tt>\"okay\"</tt>."
msgstr ""
"&nbsp;&nbsp;(f))</tt>\n"
"</p><p>вычисляется с результатом <tt>\"okay\"</tt>."

#: syntax.html:1476
msgid ""
"</p><p>\n"
"The definition of <tt>include</tt> uses <tt>datum-&gt;syntax</tt> to "
"convert\n"
"the objects read from the file into syntax objects in the proper\n"
"lexical context, so that identifier references and definitions within\n"
"those expressions are scoped where the <tt>include</tt> form appears."
msgstr ""
"</p><p>\n"
"В определении <tt>include</tt> используется <tt>datum-&gt;syntax</tt> для\n"
"преобразования объектов, считанных из файла, в синтаксические объекты в\n"
"правильном лексическом контексте, так что ссылки и определения "
"идентификаторов\n"
"в этих выражениях имеют область видимости, где появляется форма <tt>include</"
"tt>."

#: syntax.html:1483
msgid ""
"</p><p>\n"
"<a name=\"./syntax:s49\"></a><span class=\"formdef\"><b>procedure</b>: "
"<tt>(generate-temporaries&nbsp;<i>list</i>)</tt></span>\n"
"<br>\n"
"<b>returns: </b>a list of distinct generated identifiers\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>"
msgstr ""
"</p><p>\n"
"<a name=\"./syntax:s49\"></a><span class=\"formdef\"><b>procedure</b>: "
"<tt>(generate-temporaries&nbsp;<i>list</i>)</tt></span>\n"
"<br>\n"
"<b>returns: </b>a список отдельных сгенерированных идентификаторов\n"
"<br>\n"
"<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>"

#: syntax.html:1494
msgid ""
"</p><p>Transformers can introduce a fixed number of identifiers into their\n"
"output by naming each identifier.\n"
"In some cases, however, the number of identifiers to be introduced depends\n"
"upon some characteristic of the input expression.\n"
"A straightforward definition of <tt>letrec</tt>, for example,\n"
"requires as many\n"
"temporary identifiers as there are binding pairs in the\n"
"input expression.\n"
"The procedure <tt>generate-temporaries</tt> is used to construct\n"
"lists of temporary identifiers."
msgstr ""
"</p><p>Преобразователи могут вводить фиксированное количество "
"иденификаторов\n"
"в свой вывод, именуя каждый идентификатор.\n"
"Однако, в некторых случаях, количество вводимых идентификаторов зависит\n"
"от некторой харастеристики входного выражения.\n"
"Простое определение <tt>letrec</tt>, например,\n"
"требует так много идентификаторов, сколько есть пар привязок\n"
"во входном выражении.\n"
"Процедура <tt>generate-temporaries</tt> используется для создания\n"
"списка временных идентификаторов."

#: syntax.html:1501
msgid ""
"</p><p>\n"
"<tt><i>list</i></tt> may be any list; its contents are not important.\n"
"The number of temporaries generated is the number of elements\n"
"in <tt><i>list</i></tt>.\n"
"Each temporary is guaranteed to be different from all other\n"
"identifiers."
msgstr ""
"</p><p>\n"
"<tt><i>list</i></tt> может быть любым списком; его содержание не имеет "
"значения.\n"
"Количество созданных временных элементов равно количеству элеметов в  "
"<tt><i>list</i></tt>.\n"
"Каждый временный идентификатор гарантированно отличается от всех других\n"
"идентификаторов."

#: syntax.html:1505
msgid ""
"</p><p>\n"
"A definition of <a name=\"./syntax:s50\"></a><tt>letrec</tt> that\n"
"uses <tt>generate-temporaries</tt> is shown below."
msgstr ""
"</p><p>\n"
"Ниже приведено определение <a name=\"./syntax:s50\"></a><tt>letrec</tt>, "
"которое\n"
"использует <tt>generate-temporaries</tt>."

#: syntax.html:1507
msgctxt "syntax.html:1507"
msgid "</p><p>"
msgstr ""

#: syntax.html:1509
msgid "</p><p><tt>(define-syntax&nbsp;letrec<a name=\"defn:letrec\"></a><br>"
msgstr ""

#: syntax.html:1511
msgctxt "syntax.html:1511"
msgid "&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:1513
msgctxt "syntax.html:1513"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:1515
msgctxt "syntax.html:1515"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((i&nbsp;e)&nbsp;...)&nbsp;"
"b1&nbsp;b2&nbsp;...)<br>"
msgstr ""

#: syntax.html:1517
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;"
"([(t&nbsp;...)&nbsp;(generate-temporaries&nbsp;#'(i&nbsp;...))])<br>"
msgstr ""

#: syntax.html:1519
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(let&nbsp;([i&nbsp;"
"#f]&nbsp;...)<br>"
msgstr ""

#: syntax.html:1521
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;(let&nbsp;([t&nbsp;e]&nbsp;...)<br>"
msgstr ""

#: syntax.html:1523
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;(set!&nbsp;i&nbsp;t)<br>"
msgstr ""

#: syntax.html:1525
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;...<br>"
msgstr ""

#: syntax.html:1535
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;(let&nbsp;()&nbsp;b1&nbsp;b2&nbsp;...))))])))</tt>\n"
"</p><p>Any transformer that uses <tt>generate-temporaries</tt> in this "
"fashion can\n"
"be rewritten to avoid using it, albeit with a loss of clarity.\n"
"The trick is to use a recursively defined intermediate form that\n"
"generates one temporary per expansion step and completes the\n"
"expansion after enough temporaries have been generated.\n"
"<a name=\"fullletvalues\"></a>Here is a definition of <a name=\"./syntax:"
"s51\"></a><tt>let-values</tt>\n"
"(page&nbsp;<a href=\"binding.html#desc:let-values\">99</a>) that uses this "
"technique to support\n"
"multiple sets of bindings."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;(let&nbsp;()&nbsp;b1&nbsp;b2&nbsp;...))))])))</tt>\n"
"</p><p>Любой преобразователь, который использует <tt>generate-temporaries</"
"tt> таким образом, может быть\n"
"переписан, чтобы избежать его использования, хотя и с потерей ясности.\n"
"Хитрость заключается в использовании рекурсивно определенной промежуточной "
"формы,\n"
"которая генерирует один временный идентификатор на один шаг расширения и\n"
"завершает расширение после создания достаточного количества временных "
"идентификаторов.\n"
"<a name=\"fullletvalues\"></a>Вот определение <a name=\"./syntax:s51\"></"
"a><tt>let-values</tt>\n"
"(page&nbsp;<a href=\"binding.html#desc:let-values\">99</a>) которое "
"использует этот метод\n"
"для поддержки нескольких наборов привязок."

#: syntax.html:1537
msgctxt "syntax.html:1537"
msgid "</p><p>"
msgstr ""

#: syntax.html:1539
msgid "</p><p><tt>(define-syntax&nbsp;let-values<br>"
msgstr ""

#: syntax.html:1541
msgctxt "syntax.html:1541"
msgid "&nbsp;&nbsp;(syntax-rules&nbsp;()<br>"
msgstr ""

#: syntax.html:1543
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;()&nbsp;f1&nbsp;f2&nbsp;...)&nbsp;(let&nbsp;"
"()&nbsp;f1&nbsp;f2&nbsp;...)]<br>"
msgstr ""

#: syntax.html:1545
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((fmls1&nbsp;expr1)&nbsp;(fmls2&nbsp;"
"expr2)&nbsp;...)&nbsp;f1&nbsp;f2&nbsp;...)<br>"
msgstr ""

#: syntax.html:1550
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lvhelp&nbsp;fmls1&nbsp;()&nbsp;()&nbsp;"
"expr1&nbsp;((fmls2&nbsp;expr2)&nbsp;...)&nbsp;(f1&nbsp;f2&nbsp;...))]))\n"
"<br>\n"
"<br>\n"
"(define-syntax&nbsp;lvhelp<br>"
msgstr ""

#: syntax.html:1552
msgctxt "syntax.html:1552"
msgid "&nbsp;&nbsp;(syntax-rules&nbsp;()<br>"
msgstr ""

#: syntax.html:1554
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(x1&nbsp;.&nbsp;fmls)&nbsp;"
"(x&nbsp;...)&nbsp;(t&nbsp;...)&nbsp;e&nbsp;m&nbsp;b)<br>"
msgstr ""

#: syntax.html:1556
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lvhelp&nbsp;fmls&nbsp;(x&nbsp;...&nbsp;"
"x1)&nbsp;(t&nbsp;...&nbsp;tmp)&nbsp;e&nbsp;m&nbsp;b)]<br>"
msgstr ""

#: syntax.html:1558
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;()&nbsp;(x&nbsp;...)&nbsp;(t&nbsp;...)&nbsp;"
"e&nbsp;m&nbsp;b)<br>"
msgstr ""

#: syntax.html:1560
msgctxt "syntax.html:1560"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(call-with-values<br>"
msgstr ""

#: syntax.html:1562
msgctxt "syntax.html:1562"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;e)<br>"
msgstr ""

#: syntax.html:1564
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(t&nbsp;...)<br>"
msgstr ""

#: syntax.html:1566
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let-values&nbsp;"
"m&nbsp;(let&nbsp;([x&nbsp;t]&nbsp;...)&nbsp;.&nbsp;b))))]<br>"
msgstr ""

#: syntax.html:1568
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;xr&nbsp;(x&nbsp;...)&nbsp;(t&nbsp;...)&nbsp;"
"e&nbsp;m&nbsp;b)<br>"
msgstr ""

#: syntax.html:1570
msgctxt "syntax.html:1570"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(call-with-values<br>"
msgstr ""

#: syntax.html:1572
msgctxt "syntax.html:1572"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;e)<br>"
msgstr ""

#: syntax.html:1574
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(t&nbsp;...&nbsp;."
"&nbsp;tmpr)<br>"
msgstr ""

#: syntax.html:1580
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let-values&nbsp;"
"m&nbsp;(let&nbsp;([x&nbsp;t]&nbsp;...&nbsp;[xr&nbsp;tmpr])&nbsp;.&nbsp;"
"b))))]))</tt>\n"
"</p><p>The implementation of <tt>lvhelp</tt> is complicated by the need\n"
"to evaluate all of the right-hand-side expressions before creating\n"
"any of the bindings and by the need to support improper formals\n"
"lists."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let-values&nbsp;"
"m&nbsp;(let&nbsp;([x&nbsp;t]&nbsp;...&nbsp;[xr&nbsp;tmpr])&nbsp;.&nbsp;"
"b))))]))</tt>\n"
"</p><p>Реализация <tt>lvhelp</tt> осложняется необходимостью\n"
"вычисления всех правых выражений перед созданием каких-либо\n"
"привязок и необходимостью поддержки списков неправильных форматов."

#: syntax.html:1582
msgctxt "syntax.html:1582"
msgid "</p><p>"
msgstr ""

#: syntax.html:1584
msgid ""
"</p><h3><a name=\"g137\"></a><a name=\"./syntax:h4\"></a>Section 8.4. "
"Examples<a name=\"SECTSYNTAXEXAMPLES\"></a></h3>"
msgstr ""
"</p><h3><a name=\"g137\"></a><a name=\"./syntax:h4\"></a>Section 8.4. "
"Примеры<a name=\"SECTSYNTAXEXAMPLES\"></a></h3>"

#: syntax.html:1594
msgid ""
"<p>\n"
"This section presents a series of illustrative syntactic extensions\n"
"defined with either <tt>syntax-rules</tt> or <tt>syntax-case</tt>, starting "
"with\n"
"a few simple but useful syntactic extensions and ending with a\n"
"fairly complex mechanism for defining structures with automatically\n"
"generated constructors, predicates, field accessors, and field\n"
"setters."
msgstr ""
"<p>\n"
"В этом разделе представлена серия илюстративных синтаксических расширений\n"
"определенных  как <tt>syntax-rules</tt> или <tt>syntax-case</tt>, начиная с\n"
"нескольких простых, но полезных синтаксических расширений и заканчивая\n"
"довольно сложным механизмом для определения структур с автоматически\n"
"генерируемыми конструктрорами, предикатами, процедурами доступа и установки\n"
"для полей."

#: syntax.html:1601
msgid ""
"</p><p>\n"
"The simplest example in this section is the following definition\n"
"of <a name=\"./syntax:s52\"></a><tt>rec</tt>.\n"
"<tt>rec</tt> is a syntactic extension that permits internally recursive\n"
"anonymous (not externally named) procedures to be created with\n"
"minimal effort."
msgstr ""
"</p><p>\n"
"Простейшим примером в этом разделе является следующее определение\n"
"<a name=\"./syntax:s52\"></a><tt>rec</tt>.\n"
"<tt>rec</tt> это синтаксическое расширение, которое позволяет с "
"минимальными\n"
"усилиями создавать внутренне рекурсивные анонимные (не имеющие внешнего "
"имени)\n"
"процедуры."

#: syntax.html:1603
msgctxt "syntax.html:1603"
msgid "</p><p>"
msgstr ""

#: syntax.html:1605
msgid "</p><p><tt>(define-syntax&nbsp;rec<br>"
msgstr ""

#: syntax.html:1607
msgctxt "syntax.html:1607"
msgid "&nbsp;&nbsp;(syntax-rules&nbsp;()<br>"
msgstr ""

#: syntax.html:1612
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x&nbsp;e)&nbsp;(letrec&nbsp;([x&nbsp;"
"e])&nbsp;x)]))\n"
"<br>\n"
"<br>\n"
"(map&nbsp;(rec&nbsp;sum<br>"
msgstr ""

#: syntax.html:1614
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:1616
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;"
"x&nbsp;0)<br>"
msgstr ""

#: syntax.html:1618
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;0<br>"
msgstr ""

#: syntax.html:1620
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;(+&nbsp;x&nbsp;(sum&nbsp;(-&nbsp;x&nbsp;1))))))<br>"
msgstr ""

#: syntax.html:1624
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))&nbsp;"
"<img src=\"./syntax_files/0.gif\" alt=\"&lt;graphic&gt;\">&nbsp;"
"(0&nbsp;1&nbsp;3&nbsp;6&nbsp;10&nbsp;15)</tt>\n"
"</p><p>Using <tt>rec</tt>, we can define the full <tt>let</tt> (both\n"
"unnamed and named) as follows."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))&nbsp;"
"<img src=\"./syntax_files/0.gif\" alt=\"&lt;graphic&gt;\">&nbsp;"
"(0&nbsp;1&nbsp;3&nbsp;6&nbsp;10&nbsp;15)</tt>\n"
"</p><p>Используя <tt>rec</tt>, мы можем определить полный <tt>let</tt> (как\n"
"неименованный так и именованный) следующим образом."

#: syntax.html:1626
msgctxt "syntax.html:1626"
msgid "</p><p>"
msgstr ""

#: syntax.html:1628
msgctxt "syntax.html:1628"
msgid "</p><p><tt>(define-syntax&nbsp;let<br>"
msgstr ""

#: syntax.html:1630
msgctxt "syntax.html:1630"
msgid "&nbsp;&nbsp;(syntax-rules&nbsp;()<br>"
msgstr ""

#: syntax.html:1632
msgctxt "syntax.html:1632"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((x&nbsp;e)&nbsp;...)&nbsp;b1&nbsp;"
"b2&nbsp;...)<br>"
msgstr ""

#: syntax.html:1634
msgctxt "syntax.html:1634"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((lambda&nbsp;(x&nbsp;...)&nbsp;b1&nbsp;"
"b2&nbsp;...)&nbsp;e&nbsp;...)]<br>"
msgstr ""

#: syntax.html:1636
msgctxt "syntax.html:1636"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;f&nbsp;((x&nbsp;e)&nbsp;...)&nbsp;b1&nbsp;"
"b2&nbsp;...)<br>"
msgstr ""

#: syntax.html:1640
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((rec&nbsp;f&nbsp;(lambda&nbsp;"
"(x&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...))&nbsp;e&nbsp;...)]))</tt>\n"
"</p><p>We can also define <tt>let</tt> directly in terms of\n"
"<tt>letrec</tt>, although the definition is a bit less clear."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((rec&nbsp;f&nbsp;(lambda&nbsp;"
"(x&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...))&nbsp;e&nbsp;...)]))</tt>\n"
"</p><p>Мы также можем определить <tt>let</tt> непосредственно в \n"
"терминах <tt>letrec</tt>, хотя это определение немного менее понятно."

#: syntax.html:1642
msgctxt "syntax.html:1642"
msgid "</p><p>"
msgstr ""

#: syntax.html:1644
msgid "</p><p><tt>(define-syntax&nbsp;let<a name=\"defn:let\"></a><br>"
msgstr ""

#: syntax.html:1646
msgctxt "syntax.html:1646"
msgid "&nbsp;&nbsp;(syntax-rules&nbsp;()<br>"
msgstr ""

#: syntax.html:1648
msgctxt "syntax.html:1648"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((x&nbsp;e)&nbsp;...)&nbsp;b1&nbsp;"
"b2&nbsp;...)<br>"
msgstr ""

#: syntax.html:1650
msgctxt "syntax.html:1650"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((lambda&nbsp;(x&nbsp;...)&nbsp;b1&nbsp;"
"b2&nbsp;...)&nbsp;e&nbsp;...)]<br>"
msgstr ""

#: syntax.html:1652
msgctxt "syntax.html:1652"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;f&nbsp;((x&nbsp;e)&nbsp;...)&nbsp;b1&nbsp;"
"b2&nbsp;...)<br>"
msgstr ""

#: syntax.html:1660
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((letrec&nbsp;([f&nbsp;(lambda&nbsp;"
"(x&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)])&nbsp;f)&nbsp;e&nbsp;...)]))</tt>\n"
"</p><p>These definitions rely upon the fact that the first pattern cannot\n"
"match a named <tt>let</tt>, since the first subform of a named\n"
"<tt>let</tt> must\n"
"be an identifier, not a list of bindings.\n"
"The following definition uses a fender to make this check more\n"
"robust."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((letrec&nbsp;([f&nbsp;(lambda&nbsp;"
"(x&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)])&nbsp;f)&nbsp;e&nbsp;...)]))</tt>\n"
"</p><p>Эти определения основаны на том факте, что первый образец не может\n"
"соответствовать именованному <tt>let</tt>, поскольку первая подформа в "
"именованном\n"
"<tt>let</tt> должна быть идентификатором, а не списком привязок.\n"
"В следующем определении используется дополнительное условие(fender), чтобы "
"сделать\n"
"эту проверку более надежной."

#: syntax.html:1662
msgctxt "syntax.html:1662"
msgid "</p><p>"
msgstr ""

#: syntax.html:1664
msgctxt "syntax.html:1664"
msgid "</p><p><tt>(define-syntax&nbsp;let<br>"
msgstr ""

#: syntax.html:1666
msgctxt "syntax.html:1666"
msgid "&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:1668
msgctxt "syntax.html:1668"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:1670
msgctxt "syntax.html:1670"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((x&nbsp;e)&nbsp;...)&nbsp;"
"b1&nbsp;b2&nbsp;...)<br>"
msgstr ""

#: syntax.html:1672
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'((lambda&nbsp;(x&nbsp;...)&nbsp;"
"b1&nbsp;b2&nbsp;...)&nbsp;e&nbsp;...)]<br>"
msgstr ""

#: syntax.html:1674
msgctxt "syntax.html:1674"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;f&nbsp;((x&nbsp;"
"e)&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)<br>"
msgstr ""

#: syntax.html:1676
msgctxt "syntax.html:1676"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(identifier?&nbsp;#'f)<br>"
msgstr ""

#: syntax.html:1679
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'((rec&nbsp;f&nbsp;(lambda&nbsp;"
"(x&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...))&nbsp;e&nbsp;...)])))</tt>\n"
"</p><p>With the fender, we can even put the clauses in the opposite order."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'((rec&nbsp;f&nbsp;(lambda&nbsp;"
"(x&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...))&nbsp;e&nbsp;...)])))</tt>\n"
"</p><p>С дополнительным условием(fender), мы можем даже поставить "
"предложения\n"
"в обратном порядке."

#: syntax.html:1681
msgctxt "syntax.html:1681"
msgid "</p><p>"
msgstr ""

#: syntax.html:1683
msgctxt "syntax.html:1683"
msgid "</p><p><tt>(define-syntax&nbsp;let<br>"
msgstr ""

#: syntax.html:1685
msgctxt "syntax.html:1685"
msgid "&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:1687
msgctxt "syntax.html:1687"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:1689
msgctxt "syntax.html:1689"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;f&nbsp;((x&nbsp;"
"e)&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)<br>"
msgstr ""

#: syntax.html:1691
msgctxt "syntax.html:1691"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(identifier?&nbsp;#'f)<br>"
msgstr ""

#: syntax.html:1693
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'((rec&nbsp;f&nbsp;(lambda&nbsp;"
"(x&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...))&nbsp;e&nbsp;...)]<br>"
msgstr ""

#: syntax.html:1695
msgctxt "syntax.html:1695"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((x&nbsp;e)&nbsp;...)&nbsp;"
"b1&nbsp;b2&nbsp;...)<br>"
msgstr ""

#: syntax.html:1700
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'((lambda&nbsp;(x&nbsp;...)&nbsp;"
"b1&nbsp;b2&nbsp;...)&nbsp;e&nbsp;...)])))</tt>\n"
"</p><p>To be completely robust, the <tt>ids?</tt> and <tt>unique-ids?</tt> "
"checks\n"
"employed in the definition of unnamed <tt>let</tt> in Section&nbsp;<a href="
"\"syntax.html#g136\">8.3</a>\n"
"should be employed here as well."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'((lambda&nbsp;(x&nbsp;...)&nbsp;"
"b1&nbsp;b2&nbsp;...)&nbsp;e&nbsp;...)])))</tt>\n"
"</p><p>Чтобы быть полностью надежным, проверки <tt>ids?</tt> и <tt>unique-"
"ids?</tt> \n"
"применяемые в определении неименованного <tt>let</tt> в Разделе&nbsp;<a href="
"\"syntax.html#g136\">8.3</a>\n"
"должны использоваться и здесь."

#: syntax.html:1710
msgid ""
"</p><p>\n"
"</p><p>Both variants of <tt>let</tt> are easily described by simple one-line "
"patterns,\n"
"but <tt>do</tt> requires a bit more work.\n"
"The precise syntax of <a name=\"./syntax:s53\"></a><tt>do</tt> cannot be "
"expressed directly with a\n"
"single pattern because some of the bindings in a <tt>do</tt>\n"
"expression's binding list may take the form <tt>(var&nbsp;val)</tt> while\n"
"others take the form <tt>(var&nbsp;val&nbsp;update)</tt>.\n"
"The following definition of <tt>do</tt> uses <tt>syntax-case</tt>\n"
"internally to parse the bindings separately from the overall form."
msgstr ""
"</p><p>\n"
"</p><p>Оба варианта <tt>let</tt> легко описываются простыми однострочными "
"образцами, но <tt>do</tt> \n"
"требует большей работы.\n"
"Точный синтаксис <a name=\"./syntax:s53\"></a><tt>do</tt> не может быть "
"выражен напрямую\n"
"с помощью одного образца, потому что некоторые привязки в списке привязок в  "
"выражении <tt>do</tt>\n"
"могут принимать форму <tt>(var&nbsp;val)</tt>, в то время как другие\n"
"принимают форму <tt>(var&nbsp;val&nbsp;update)</tt>.\n"
"Следующее определение <tt>do</tt> использует <tt>syntax-case</tt>\n"
"для внутреннего разбора привязок отдельно от общей формы."

#: syntax.html:1712
msgctxt "syntax.html:1712"
msgid "</p><p>"
msgstr ""

#: syntax.html:1714
msgid "</p><p><tt>(define-syntax&nbsp;do<a name=\"defn:do\"></a><br>"
msgstr ""

#: syntax.html:1716
msgctxt "syntax.html:1716"
msgid "&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:1718
msgctxt "syntax.html:1718"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:1720
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(binding&nbsp;...)&nbsp;"
"(test&nbsp;res&nbsp;...)&nbsp;expr&nbsp;...)<br>"
msgstr ""

#: syntax.html:1722
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;([((var&nbsp;"
"val&nbsp;update)&nbsp;...)<br>"
msgstr ""

#: syntax.html:1724
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;"
"(lambda&nbsp;(b)<br>"
msgstr ""

#: syntax.html:1726
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;b&nbsp;()<br>"
msgstr ""

#: syntax.html:1728
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(var&nbsp;val)&nbsp;#'(var&nbsp;"
"val&nbsp;var)]<br>"
msgstr ""

#: syntax.html:1730
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(var&nbsp;val&nbsp;update)&nbsp;"
"#'(var&nbsp;val&nbsp;update)]))<br>"
msgstr ""

#: syntax.html:1732
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;#'(binding&nbsp;...))])<br>"
msgstr ""

#: syntax.html:1734
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(let&nbsp;"
"doloop&nbsp;([var&nbsp;val]&nbsp;...)<br>"
msgstr ""

#: syntax.html:1736
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;(if&nbsp;test<br>"
msgstr ""

#: syntax.html:1738
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(if&nbsp;#f&nbsp;#f)&nbsp;"
"res&nbsp;...)<br>"
msgstr ""

#: syntax.html:1750
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;expr&nbsp;...&nbsp;(doloop&nbsp;"
"update&nbsp;...)))))])))</tt>\n"
"</p><p>The odd-looking expression <tt>(if&nbsp;#f&nbsp;#f)</tt> is inserted "
"before the\n"
"result expressions <tt>res&nbsp;...</tt> in case no result expressions are\n"
"provided, since <tt>begin</tt> requires at least one subexpression.\n"
"The value of <tt>(if&nbsp;#f&nbsp;#f)</tt> is unspecified, which is what we "
"want\n"
"since the value of <tt>do</tt> is unspecified if no result expressions\n"
"are provided.\n"
"At the expense of a bit more code, we could use <tt>syntax-case</tt> to\n"
"determine whether any result expressions are provided and to produce a\n"
"loop with either a one- or two-armed <tt>if</tt> as appropriate.\n"
"The resulting expansion would be cleaner but semantically equivalent."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;expr&nbsp;...&nbsp;(doloop&nbsp;"
"update&nbsp;...)))))])))</tt>\n"
"</p><p>Нечетное выражение <tt>(if&nbsp;#f&nbsp;#f)</tt> вставлено до\n"
"результирующего выражения <tt>res&nbsp;...</tt>, на случай отсутствия "
"результирующего\n"
"выражения, так как для <tt>begin</tt> требуется хотя бы одно подвыражение.\n"
"Значение <tt>(if&nbsp;#f&nbsp;#f)</tt> неопределено, и это то что мы "
"хотим, \n"
"поскольк значение <tt>do</tt> непоределено, если не указано результирующее "
"выражение.\n"
"За счет немного большего количества кода, мы могли бы использовать "
"<tt>syntax-case</tt>,\n"
"чтобы определить, предоставляются ли какие-либо результирующие выражения, и "
"создать\n"
"цикл с одно или двух сторонними <tt>if</tt>, если это необходимо.\n"
"Полученное расширение будет более ясным, но семантически эквивалентным."

#: syntax.html:1759
msgid ""
"</p><p>\n"
"</p><p>As mentioned in Section&nbsp;<a href=\"syntax.html#g135\">8.2</a>,\n"
"ellipses lose their special meaning\n"
"within templates of the form <tt>(...&nbsp;<i>template</i>)</tt>.\n"
"This fact allows syntactic extensions\n"
"to expand into syntax definitions containing ellipses.\n"
"This usage is illustrated by the definition below of\n"
"<a name=\"./syntax:s54\"></a><tt>be-like-begin</tt>."
msgstr ""
"</p><p>\n"
"</p><p>Как упоминалось в Разделе&nbsp;<a href=\"syntax.html#g135\">8.2</a>,\n"
"многоточия теряют свое особое значение в шаблонах вида <tt>(...&nbsp;"
"<i>template</i>)</tt>.\n"
"Этот факт позволяет синтаксическим расширениям расширяться в синтаксические\n"
"определения содержащие многоточия.\n"
"Его использование демонстрируется нижеследующим определением \n"
"<a name=\"./syntax:s54\"></a><tt>be-like-begin</tt>."

#: syntax.html:1761
msgctxt "syntax.html:1761"
msgid "</p><p>"
msgstr ""

#: syntax.html:1763
msgid "</p><p><tt>(define-syntax&nbsp;be-like-begin<br>"
msgstr ""

#: syntax.html:1765
msgctxt "syntax.html:1765"
msgid "&nbsp;&nbsp;(syntax-rules&nbsp;()<br>"
msgstr ""

#: syntax.html:1767
msgid "&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;name)<br>"
msgstr ""

#: syntax.html:1769
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define-syntax&nbsp;name<br>"
msgstr ""

#: syntax.html:1771
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>"
msgstr ""

#: syntax.html:1773
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e0&nbsp;"
"e1&nbsp;(...&nbsp;...))<br>"
msgstr ""

#: syntax.html:1778
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;"
"e0&nbsp;e1&nbsp;(...&nbsp;...))]))]))</tt>\n"
"</p><p>With <tt>be-like-begin</tt> defined in this manner,\n"
"<tt>(be-like-begin&nbsp;sequence)</tt> has the same effect as\n"
"the following definition of <a name=\"./syntax:s55\"></a><tt>sequence</tt>."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;"
"e0&nbsp;e1&nbsp;(...&nbsp;...))]))]))</tt>\n"
"</p><p>С <tt>be-like-begin</tt> определенным таким образом,\n"
"<tt>(be-like-begin&nbsp;sequence)</tt> имеет тот же эффект, что и следующее\n"
"определение <a name=\"./syntax:s55\"></a><tt>sequence</tt>."

#: syntax.html:1780
msgctxt "syntax.html:1780"
msgid "</p><p>"
msgstr ""

#: syntax.html:1782
msgid "</p><p><tt>(define-syntax&nbsp;sequence<br>"
msgstr ""

#: syntax.html:1784
msgctxt "syntax.html:1784"
msgid "&nbsp;&nbsp;(syntax-rules&nbsp;()<br>"
msgstr ""

#: syntax.html:1788
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e0&nbsp;e1&nbsp;...)&nbsp;(begin&nbsp;"
"e0&nbsp;e1&nbsp;...)]))</tt>\n"
"</p><p>That is, a <tt>sequence</tt> form becomes equivalent to a <tt>begin</"
"tt>\n"
"form so that, for example:"
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e0&nbsp;e1&nbsp;...)&nbsp;(begin&nbsp;"
"e0&nbsp;e1&nbsp;...)]))</tt>\n"
"</p><p>То есть, форма <tt>sequence</tt> становиться эквивалентной форме "
"<tt>begin</tt>,\n"
"так что, например:"

#: syntax.html:1790
msgctxt "syntax.html:1790"
msgid "</p><p>"
msgstr ""

#: syntax.html:1793
msgid ""
"</p><p><tt>(sequence&nbsp;(display&nbsp;\"Say&nbsp;what?\")&nbsp;(newline))</"
"tt>\n"
"</p><p>prints \"Say what?\" followed by a newline."
msgstr ""
"</p><p><tt>(sequence&nbsp;(display&nbsp;\"Say&nbsp;what?\")&nbsp;(newline))</"
"tt>\n"
"</p><p>печатает \"Say what?\" а затем новую строку."

#: syntax.html:1801
msgid ""
"</p><p>\n"
"</p><p>The following example shows how one might restrict\n"
"<tt>if</tt> expressions within a given expression to require the\n"
"\"else\" (alternative) subexpression by defining a local <tt>if</tt> in\n"
"terms of the built-in <tt>if</tt>.\n"
"Within the body of the <tt>let-syntax</tt> binding below,\n"
"two-armed <tt>if</tt> works as always:"
msgstr ""
"</p><p>\n"
"</p><p>В следующем примере показано, как можно ограничить выражение\n"
"<tt>if</tt>  в заданном выражении требующим подвыражения\n"
"\"else\" (альтернатива) определением локального <tt>if</tt> \n"
"в терминах встроенного <tt>if</tt>.\n"
"Внутри тела <tt>let-syntax</tt> связанный ниже,\n"
"двух сторонний <tt>if</tt> работает как обычно:"

#: syntax.html:1803
msgctxt "syntax.html:1803"
msgid "</p><p>"
msgstr ""

#: syntax.html:1805
msgctxt "syntax.html:1805"
msgid "</p><p><tt>(let-syntax&nbsp;([if&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:1807
msgctxt "syntax.html:1807"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:1809
msgctxt "syntax.html:1809"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e1&nbsp;"
"e2&nbsp;e3)<br>"
msgstr ""

#: syntax.html:1811
msgctxt "syntax.html:1811"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(if&nbsp;"
"e1&nbsp;e2&nbsp;e3)]))])<br>"
msgstr ""

#: syntax.html:1814
msgid ""
"&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;1&nbsp;5)&nbsp;2&nbsp;3))&nbsp;<img src=\"./"
"syntax_files/0.gif\" alt=\"&lt;graphic&gt;\">&nbsp;2</tt>\n"
"</p><p>but one-armed if results in a syntax error."
msgstr ""
"&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;1&nbsp;5)&nbsp;2&nbsp;3))&nbsp;<img src=\"./"
"syntax_files/0.gif\" alt=\"&lt;graphic&gt;\">&nbsp;2</tt>\n"
"</p><p>но односторонний if приводит к синтаксической ошибке."

#: syntax.html:1816
msgctxt "syntax.html:1816"
msgid "</p><p>"
msgstr ""

#: syntax.html:1818
msgctxt "syntax.html:1818"
msgid "</p><p><tt>(let-syntax&nbsp;([if&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:1820
msgctxt "syntax.html:1820"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:1822
msgctxt "syntax.html:1822"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e1&nbsp;"
"e2&nbsp;e3)<br>"
msgstr ""

#: syntax.html:1824
msgctxt "syntax.html:1824"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(if&nbsp;"
"e1&nbsp;e2&nbsp;e3)]))])<br>"
msgstr ""

#: syntax.html:1835
msgid ""
"&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;1&nbsp;5)&nbsp;2))&nbsp;<img src=\"./"
"syntax_files/0.gif\" alt=\"&lt;graphic&gt;\">&nbsp;<i>syntax&nbsp;violation</"
"i></tt>\n"
"</p><p>Although this local definition of <tt>if</tt> looks simple enough,\n"
"there are a few subtle ways in which an attempt to write it might go\n"
"wrong.\n"
"If <a name=\"./syntax:s56\"></a><tt>letrec-syntax</tt> were used in\n"
"place of <a name=\"./syntax:s57\"></a><tt>let-syntax</tt>,\n"
"the identifier <tt>if</tt> inserted into the \n"
"output would refer to the local <tt>if</tt>\n"
"rather than the built-in <tt>if</tt>, and expansion would loop\n"
"indefinitely."
msgstr ""
"&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;1&nbsp;5)&nbsp;2))&nbsp;<img src=\"./"
"syntax_files/0.gif\" alt=\"&lt;graphic&gt;\">&nbsp;<i>syntax&nbsp;violation</"
"i></tt>\n"
"</p><p>Хотя это локальное определение <tt>if</tt> выглядит достаточно "
"простым,\n"
"есть несколько тонких способов, в которых попытка написать его может пойти "
"не так.\n"
"Если <a name=\"./syntax:s56\"></a><tt>letrec-syntax</tt> использовался "
"вместо\n"
"<a name=\"./syntax:s57\"></a><tt>let-syntax</tt>,\n"
"идентификатор <tt>if</tt> вставленный в выход, будет ссылаться на локальный "
"<tt>if</tt>, \n"
"а не на встроенный <tt>if</tt>, а расширение будет работать бесконечно в "
"цикле."

#: syntax.html:1842
msgid ""
"</p><p>\n"
"Similarly, if the underscore were replaced with the identifier\n"
"<tt>if</tt>, expansion would again loop indefinitely.\n"
"The <tt>if</tt> appearing in the template <tt>(if&nbsp;e1&nbsp;e2&nbsp;e3)</"
"tt> would be treated\n"
"as a pattern variable bound to the corresponding identifier <tt>if</tt>\n"
"from the input form, which denotes the local version of <tt>if</tt>."
msgstr ""
"</p><p>\n"
"Аналогично, если знак подчеркивания был заменен идентификатором <tt>if</"
"tt>, \n"
"расширение снова запустит бесконечный цикл.\n"
"<tt>if</tt> появляющееся в шаблоне <tt>(if&nbsp;e1&nbsp;e2&nbsp;e3)</tt> "
"будет\n"
"рассматриваться как переменная образца, связанная с соответствующим\n"
"идентификатором <tt>if</tt> из входной формы, которая обозначает\n"
"локальную версию <tt>if</tt>."

#: syntax.html:1852
msgid ""
"</p><p>\n"
"Placing <tt>if</tt> in the list of literals in an attempt\n"
"to patch up the latter version would not work either.\n"
"This would cause <tt>syntax-case</tt> to compare the literal\n"
"<tt>if</tt> in the pattern, which would be scoped outside the\n"
"<tt>let-syntax</tt> expression, with the <tt>if</tt> in the\n"
"input expression, which would be scoped inside the <tt>let-syntax</tt>.\n"
"Since they would not refer to the same binding, they would not be\n"
"<tt>free-identifier=?</tt>, and a syntax violation would result."
msgstr ""
"</p><p>\n"
"Размещение <tt>if</tt> в списке литералов в попытке исправления\n"
"последней версии не будет работать.\n"
"В этом случаее <tt>syntax-case</tt> будет сравнивать литерал\n"
"<tt>if</tt> в образце, который будет ограничен пределами\n"
"выражения <tt>let-syntax</tt>, с <tt>if</tt> во входном выражении,\n"
"который будет ограничен пределами <tt>let-syntax</tt>.\n"
"Поскольку они не будут ссылаться на одну и туже привязку, они не\n"
"будут <tt>free-identifier=?</tt>, и это приведет к нарушению\n"
"синтаксиса."

#: syntax.html:1858
msgid ""
"</p><p>\n"
"The conventional use of\n"
"<a name=\"./syntax:s58\"></a><a name=\"./syntax:s59\"></a>underscore (&nbsp;"
"<tt>_</tt>&nbsp;)\n"
"helps the programmer avoid situations like these in which the wrong\n"
"identifier is matched against or inserted by accident."
msgstr ""
"</p><p>\n"
"Обычное использование\n"
"<a name=\"./syntax:s58\"></a><a name=\"./syntax:s59\"></a>подчеркивания "
"(&nbsp;<tt>_</tt>&nbsp;)\n"
"помогает программисту избежать ситуаций, подобных тем, в которых "
"неправильный\n"
"идентификатор сопоставляется опять или вставлен случайно."

#: syntax.html:1865
msgid ""
"</p><p>\n"
"</p><p>It is a syntax violation to generate a reference to an identifier "
"that is not\n"
"present within the context of an input form, which can happen if the\n"
"\"closest enclosing lexical binding\" for an identifier inserted into\n"
"the output of a transformer does not also enclose the input form.\n"
"For example,"
msgstr ""
"</p><p>\n"
"</p><p>Нарушение синтаксиса создает ссылку на идентификатор, который "
"отсутствует\n"
"в контексте входной формы, что может произойти, если\n"
"\"ближайшая охватывающая лексическая привязка\" для идентификатора "
"вставленного в\n"
"вывод преобразователя, также не охватывает входную форму.\n"
"Например,"

#: syntax.html:1867
msgctxt "syntax.html:1867"
msgid "</p><p>"
msgstr ""

#: syntax.html:1869
msgid "</p><p><tt>(let-syntax&nbsp;([divide&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:1871
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;"
"([/&nbsp;+])<br>"
msgstr ""

#: syntax.html:1873
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;(syntax-case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:1875
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;[(_&nbsp;e1&nbsp;e2)&nbsp;#'(/&nbsp;e1&nbsp;e2)])))])<br>"
msgstr ""

#: syntax.html:1881
msgid ""
"&nbsp;&nbsp;(let&nbsp;([/&nbsp;*])&nbsp;(divide&nbsp;2&nbsp;1)))</tt>\n"
"</p><p>should result in a syntax violation with a message to the effect "
"that&nbsp;<tt>/</tt>&nbsp;is referenced in an\n"
"invalid context, since the occurrence of&nbsp;<tt>/</tt>&nbsp;in the output "
"of\n"
"<tt>divide</tt> is a reference to the variable&nbsp;<tt>/</tt>&nbsp;bound by "
"the <tt>let</tt>\n"
"expression within the transformer."
msgstr ""
"&nbsp;&nbsp;(let&nbsp;([/&nbsp;*])&nbsp;(divide&nbsp;2&nbsp;1)))</tt>\n"
"</p><p>должно привести к нарушению синтаксиса с сообщением о том, что\n"
"&nbsp;<tt>/</tt>&nbsp;ссылается в недопустимом контексте, так как "
"вхождение&nbsp;<tt>/</tt>&nbsp;в вывод\n"
"<tt>divide</tt> является ссылкой на переменную&nbsp;<tt>/</tt>&nbsp; "
"связанную выражением <tt>let</tt>\n"
"внутри перобразователя."

#: syntax.html:1889
msgid ""
"</p><p>\n"
"<a name=\"./syntax:s60\"></a>The next example defines a\n"
"<a name=\"./syntax:s61\"></a><tt>define-integrable</tt>\n"
"form that is similar\n"
"to <tt>define</tt> for procedure definitions except that it causes the\n"
"code for the procedure to be <i>integrated</i>, or inserted, wherever\n"
"a direct call to the procedure is found."
msgstr ""
"</p><p>\n"
"<a name=\"./syntax:s60\"></a>Следующий пример определяет форму\n"
"<a name=\"./syntax:s61\"></a><tt>define-integrable</tt>,\n"
"которая аналогична <tt>define</tt> \n"
"для определения процедур, за исключением того, что она заставляет\n"
"код для процедуры быть встроенным(<i>integrated</i>), или вставленным, где\n"
"бы ни был найден прямой вызов процедуры."

#: syntax.html:1891
msgctxt "syntax.html:1891"
msgid "</p><p>"
msgstr ""

#: syntax.html:1893
msgctxt "syntax.html:1893"
msgid "</p><p><tt>(define-syntax&nbsp;define-integrable<br>"
msgstr ""

#: syntax.html:1895
msgctxt "syntax.html:1895"
msgid "&nbsp;&nbsp;(syntax-rules&nbsp;(lambda)<br>"
msgstr ""

#: syntax.html:1897
msgctxt "syntax.html:1897"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;name&nbsp;(lambda&nbsp;formals&nbsp;"
"form1&nbsp;form2&nbsp;...))<br>"
msgstr ""

#: syntax.html:1899
msgctxt "syntax.html:1899"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>"
msgstr ""

#: syntax.html:1901
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;xname&nbsp;"
"(lambda&nbsp;formals&nbsp;form1&nbsp;form2&nbsp;...))<br>"
msgstr ""

#: syntax.html:1903
msgctxt "syntax.html:1903"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define-syntax&nbsp;name<br>"
msgstr ""

#: syntax.html:1905
msgctxt "syntax.html:1905"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:1907
msgctxt "syntax.html:1907"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-"
"case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:1909
msgctxt "syntax.html:1909"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;[_&nbsp;(identifier?&nbsp;x)&nbsp;#'xname]<br>"
msgstr ""

#: syntax.html:1911
msgctxt "syntax.html:1911"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;[(_&nbsp;arg&nbsp;(...&nbsp;...))<br>"
msgstr ""

#: syntax.html:1913
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;#'((lambda&nbsp;formals&nbsp;form1&nbsp;form2&nbsp;...)<br>"
msgstr ""

#: syntax.html:1915
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arg<br>"
msgstr ""

#: syntax.html:1938
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(...&nbsp;...))]))))]))</tt>\n"
"</p><p>The form <tt>(define-integrable&nbsp;<i>name</i>&nbsp;<i>lambda-"
"expression</i>)</tt>\n"
"expands into a pair of definitions:  a syntax definition of <tt><i>name</i></"
"tt> and\n"
"a variable definition of <tt>xname</tt>.\n"
"The transformer for <tt><i>name</i></tt> converts apparent calls to\n"
"<tt><i>name</i></tt> into direct calls to <tt><i>lambda-expression</i></"
"tt>.\n"
"Since the resulting forms are merely direct <tt>lambda</tt> applications\n"
"(the equivalent of <tt>let</tt> expressions),\n"
"the actual parameters are evaluated exactly once and before evaluation\n"
"of the procedure's body, as required.\n"
"All other references to <tt><i>name</i></tt> are replaced with references "
"to\n"
"<tt>xname</tt>.\n"
"The definition of <tt>xname</tt> binds it to the value of\n"
"<tt><i>lambda-expression</i></tt>.\n"
"This allows the procedure to be used as a first-class value.\n"
"The <tt>define-integrable</tt> transformer does nothing special to\n"
"maintain lexical scoping within the <tt>lambda</tt> expression or at the\n"
"call site, since lexical scoping is maintained automatically by the\n"
"expander.\n"
"Also, because <tt>xname</tt> is introduced by the transformer, the binding\n"
"for <tt>xname</tt> is not visible anywhere except where references to it\n"
"are introduced by the the transformer for <tt><i>name</i></tt>."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(...&nbsp;...))]))))]))</tt>\n"
"</p><p>Форма <tt>(define-integrable&nbsp;<i>name</i>&nbsp;<i>lambda-"
"expression</i>)</tt>\n"
"расширяется в пару определений:  синтаксическое определение <tt><i>name</i></"
"tt> и\n"
"определение переменной <tt>xname</tt>.\n"
"Преобразователь для <tt><i>name</i></tt> преобразует кажущиеся вызовы \n"
"<tt><i>name</i></tt> в прямые вызовы <tt><i>lambda-expression</i></tt>.\n"
"Поскольку полученные формы являются просто прямым применением <tt>lambda</"
"tt> \n"
"(эквивалентными выражениям <tt>let</tt>),\n"
"фактические параметры вычисляются ровно один раз до вычисления\n"
"тела процедуры, если это необходимо)\n"
"Все остальные ссылки на <tt><i>name</i></tt> заменяются ссылками на\n"
"<tt>xname</tt>.\n"
"Определение <tt>xname</tt> связываетего со значением \n"
"<tt><i>lambda-expression</i></tt>.\n"
"Это позволяет использовать эту процедуру в качестве значения первого "
"класса.\n"
"Преобразователь <tt>define-integrable</tt> не делает ничего особенного для\n"
"поддержания лексического охвата в пределах <tt>lambda</tt> выражения или "
"места вызова,\n"
"поскольку область лексического охвата автоматически поддерживаетс "
"расширителем.\n"
"Кроме того, поскольку <tt>xname</tt> вводиться преобразователем, привязка "
"для\n"
" <tt>xname</tt> не видна нигде, кроме случаев, когда ссылки на нее "
"вводяться\n"
"преобразователем для <tt><i>name</i></tt>."

#: syntax.html:1947
msgid ""
"</p><p>\n"
"The above definition of <tt>define-integrable</tt> does not work for\n"
"recursive procedures, since a recursive call would cause an indefinite\n"
"number of expansion steps, likely resulting in exhaustion\n"
"of memory at expansion time.\n"
"A solution to this problem for directly recursive procedures is to wrap\n"
"each occurrence of the <tt>lambda</tt> expression with a <tt>let-syntax</"
"tt>\n"
"binding that unconditionally expands <tt><i>name</i></tt> to <tt>xname</tt>."
msgstr ""
"</p><p>\n"
"Вышеприведенное определение <tt>define-integrable</tt> не работает для\n"
"рекурсивных процедур, поскольку рекурсивный вызов вызовет неопределенное\n"
"количество шагов расширения, что вероятно, приведет к исчерпанию памяти\n"
"во время расширения.\n"
"Решение этой проблемы для непосредственно рекурсивных процедур заключается\n"
"в том, чтобы обернуть каждое вхождение <tt>lambda</tt> выражения "
"связыванием\n"
"с <tt>let-syntax</tt> которое безоговорочно расширяет <tt><i>name</i></tt> \n"
"в <tt>xname</tt>."

#: syntax.html:1949
msgctxt "syntax.html:1949"
msgid "</p><p>"
msgstr ""

#: syntax.html:1951
msgctxt "syntax.html:1951"
msgid "</p><p><tt>(define-syntax&nbsp;define-integrable<br>"
msgstr ""

#: syntax.html:1953
msgctxt "syntax.html:1953"
msgid "&nbsp;&nbsp;(syntax-rules&nbsp;(lambda)<br>"
msgstr ""

#: syntax.html:1955
msgctxt "syntax.html:1955"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;name&nbsp;(lambda&nbsp;formals&nbsp;"
"form1&nbsp;form2&nbsp;...))<br>"
msgstr ""

#: syntax.html:1957
msgctxt "syntax.html:1957"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>"
msgstr ""

#: syntax.html:1959
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;xname<br>"
msgstr ""

#: syntax.html:1961
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let-syntax&nbsp;"
"([name&nbsp;(identifier-syntax&nbsp;xname)])<br>"
msgstr ""

#: syntax.html:1963
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"(lambda&nbsp;formals&nbsp;form1&nbsp;form2&nbsp;...)))<br>"
msgstr ""

#: syntax.html:1965
msgctxt "syntax.html:1965"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define-syntax&nbsp;name<br>"
msgstr ""

#: syntax.html:1967
msgctxt "syntax.html:1967"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:1969
msgctxt "syntax.html:1969"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-"
"case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:1971
msgctxt "syntax.html:1971"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;[_&nbsp;(identifier?&nbsp;x)&nbsp;#'xname]<br>"
msgstr ""

#: syntax.html:1973
msgctxt "syntax.html:1973"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;[(_&nbsp;arg&nbsp;(...&nbsp;...))<br>"
msgstr ""

#: syntax.html:1975
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;#'((let-syntax&nbsp;([name&nbsp;(identifier-syntax&nbsp;"
"xname)])<br>"
msgstr ""

#: syntax.html:1977
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;formals&nbsp;"
"form1&nbsp;form2&nbsp;...))<br>"
msgstr ""

#: syntax.html:1983
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arg&nbsp;(...&nbsp;...))]))))]))</tt>\n"
"</p><p>This problem can be solved for mutually recursive procedures by\n"
"replacing the <tt>let-syntax</tt> forms with the nonstandard\n"
"<tt>fluid-let-syntax</tt> form, which is described in the <i>Chez Scheme\n"
"User's Guide</i>&nbsp;[<a class=\"citation\" href=\"bibliography."
"html#g227\">9</a>]."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arg&nbsp;(...&nbsp;...))]))))]))</tt>\n"
"</p><p>Эта проблема может быть решена для взаимнорекурсивных процедур путем "
"замены\n"
"форм <tt>let-syntax</tt> на нестандартную форму <tt>fluid-let-syntax</tt>,\n"
"которая описана в <i>Руководстве пользователя Chez Scheme \n"
"</i>&nbsp;[<a class=\"citation\" href=\"bibliography.html#g227\">9</a>]."

#: syntax.html:1994
msgid ""
"</p><p>\n"
"</p><p>Both definitions of <tt>define-integrable</tt> treat\n"
"the case where an identifier appears\n"
"in the first position of a structured expression differently from\n"
"the case where it appears elsewhere, as does the <tt>pcar</tt> example "
"given\n"
"in the description for <tt>identifier?</tt>.\n"
"In other situations, both cases must be treated the same.\n"
"The form <a name=\"./syntax:s62\"></a><tt>identifier-syntax</tt>\n"
"can make doing so more\n"
"convenient<a name=\"./syntax:s63\"></a>."
msgstr ""
"</p><p>\n"
"</p><p>Оба определения <tt>define-integrable</tt> относятся\n"
"к случаю, когда идентификатор появляется в первой позиции\n"
"структурированного выражения отличающегося от\n"
"случая когда он появляется в другом месте, как в примере <tt>pcar</tt>\n"
"приведенном в описании для <tt>identifier?</tt>.\n"
"В других ситуациях, оба случая должны рассматриваться одинаково.\n"
"Форма <a name=\"./syntax:s62\"></a><tt>identifier-syntax</tt>\n"
"может сделать это более удобным.\n"
"<a name=\"./syntax:s63\"></a>."

#: syntax.html:1996
msgctxt "syntax.html:1996"
msgid "</p><p>"
msgstr ""

#: syntax.html:1998
msgid "</p><p><tt>(let&nbsp;([x&nbsp;0])<br>"
msgstr ""

#: syntax.html:2000
msgid "&nbsp;&nbsp;(define-syntax&nbsp;x++<br>"
msgstr ""

#: syntax.html:2002
msgctxt "syntax.html:2002"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(identifier-syntax<br>"
msgstr ""

#: syntax.html:2004
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([t&nbsp;x])<br>"
msgstr ""

#: syntax.html:2006
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;x&nbsp;(+&nbsp;"
"t&nbsp;1))&nbsp;t)))<br>"
msgstr ""

#: syntax.html:2028
msgid ""
"&nbsp;&nbsp;(let&nbsp;([a&nbsp;x++])&nbsp;(list&nbsp;a&nbsp;x)))&nbsp;<img "
"src=\"./syntax_files/0.gif\" alt=\"&lt;graphic&gt;\">&nbsp;(0&nbsp;1)</tt>\n"
"</p><p></p><p>The following example uses\n"
"<a name=\"./syntax:s64\"></a><tt>identifier-syntax</tt>,\n"
"<a name=\"./syntax:s65\"></a><tt>datum-&gt;syntax</tt>,\n"
"and local syntax definitions to define a form of <i>method</i>, one\n"
"of the basic building blocks of\n"
"<a name=\"./syntax:s66\"></a>object-oriented programming (OOP)\n"
"systems.\n"
"A <a name=\"./syntax:s67\"></a><tt>method</tt> expression is similar to\n"
"a <tt>lambda</tt> expression, except\n"
"that in addition to the formal parameters and body, a <tt>method</tt>\n"
"expression also contains a list of instance variables <tt>(ivar&nbsp;...)</"
"tt>.\n"
"When a method is invoked, it is always passed an <i>object</i>\n"
"(<i>instance</i>),\n"
"represented as a vector of <i>fields</i> corresponding to the\n"
"instance variables, and zero or more additional arguments.\n"
"Within the method body, the object is bound implicitly to the\n"
"identifier <tt>self</tt> and the additional arguments are bound to the\n"
"formal parameters.\n"
"The fields of the object may be accessed or altered within the\n"
"method body via instance variable references or assignments."
msgstr ""
"&nbsp;&nbsp;(let&nbsp;([a&nbsp;x++])&nbsp;(list&nbsp;a&nbsp;x)))&nbsp;<img "
"src=\"./syntax_files/0.gif\" alt=\"&lt;graphic&gt;\">&nbsp;(0&nbsp;1)</tt>\n"
"</p><p></p><p>В следующем примере используются\n"
"<a name=\"./syntax:s64\"></a><tt>identifier-syntax</tt>,\n"
"<a name=\"./syntax:s65\"></a><tt>datum-&gt;syntax</tt>,\n"
"и локальные синтаксические определения для опредления формы <i>method</i>, "
"одной\n"
"из основных строительных блоков систем\n"
"<a name=\"./syntax:s66\"></a>объектно-ориентированного "
"программирования(ООП)\n"
"Выражение <a name=\"./syntax:s67\"></a><tt>method</tt> аналогично выражению\n"
"<tt>lambda</tt>, за исключением того, что помимо формальных параметров и\n"
"тела выражения, выражение <tt>method</tt> содержит список переменных "
"экземпляра\n"
"<tt>(ivar&nbsp;...)</tt>.\n"
"Когда метод вызывается, он всегда передается объекту-<i>object</i>\n"
"(<i>instance</i>-экземпляру),\n"
"представленному как вектор полей <i>fields</i> соответствующих переменных\n"
"экземпляра, и нулю или более дополнительных аргументов.\n"
"Внури тела метода объект привязан к неявному идентификатору <tt>self</tt> \n"
"и в дополнительные параметры связаны с формальными параметрами.\n"
"Поля объекта могут быть доступны или изменены внутри тела метода\n"
"посредством ссылок или присвоений переменным экземпляра."

#: syntax.html:2030
msgctxt "syntax.html:2030"
msgid "</p><p>"
msgstr ""

#: syntax.html:2032
msgid "</p><p><tt>(define-syntax&nbsp;method<a name=\"defn:method\"></a><br>"
msgstr ""

#: syntax.html:2034
msgctxt "syntax.html:2034"
msgid "&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:2036
msgctxt "syntax.html:2036"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:2038
msgctxt "syntax.html:2038"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(k&nbsp;(ivar&nbsp;...)&nbsp;"
"formals&nbsp;b1&nbsp;b2&nbsp;...)<br>"
msgstr ""

#: syntax.html:2040
msgctxt "syntax.html:2040"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;"
"([(index&nbsp;...)<br>"
msgstr ""

#: syntax.html:2042
msgctxt "syntax.html:2042"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;"
"([i&nbsp;0]&nbsp;[ls&nbsp;#'(ivar&nbsp;...)])<br>"
msgstr ""

#: syntax.html:2044
msgctxt "syntax.html:2044"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"(if&nbsp;(null?&nbsp;ls)<br>"
msgstr ""

#: syntax.html:2046
msgctxt "syntax.html:2046"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;'()<br>"
msgstr ""

#: syntax.html:2048
msgctxt "syntax.html:2048"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;i&nbsp;(f&nbsp;(+&nbsp;i&nbsp;1)&nbsp;"
"(cdr&nbsp;ls)))))]<br>"
msgstr ""

#: syntax.html:2050
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[self&nbsp;(datum-&gt;"
"syntax&nbsp;#'k&nbsp;'self)]<br>"
msgstr ""

#: syntax.html:2052
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[set!&nbsp;(datum-&gt;"
"syntax&nbsp;#'k&nbsp;'set!)])<br>"
msgstr ""

#: syntax.html:2054
msgctxt "syntax.html:2054"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(lambda&nbsp;"
"(self&nbsp;.&nbsp;formals)<br>"
msgstr ""

#: syntax.html:2056
msgctxt "syntax.html:2056"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;(let-syntax&nbsp;([ivar&nbsp;(identifier-syntax<br>"
msgstr ""

#: syntax.html:2058
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector-ref&nbsp;"
"self&nbsp;index))]<br>"
msgstr ""

#: syntax.html:2060
msgctxt "syntax.html:2060"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;...)<br>"
msgstr ""

#: syntax.html:2062
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;(let-syntax&nbsp;([set!<br>"
msgstr ""

#: syntax.html:2064
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;(ivar&nbsp;...)<br>"
msgstr ""

#: syntax.html:2066
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;ivar&nbsp;e)&nbsp;(vector-"
"set!&nbsp;self&nbsp;index&nbsp;e)]<br>"
msgstr ""

#: syntax.html:2068
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>"
msgstr ""

#: syntax.html:2070
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x&nbsp;e)&nbsp;(set!&nbsp;"
"x&nbsp;e)])])<br>"
msgstr ""

#: syntax.html:2080
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b1&nbsp;b2&nbsp;...))))])))</tt>\n"
"</p><p>Local bindings for <tt>ivar&nbsp;...</tt> and for <tt>set!</tt> make "
"the fields of\n"
"the object appear to be ordinary variables, with references and\n"
"assignments translated into calls to <tt>vector-ref</tt> and <tt>vector-set!"
"</tt>.\n"
"<tt>datum-&gt;syntax</tt> is used to make the introduced\n"
"bindings of <tt>self</tt> and <tt>set!</tt> visible in the method body.\n"
"Nested <tt>let-syntax</tt> expressions are needed so that the identifiers\n"
"<tt>ivar&nbsp;...</tt> serving as auxiliary keywords for the local version "
"of\n"
"<tt>set!</tt> are scoped properly."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b1&nbsp;b2&nbsp;...))))])))</tt>\n"
"</p><p>Локальные привязки для <tt>ivar&nbsp;...</tt> и для <tt>set!</tt> "
"делают поля\n"
"объекта кажущимися обычными переменными,  сслыки и присваивания которым\n"
"преобразуются в вызовы <tt>vector-ref</tt> и <tt>vector-set!</tt>.\n"
"<tt>datum-&gt;syntax</tt> используется для создания видимыми введенных \n"
"привязок <tt>self</tt> и <tt>set!</tt> в теле метода.\n"
"Вложенные выражения <tt>let-syntax</tt> необходимы, чтобы идентификаторы\n"
"<tt>ivar&nbsp;...</tt> служили вспомогательными ключевыми словами для "
"локальной\n"
"версии <tt>set!</tt> должным образом."

#: syntax.html:2084
msgid ""
"</p><p>\n"
"<a name=\"./syntax:s68\"></a>By using the general form of <tt>identifier-"
"syntax</tt> to handle <tt>set!</tt>\n"
"forms more directly, we can simplify the definition of <tt>method</tt>."
msgstr ""
"</p><p>\n"
"<a name=\"./syntax:s68\"></a>Используя общую форму <tt>identifier-syntax</"
"tt> для обработки форм <tt>set!</tt>\n"
"напрямую, мы можем упростить определение <tt>method</tt>."

#: syntax.html:2086
msgctxt "syntax.html:2086"
msgid "</p><p>"
msgstr ""

#: syntax.html:2088
msgid "</p><p><tt>(define-syntax&nbsp;method<br>"
msgstr ""

#: syntax.html:2090
msgctxt "syntax.html:2090"
msgid "&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:2092
msgctxt "syntax.html:2092"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:2094
msgctxt "syntax.html:2094"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(k&nbsp;(ivar&nbsp;...)&nbsp;"
"formals&nbsp;b1&nbsp;b2&nbsp;...)<br>"
msgstr ""

#: syntax.html:2096
msgctxt "syntax.html:2096"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;"
"([(index&nbsp;...)<br>"
msgstr ""

#: syntax.html:2098
msgctxt "syntax.html:2098"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;"
"([i&nbsp;0]&nbsp;[ls&nbsp;#'(ivar&nbsp;...)])<br>"
msgstr ""

#: syntax.html:2100
msgctxt "syntax.html:2100"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"(if&nbsp;(null?&nbsp;ls)<br>"
msgstr ""

#: syntax.html:2102
msgctxt "syntax.html:2102"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;'()<br>"
msgstr ""

#: syntax.html:2104
msgctxt "syntax.html:2104"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;i&nbsp;(f&nbsp;(+&nbsp;i&nbsp;1)&nbsp;"
"(cdr&nbsp;ls)))))]<br>"
msgstr ""

#: syntax.html:2106
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[self&nbsp;(datum-&gt;"
"syntax&nbsp;#'k&nbsp;'self)])<br>"
msgstr ""

#: syntax.html:2108
msgctxt "syntax.html:2108"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(lambda&nbsp;"
"(self&nbsp;.&nbsp;formals)<br>"
msgstr ""

#: syntax.html:2110
msgctxt "syntax.html:2110"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;(let-syntax&nbsp;([ivar&nbsp;(identifier-syntax<br>"
msgstr ""

#: syntax.html:2112
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[_&nbsp;(vector-"
"ref&nbsp;self&nbsp;index)]<br>"
msgstr ""

#: syntax.html:2114
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(set!&nbsp;"
"_&nbsp;e)<br>"
msgstr ""

#: syntax.html:2116
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector-"
"set!&nbsp;self&nbsp;index&nbsp;e)])]<br>"
msgstr ""

#: syntax.html:2118
msgctxt "syntax.html:2118"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;...)<br>"
msgstr ""

#: syntax.html:2121
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;b1&nbsp;b2&nbsp;...)))])))</tt>\n"
"</p><p>The examples below demonstrate simple uses of <tt>method</tt>."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;b1&nbsp;b2&nbsp;...)))])))</tt>\n"
"</p><p>Примеры ниже демонстрируют простое использование <tt>method</tt>."

#: syntax.html:2123
msgctxt "syntax.html:2123"
msgid "</p><p>"
msgstr ""

#: syntax.html:2125
msgid ""
"</p><p><tt>(let&nbsp;([m&nbsp;(method&nbsp;(a)&nbsp;(x)&nbsp;(list&nbsp;"
"a&nbsp;x&nbsp;self))])<br>"
msgstr ""

#: syntax.html:2130
msgid ""
"&nbsp;&nbsp;(m&nbsp;#(1)&nbsp;2))&nbsp;<img src=\"./syntax_files/0.gif\" alt="
"\"&lt;graphic&gt;\">&nbsp;(1&nbsp;2&nbsp;#(1))\n"
"<br>\n"
"<br>\n"
"(let&nbsp;([m&nbsp;(method&nbsp;(a)&nbsp;(x)<br>"
msgstr ""

#: syntax.html:2132
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;"
"a&nbsp;x)<br>"
msgstr ""

#: syntax.html:2134
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;"
"x&nbsp;(+&nbsp;a&nbsp;x))<br>"
msgstr ""

#: syntax.html:2136
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;"
"a&nbsp;x&nbsp;self))])<br>"
msgstr ""

#: syntax.html:2143
msgid ""
"&nbsp;&nbsp;(m&nbsp;#(1)&nbsp;2))&nbsp;<img src=\"./syntax_files/0.gif\" alt="
"\"&lt;graphic&gt;\">&nbsp;(2&nbsp;4&nbsp;#(2))</tt>\n"
"</p><p>In a complete OOP system based on <tt>method</tt>, the instance "
"variables\n"
"<tt>ivar&nbsp;...</tt> would likely be drawn from class declarations, not\n"
"listed explicitly in the <tt>method</tt> forms, although the same "
"techniques\n"
"would be used to make instance variables appear as ordinary variables\n"
"within method bodies."
msgstr ""
"&nbsp;&nbsp;(m&nbsp;#(1)&nbsp;2))&nbsp;<img src=\"./syntax_files/0.gif\" alt="
"\"&lt;graphic&gt;\">&nbsp;(2&nbsp;4&nbsp;#(2))</tt>\n"
"</p><p>В полной ООП системе, основанной на <tt>method</tt>, переменные "
"экземпляра\n"
"<tt>ivar&nbsp;...</tt> вероятно, будут сфрмированы из объявлений классов, не "
"указанных\n"
"явно, в формах  <tt>method</tt>, хотя те же методы будут использоваться, "
"чтобы \n"
"переменные экземпляра отображались как обычные переменные в телах методов."

#: syntax.html:2151
msgid ""
"</p><p>\n"
"</p><p><a name=\"./syntax:s69\"></a>The final example of this section "
"defines a simple structure\n"
"definition facility that represents structures as vectors with\n"
"named fields.\n"
"Structures are defined with\n"
"<a name=\"./syntax:s70\"></a><tt>define-structure</tt>, which takes the\n"
"form"
msgstr ""
"</p><p>\n"
"</p><p><a name=\"./syntax:s69\"></a>Последний пример этого раздела "
"определяет средство\n"
"определения простой структуры, которая представляет структуру типа вектора "
"с\n"
"именованными полями.\n"
"Структуры определяются с помощью\n"
"<a name=\"./syntax:s70\"></a><tt>define-structure</tt>, которая принимает "
"форму"

#: syntax.html:2153
msgctxt "syntax.html:2153"
msgid "</p><p>"
msgstr ""

#: syntax.html:2161
msgid ""
"</p><p><tt>(define-structure&nbsp;<i>name</i>&nbsp;<i>field</i>&nbsp;...)</"
"tt>\n"
"</p><p>where <tt><i>name</i></tt> names the structure and <tt><i>field</"
"i>&nbsp;...</tt> names its\n"
"fields.\n"
"<tt>define-structure</tt> expands into a series of generated definitions:\n"
"a constructor <tt>make-<i>name</i></tt>, a type predicate <tt><i>name</i>?</"
"tt>,\n"
"and one accessor <tt><i>name</i>-<i>field</i></tt> and setter\n"
"<tt>set-<i>name</i>-<i>field</i>!</tt> per field name."
msgstr ""
"</p><p><tt>(define-structure&nbsp;<i>name</i>&nbsp;<i>field</i>&nbsp;...)</"
"tt>\n"
"</p><p>где <tt><i>name</i></tt> именуют структуру и <tt><i>field</i>&nbsp;..."
"</tt> именуют ее\n"
"поля.\n"
"<tt>define-structure</tt> расширяется в ряд сгенерированных определений:\n"
"конструктор <tt>make-<i>name</i></tt>, предикат типа <tt><i>name</i>?</tt>,\n"
"и по одной процедуре доступа к полю(accessor) <tt><i>name</i>-<i>field</i></"
"tt> и одному\n"
"установщику поля(setter)  <tt>set-<i>name</i>-<i>field</i>!</tt> для "
"каждого\n"
"имени поля."

#: syntax.html:2163
msgctxt "syntax.html:2163"
msgid "</p><p>"
msgstr ""

#: syntax.html:2166
msgid "</p><p><tt>(define-syntax&nbsp;define-structure<br>"
msgstr ""

#: syntax.html:2168
msgctxt "syntax.html:2168"
msgid "&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:2170
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;gen-id<br>"
msgstr ""

#: syntax.html:2172
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(template-id&nbsp;.&nbsp;"
"args)<br>"
msgstr ""

#: syntax.html:2174
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(datum-&gt;syntax&nbsp;"
"template-id<br>"
msgstr ""

#: syntax.html:2176
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-&gt;"
"symbol<br>"
msgstr ""

#: syntax.html:2178
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"(apply&nbsp;string-append<br>"
msgstr ""

#: syntax.html:2180
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:2182
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(string?&nbsp;"
"x)<br>"
msgstr ""

#: syntax.html:2184
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;x<br>"
msgstr ""

#: syntax.html:2186
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;(symbol-&gt;string&nbsp;(syntax-&gt;datum&nbsp;x))))<br>"
msgstr ""

#: syntax.html:2188
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args))))))<br>"
msgstr ""

#: syntax.html:2190
msgctxt "syntax.html:2190"
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>"
msgstr ""

#: syntax.html:2192
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;name&nbsp;field&nbsp;...)<br>"
msgstr ""

#: syntax.html:2194
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;"
"([constructor&nbsp;(gen-id&nbsp;#'name&nbsp;\"make-\"&nbsp;#'name)]<br>"
msgstr ""

#: syntax.html:2196
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[predicate&nbsp;(gen-"
"id&nbsp;#'name&nbsp;#'name&nbsp;\"?\")]<br>"
msgstr ""

#: syntax.html:2198
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(access&nbsp;...)<br>"
msgstr ""

#: syntax.html:2200
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;"
"(lambda&nbsp;(x)&nbsp;(gen-id&nbsp;x&nbsp;#'name&nbsp;\"-\"&nbsp;x))<br>"
msgstr ""

#: syntax.html:2202
msgctxt "syntax.html:2202"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;#'(field&nbsp;...))]<br>"
msgstr ""

#: syntax.html:2204
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(assign&nbsp;...)<br>"
msgstr ""

#: syntax.html:2206
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;"
"(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:2208
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(gen-id&nbsp;x&nbsp;\"set-\"&nbsp;#'name&nbsp;"
"\"-\"&nbsp;x&nbsp;\"!\"))<br>"
msgstr ""

#: syntax.html:2210
msgctxt "syntax.html:2210"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;#'(field&nbsp;...))]<br>"
msgstr ""

#: syntax.html:2212
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[structure-length&nbsp;"
"(+&nbsp;(length&nbsp;#'(field&nbsp;...))&nbsp;1)]<br>"
msgstr ""

#: syntax.html:2214
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(index&nbsp;...)<br>"
msgstr ""

#: syntax.html:2216
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;"
"([i&nbsp;1]&nbsp;[ids&nbsp;#'(field&nbsp;...)])<br>"
msgstr ""

#: syntax.html:2218
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"(if&nbsp;(null?&nbsp;ids)<br>"
msgstr ""

#: syntax.html:2220
msgctxt "syntax.html:2220"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;'()<br>"
msgstr ""

#: syntax.html:2222
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;i&nbsp;(f&nbsp;(+&nbsp;i&nbsp;1)&nbsp;"
"(cdr&nbsp;ids)))))])<br>"
msgstr ""

#: syntax.html:2224
msgid "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(begin<br>"
msgstr ""

#: syntax.html:2226
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;(define&nbsp;constructor<br>"
msgstr ""

#: syntax.html:2228
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;(lambda&nbsp;(field&nbsp;...)<br>"
msgstr ""

#: syntax.html:2230
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector&nbsp;'name&nbsp;field&nbsp;...)))<br>"
msgstr ""

#: syntax.html:2232
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;(define&nbsp;predicate<br>"
msgstr ""

#: syntax.html:2234
msgctxt "syntax.html:2234"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:2236
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(vector?&nbsp;x)<br>"
msgstr ""

#: syntax.html:2238
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(=&nbsp;(vector-"
"length&nbsp;x)&nbsp;structure-length)<br>"
msgstr ""

#: syntax.html:2240
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eq?&nbsp;"
"(vector-ref&nbsp;x&nbsp;0)&nbsp;'name))))<br>"
msgstr ""

#: syntax.html:2242
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;(define&nbsp;access<br>"
msgstr ""

#: syntax.html:2244
msgctxt "syntax.html:2244"
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>"
msgstr ""

#: syntax.html:2246
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector-ref&nbsp;x&nbsp;index)))<br>"
msgstr ""

#: syntax.html:2248
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;...<br>"
msgstr ""

#: syntax.html:2250
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;(define&nbsp;assign<br>"
msgstr ""

#: syntax.html:2252
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;update)<br>"
msgstr ""

#: syntax.html:2254
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector-set!&nbsp;x&nbsp;index&nbsp;"
"update)))<br>"
msgstr ""

#: syntax.html:2262
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;...))])))</tt>\n"
"</p><p>\n"
"</p><p>The constructor accepts as many arguments as there are fields in the\n"
"structure and creates a vector whose first element is the symbol\n"
"<tt><i>name</i></tt> and whose remaining elements are the argument values.\n"
"The type predicate returns true if its argument is a vector\n"
"of the expected length whose first element is <tt><i>name</i></tt>."
msgstr ""
"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
"&nbsp;...))])))</tt>\n"
"</p><p>\n"
"</p><p>Конструктор принимает столько аргументов, сколько полей в структуре, "
"и создает вектор,\n"
"первым элементом которого является символ\n"
"<tt><i>name</i></tt>(имя структуры), а остальные элементы значения "
"аргументов.\n"
"Предикат типа возвращает истину если его аргумент представляет собой вектор "
"ожидаемой длины,\n"
"первым элементом которого является <tt><i>name</i></tt>."

#: syntax.html:2267
msgid ""
"</p><p>\n"
"Since a <tt>define-structure</tt> form expands into a <tt>begin</tt> "
"containing\n"
"definitions, it is itself a definition and can be used wherever\n"
"definitions are valid."
msgstr ""
"</p><p>\n"
"Поскольку форма <tt>define-structure</tt> расширяется в <tt>begin</tt> "
"содержащее\n"
"определения, она сама по себе является определением и может использоваться "
"везде,\n"
"где определения допустимы."

#: syntax.html:2272
msgid ""
"</p><p>\n"
"The generated identifiers are created with\n"
"<a name=\"./syntax:s71\"></a><tt>datum-&gt;syntax</tt> to allow the "
"identifiers to be visible\n"
"where the <tt>define-structure</tt> form appears."
msgstr ""
"</p><p>\n"
"Сгенерированные идентификаторы создаются с помощью синтаксиса\n"
"<a name=\"./syntax:s71\"></a><tt>datum-&gt;syntax</tt>, чтобы позволить "
"идентификаторам быть\n"
"видимыми, везде где появляется форма <tt>define-structure</tt>."

#: syntax.html:2275
msgid ""
"</p><p>\n"
"The examples below demonstrate the use of <tt>define-structure</tt>."
msgstr ""
"</p><p>\n"
"Приведенные ниже примеры демонстрируют испольование <tt>define-structure</"
"tt>."

#: syntax.html:2277
msgctxt "syntax.html:2277"
msgid "</p><p>"
msgstr ""

#: syntax.html:2279
msgid "</p><p><tt>(define-structure&nbsp;tree&nbsp;left&nbsp;right)<br>"
msgstr ""

#: syntax.html:2281
msgid "(define&nbsp;t<br>"
msgstr ""

#: syntax.html:2283
msgid "&nbsp;&nbsp;(make-tree<br>"
msgstr ""

#: syntax.html:2285
msgid "&nbsp;&nbsp;&nbsp;&nbsp;(make-tree&nbsp;0&nbsp;1)<br>"
msgstr ""

#: syntax.html:2290
msgid ""
"&nbsp;&nbsp;&nbsp;&nbsp;(make-tree&nbsp;2&nbsp;3)))\n"
"<br>\n"
"<br>\n"
"t&nbsp;<img src=\"./syntax_files/0.gif\" alt=\"&lt;graphic&gt;\">&nbsp;"
"#(tree&nbsp;#(tree&nbsp;0&nbsp;1)&nbsp;#(tree&nbsp;2&nbsp;3))<br>"
msgstr ""

#: syntax.html:2292
msgid ""
"(tree?&nbsp;t)&nbsp;<img src=\"./syntax_files/0.gif\" alt=\"&lt;graphic&gt;"
"\">&nbsp;#t<br>"
msgstr ""

#: syntax.html:2294
msgid ""
"(tree-left&nbsp;t)&nbsp;<img src=\"./syntax_files/0.gif\" alt=\"&lt;"
"graphic&gt;\">&nbsp;#(tree&nbsp;0&nbsp;1)<br>"
msgstr ""

#: syntax.html:2296
msgid ""
"(tree-right&nbsp;t)&nbsp;<img src=\"./syntax_files/0.gif\" alt=\"&lt;"
"graphic&gt;\">&nbsp;#(tree&nbsp;2&nbsp;3)<br>"
msgstr ""

#: syntax.html:2298
msgid "(set-tree-left!&nbsp;t&nbsp;0)<br>"
msgstr ""

#: syntax.html:2301
msgid ""
"t&nbsp;<img src=\"./syntax_files/0.gif\" alt=\"&lt;graphic&gt;\">&nbsp;"
"#(tree&nbsp;0&nbsp;#(tree&nbsp;2&nbsp;3))</tt>\n"
"</p><p>"
msgstr ""

#: syntax.html:2313
msgid ""
"</p><hr class=\"copyright\" align=\"left\">\n"
"<p>\n"
"R. Kent Dybvig / <it>The Scheme Programming Language, Fourth Edition</"
"it><br>\n"
"Copyright © 2009 <a class=\"plain\" href=\"http://mitpress.mit.edu/catalog/"
"item/default.asp?ttype=2&amp;tid=11984\">The MIT Press</a>.  Electronically "
"reproduced by permission.<br>\n"
"Illustrations © 2009 <a class=\"plain\" href=\"http://hebert.kitp.ucsb.edu/"
"\">Jean-Pierre Hébert</a><br>\n"
"ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93<br>\n"
"<a class=\"plain\" href=\"http://mitpress.mit.edu/catalog/item/default.asp?"
"ttype=2&amp;tid=11984\">to order this book</a> / <a class=\"plain\" href="
"\"canned/about.html\">about this book</a>\n"
"</p>\n"
"<p><a class=\"plain\" href=\"http://www.scheme.com/\">http://www.scheme.com</"
"a></p>"
msgstr ""

#: syntax.html:2315
msgid "</body></html>"
msgstr ""
